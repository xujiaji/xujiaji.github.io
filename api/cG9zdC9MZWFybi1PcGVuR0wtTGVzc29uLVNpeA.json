{"title":"OpenGL Android课程六：介绍纹理过滤","date":"2019-02-19T08:24:18.000Z","author":"xujiaji","thumbnail":"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190224214007.jpg","slug":"Learn-OpenGL-Lesson-Six","comments":true,"tags":["Android","OpenGL","学习","翻译"],"categories":["OpenGL"],"updated":"2019-03-26T09:09:17.193Z","content":"<blockquote>\n<p>翻译文</p>\n</blockquote>\n<p>原文标题：Android Lesson Six: An Introduction to Texture Filtering<br>原文链接：<a href=\"http://www.learnopengles.com/android-lesson-six-an-introduction-to-texture-filtering/\" target=\"_blank\" rel=\"noopener\">http://www.learnopengles.com/android-lesson-six-an-introduction-to-texture-filtering/</a><br><a id=\"more\"></a></p>\n<hr>\n<h1 id=\"介绍纹理过滤\">介绍纹理过滤<a href=\"post/Learn-OpenGL-Lesson-Six#介绍纹理过滤\"></a></h1><div class=\"article-bounded\"><div class=\"article-table\"><table>\n\n<tbody>\n<tr>\n<td>这节课，我们将介绍基本纹理过滤的不同类型和怎样使用它们，<br>包括最邻近（nearest-neighbour）过滤，<a href=\"https://en.wikipedia.org/wiki/Bilinear_filtering\" target=\"_blank\" rel=\"noopener\">双线性(bilinear)过滤</a>，<br>和使用mipmap的<a href=\"https://en.wikipedia.org/wiki/Trilinear_filtering\" target=\"_blank\" rel=\"noopener\">三线性(trilinear)过滤</a>。<br><br>你将学习如何使纹理看起来更平滑，以及平滑带来的缺点。<br>[这儿有旋转物体][]的不同方式，本课使用了其中一。</td>\n<td style=\"text-align:center\"><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190219164050.png\" alt=\"screenshot\"></td>\n</tr>\n</tbody>\n</table></div></div>\n<h2 id=\"前提条件\">前提条件<a href=\"post/Learn-OpenGL-Lesson-Six#前提条件\"></a></h2><p>强烈建议您先阅读<a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four\">OpenGL Android课程四：介绍纹理基础</a>，理解纹理映射在OpenGL中的基本使用。</p>\n<h2 id=\"什么是纹理过滤？\">什么是纹理过滤？<a href=\"post/Learn-OpenGL-Lesson-Six#什么是纹理过滤？\"></a></h2><p>OpenGLES中的纹理由元素数组组成，被称为纹素(texels)，其中包含颜色和alpha值。这与显示器相对应，显示器由一堆像素组成，并在每个点显示不同的颜色。在OpenGL中纹理被用在三角形上并绘制到屏幕，因此这些纹理能绘制出各种各样的尺寸和方向。OpenGL中的纹理过滤选项告诉它如何根据具体情况将纹理像素过滤到设备的像素上。</p>\n<blockquote>\n<p>有三种情况：</p>\n</blockquote>\n<ul>\n<li>每个纹素映射到多个像素，这被称为放大(magnification)</li>\n<li>每个纹素精确的映射到一个像素，过滤不适合这种情况</li>\n<li>每个纹素映射少于一个像素，这被称为缩小(minification)</li>\n</ul>\n<p>OpenGL允许我们为放大和缩小分配过滤器，并允许我们使用最邻近、双线性和三线性过滤。我们将在下面解释这些意思。</p>\n<h2 id=\"放大和缩小\">放大和缩小<a href=\"post/Learn-OpenGL-Lesson-Six#放大和缩小\"></a></h2><p>这里是放大和缩小的最邻近渲染的可视化，当您用USB连接你的Android设备时使用这个可爱的Android显示成功连接。</p>\n<div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221100843.png\" alt=\"cute android\" data-zoomable=\"\"></p></div>\n<h3 id=\"放大\">放大<a href=\"post/Learn-OpenGL-Lesson-Six#放大\"></a></h3><div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221100936.png\" alt=\"magnification android\" data-zoomable=\"\"></p></div>\n<p>正如您所见，纹素现在很容易看到，因为当前一个纹素覆盖了很多像素展示出来。</p>\n<h3 id=\"缩小\">缩小<a href=\"post/Learn-OpenGL-Lesson-Six#缩小\"></a></h3><div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221101211.png\" alt=\"minification android\" data-zoomable=\"\"></p></div>\n<p>随着缩小，许多纹素不能渲染到有限的像素上，许多细节将会丢失。</p>\n<h2 id=\"纹理过滤模式\">纹理过滤模式<a href=\"post/Learn-OpenGL-Lesson-Six#纹理过滤模式\"></a></h2><h3 id=\"双线性插值（Bilinear-interpolation）\">双线性插值（Bilinear interpolation）<a href=\"post/Learn-OpenGL-Lesson-Six#双线性插值（Bilinear-interpolation）\"></a></h3><p>当纹素值之间没有插值时，在放大示例中，纹理的纹素清晰可见为大正方形。当使用最邻近方式时，像素将会分配到最邻近的像素。</p>\n<p>通过切换到双线性插值，渲染质量显著提高。这些值将会在邻近的四个像素之间线性插值，而不是将一组像素分配给邻近相同的纹素值。每个像素被平滑化，使得最后的图片看起来也更平滑：</p>\n<div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221103115.png\" alt=\"smoother android\" data-zoomable=\"\"></p></div>\n<p>一些块效果仍然很明显，但是这个图片看起来比之前更加平滑。那些在3D加速卡出现前玩过3D游戏的人将会记得软件渲染游戏和硬件加速游戏之间的特性：软件渲染游戏根本没有进行预计算处理，所以一切都显示得块状和锯齿状。一旦人们开始使用图形加速，这些东西都将变得平滑。</p>\n<div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221104453.png\" alt=\"smooth\" data-zoomable=\"\"></p></div>\n<p>双线性插值大多使用在放大。它也能使用在缩小，但是超过某个度，我们将会遇到同样的问题，我们在尝试将太多的纹素放到相同的像素上。OpenGL仅使用最多4个纹素渲染一个像素，因此许多信息仍然会丢失。</p>\n<p>如果我们看应用了双线性插值的纹理，当我们在远处看它移动时看起来会很嘈杂，因为每帧都会选择不同的纹素。</p>\n<h3 id=\"纹理映射（Mipmapping）\">纹理映射（Mipmapping）<a href=\"post/Learn-OpenGL-Lesson-Six#纹理映射（Mipmapping）\"></a></h3><p>我们如何才能在缩小纹理时不引用嘈杂并使用上所有纹素呢？我们可以生成一组优化后的不同尺寸的纹理，然后在我们运行的时候使用它们。由于这些纹理已预先生成，它们能使用更多高昂的技术去过滤所有纹素，并且在运行时OpenGL会根据纹理在屏幕上的最终大小选择最合适的层。</p>\n<div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221143838.png\" alt=\"textures set\" data-zoomable=\"\"></p></div>\n<p>生成的图片可以具有更多细节，更少噪点，并且整体上看起来更好。尽管需要更多的内存，但渲染速度也会更快，因为较小的层级能更容易保存在GPU的纹理缓存中。让我们来仔细研究一下原尺寸的1/8倍的图片，在使用了双线性过滤使用纹理映射和双线性过滤没有使用映射。为了清楚图片已被扩大：</p>\n<h4 id=\"双线性过滤没有mipmap\">双线性过滤没有mipmap<a href=\"post/Learn-OpenGL-Lesson-Six#双线性过滤没有mipmap\"></a></h4><div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221145134.png\" alt=\"without mipmaps\" data-zoomable=\"\"></p></div>\n<h4 id=\"双线性过滤-mipmap\">双线性过滤+mipmap<a href=\"post/Learn-OpenGL-Lesson-Six#双线性过滤-mipmap\"></a></h4><div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221145249.png\" alt=\"with mipmaps\" data-zoomable=\"\"></p></div>\n<p>使用mipmap的版本拥有更多细节，由于图像预处理到单独的层级，所有纹素最终都会在最终的图像中使用。</p>\n<h3 id=\"三线性过滤（Trilinear-filtering）\">三线性过滤（Trilinear filtering）<a href=\"post/Learn-OpenGL-Lesson-Six#三线性过滤（Trilinear-filtering）\"></a></h3><p>当使用双线性过滤的mipmap时，有时在渲染场景中可以看到明显的跳跃或线，由于OpenGL在纹理的不同mipmap层级之间切换。比较不同的OpenGL纹理的过滤模式将在下面进一步指出。</p>\n<p>三线性插值通过在不同mipmap层级之间插值来解决这个问题，这样总共8个纹素将用于插值得到最终的像素值，使得图像更平滑。</p>\n<h2 id=\"OpenGL-纹理过滤模式\">OpenGL 纹理过滤模式<a href=\"post/Learn-OpenGL-Lesson-Six#OpenGL-纹理过滤模式\"></a></h2><p>OpenGL有两个可被设置的参数：</p>\n<ul>\n<li><code>GL_TEXTURE_MIN_FILTER</code> 纹理缩小时的过滤模式</li>\n<li><code>GL_TEXTURE_MAG_FILTER</code> 纹理放大时的过滤模式</li>\n</ul>\n<p>这些相对应于上面的缩小和放大描述。  </p>\n<ul>\n<li><code>GL_TEXTURE_MIN_FILTER</code>接受以下选项：<ul>\n<li><code>GL_NEAREST</code></li>\n<li><code>GL_LINEAR</code></li>\n<li><code>GL_NEAREST_MIPMAP_NEAREST</code></li>\n<li><code>GL_NEAREST_MIPMAP_LINEAR</code></li>\n<li><code>GL_LINEAR_MIPMAP_NEAREST</code></li>\n<li><code>GL_LINEAR_MIPMAP_LINEAR</code></li>\n</ul>\n</li>\n<li><code>GL_TEXTURE_MAG_FILTER</code>接受以下选项：<ul>\n<li><code>GL_NEAREST</code></li>\n<li><code>GL_LINEAR</code></li>\n</ul>\n</li>\n</ul>\n<p><code>GL_NEAREST</code> 对应最邻近渲染；<br><code>GL_LINEAR</code> 对应双线性过滤；<br><code>GL_LINEAR_MIPMAP_NEAREST</code> 对应双线性过滤+mipmap；<br><code>GL_LINEAR_MIPMAP_LINEAR</code> 对应三线性过滤；<br>本课中将进一步介绍图形示例和最常见选项的进一步说明。</p>\n<h3 id=\"怎样设置纹理过滤模式\">怎样设置纹理过滤模式<a href=\"post/Learn-OpenGL-Lesson-Six#怎样设置纹理过滤模式\"></a></h3><p>我们首先需要绑定纹理，然后我们在这个纹理上设置合适的过滤参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureHandle);</span><br><span class=\"line\">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, filter);</span><br></pre></td></tr></table></figure>\n<h3 id=\"怎样生成mipmap\">怎样生成mipmap<a href=\"post/Learn-OpenGL-Lesson-Six#怎样生成mipmap\"></a></h3><p>这真的很容易！在加载纹理到OpenGL中后，纹理仍然是绑定的，我们可以简单的调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLES20.glGenerateMipmap(GLES20.GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure>\n<p>它将为我们生成所有的mipmap层级，并且这些层级会根据纹理过滤自动使用。</p>\n<h2 id=\"它看起来怎么样？\">它看起来怎么样？<a href=\"post/Learn-OpenGL-Lesson-Six#它看起来怎么样？\"></a></h2><p>以下是可用的最常见的组合的屏幕截图，当你看到它运动中时，效果更加引人注目，因此我建议下载<a href=\"https://github.com/xujiaji/LearnOpenGL/releases\" target=\"_blank\" rel=\"noopener\">这个App</a>并试一试。</p>\n<h3 id=\"最邻近渲染\">最邻近渲染<a href=\"post/Learn-OpenGL-Lesson-Six#最邻近渲染\"></a></h3><p>这个模式让人想起旧版3D游戏软件的渲染。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GL_TEXTURE_MIN_FILTER = GL_NEAREST</span><br><span class=\"line\">GL_TEXTURE_MAG_FILTER = GL_NEAREST</span><br></pre></td></tr></table></figure>\n<div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221163746.png\" alt=\"nearest nearest\" data-zoomable=\"\"></p></div>\n<h3 id=\"双线性过滤，mipmap\">双线性过滤，mipmap<a href=\"post/Learn-OpenGL-Lesson-Six#双线性过滤，mipmap\"></a></h3><p>许多支持3D加速的首批游戏都使用此模式，这是今天在Android手机上平滑纹理的有效方式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GL_TEXTURE_MIN_FILTER = GL_LINEAR_MIPMAP_NEAREST</span><br><span class=\"line\">GL_TEXTURE_MAG_FILTER = GL_LINEAR</span><br></pre></td></tr></table></figure>\n<div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221164349.png\" alt=\"linear mipmap\" data-zoomable=\"\"></p></div>\n<p>静态图上很难看图问题，但是当物体运动时，您可能会注意到渲染的像素在mipmap层级之间切换的水平条带。</p>\n<h3 id=\"三线性过滤\">三线性过滤<a href=\"post/Learn-OpenGL-Lesson-Six#三线性过滤\"></a></h3><p>此模式通过在mipmap层级之间进行插值，改进了使用mipmap的双线性过滤的渲染质量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GL_TEXTURE_MIN_FILTER = GL_LINEAR_MIPMAP_LINEAR</span><br><span class=\"line\">GL_TEXTURE_MAG_FILTER = GL_LINEAR</span><br></pre></td></tr></table></figure>\n<div class=\"article-img\"><p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190221165703.png\" alt=\"trilinear\" data-zoomable=\"\"></p></div>\n<p>像素在近距离和远距离之间完全平滑；事实上，纹理现在可能在倾斜角度下显示的过于平滑。<br><a href=\"https://en.wikipedia.org/wiki/Anisotropic_filtering\" target=\"_blank\" rel=\"noopener\">各向异性过滤（Anisotropic filtering）</a>是一种更先进的技术，受到某些移动GPU的支持，可用于改善最终结果，超出三线性过滤所能提供的效果。</p>\n<h3 id=\"进一步练习\">进一步练习<a href=\"post/Learn-OpenGL-Lesson-Six#进一步练习\"></a></h3><p>使用其他模式可以达到什么样的效果？例如，您何时会使用像<code>GL_NEAREST_MIPMAP_LINEAR</code>这样的东西？</p>\n<h2 id=\"教程目录\">教程目录<a href=\"post/Learn-OpenGL-Lesson-Six#教程目录\"></a></h2><ul>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One\">OpenGL Android课程一：入门</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two\">OpenGL Android课程二：环境光和漫射光</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three\">OpenGL Android课程三：使用每片段照明</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four\">OpenGL Android课程四：介绍纹理基础</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five\">OpenGL Android课程五：介绍混合（Blending）</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six\">OpenGL Android课程六：介绍纹理过滤</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven\">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）</a></li>\n</ul>\n<h2 id=\"打包教材\">打包教材<a href=\"post/Learn-OpenGL-Lesson-Six#打包教材\"></a></h2><p>可以在Github下载本课程源代码：<a href=\"https://github.com/learnopengles/Learn-OpenGLES-Tutorials\" target=\"_blank\" rel=\"noopener\">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href=\"https://market.android.com/details?id=com.learnopengles.android\" target=\"_blank\" rel=\"noopener\">google play 下载apk</a><br>“我”也编译了个apk，方便大家下载：<a href=\"https://github.com/xujiaji/LearnOpenGL/releases\" target=\"_blank\" rel=\"noopener\">github download</a></p>\n","prev":{"title":"OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VBO）","slug":"Learn-OpenGL-Lesson-Seven"},"next":{"title":"OpenGL Android课程五：介绍混合（Blending）","slug":"Learn-OpenGL-Lesson-Five"},"link":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six/","toc":[{"title":"介绍纹理过滤","id":"介绍纹理过滤","index":"1","children":[{"title":"前提条件","id":"前提条件","index":"1.1"},{"title":"什么是纹理过滤？","id":"什么是纹理过滤？","index":"1.2"},{"title":"放大和缩小","id":"放大和缩小","index":"1.3","children":[{"title":"放大","id":"放大","index":"1.3.1"},{"title":"缩小","id":"缩小","index":"1.3.2"}]},{"title":"纹理过滤模式","id":"纹理过滤模式","index":"1.4","children":[{"title":"双线性插值（Bilinear interpolation）","id":"双线性插值（Bilinear-interpolation）","index":"1.4.1"},{"title":"纹理映射（Mipmapping）","id":"纹理映射（Mipmapping）","index":"1.4.2"},{"title":"三线性过滤（Trilinear filtering）","id":"三线性过滤（Trilinear-filtering）","index":"1.4.3"}]},{"title":"OpenGL 纹理过滤模式","id":"OpenGL-纹理过滤模式","index":"1.5","children":[{"title":"怎样设置纹理过滤模式","id":"怎样设置纹理过滤模式","index":"1.5.1"},{"title":"怎样生成mipmap","id":"怎样生成mipmap","index":"1.5.2"}]},{"title":"它看起来怎么样？","id":"它看起来怎么样？","index":"1.6","children":[{"title":"最邻近渲染","id":"最邻近渲染","index":"1.6.1"},{"title":"双线性过滤，mipmap","id":"双线性过滤，mipmap","index":"1.6.2"},{"title":"三线性过滤","id":"三线性过滤","index":"1.6.3"},{"title":"进一步练习","id":"进一步练习","index":"1.6.4"}]},{"title":"教程目录","id":"教程目录","index":"1.7"},{"title":"打包教材","id":"打包教材","index":"1.8"}]}],"reward":true,"copyright":{"author":"xujiaji","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","link":"<a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six/\" title=\"OpenGL Android课程六：介绍纹理过滤\">https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six/</a>"}}