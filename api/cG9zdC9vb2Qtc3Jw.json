{"title":"面向对象设计-单一职责原则(SRP)","date":"2016-04-07T15:55:00.000Z","author":"xujiaji","link":"post/ood-srp","comments":true,"tags":["Java","面向对象设计"],"categories":["设计模式"],"updated":"2019-04-08T06:56:50.532Z","content":"<blockquote>\n<p>SRP</p>\n</blockquote>\n<div class=\"article-img\"><p><img src=\"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/ood/srp.png\" alt=\"SRP.png\" data-zoomable=\"\"></p></div>\n<h2 id=\"何为SRP？\">何为SRP？<a href=\"post/ood-srp#何为SRP？\"></a></h2><ul>\n<li>全称：单一职责原则(Single Responsibility Principle)</li>\n<li>定义:该原则规定每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来</li>\n</ul>\n<h2 id=\"何为职责-R\">何为职责(R)?<a href=\"post/ood-srp#何为职责-R\"></a></h2><blockquote>\n<p>既然是单一“职责”，那么职责即为被规定的因素。</p>\n</blockquote>\n<ul>\n<li><p>概括：”功能(职责)”为改变的原因，一个类或者模块应该有且只有一个改变的原因。</p>\n</li>\n<li><p>如下图农活责任所示，耕菜地和耕水田即为牛和耕地机的职责，即为这个对象存在的原因（下面将来讨论这个关系图）。</p>\n</li>\n</ul>\n<blockquote>\n<p>农活责任</p>\n</blockquote>\n<div class=\"article-img\"><p><img src=\"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/ood/srp-nong-huo.png\" alt=\"农活责任\" data-zoomable=\"\"></p></div>\n<h2 id=\"为何要提倡SRP？\">为何要提倡SRP？<a href=\"post/ood-srp#为何要提倡SRP？\"></a></h2><blockquote>\n<p>其思想简单，但却难以掌握。就是一个模块，一个类只能干一件事情。</p>\n</blockquote>\n<p>看上图农活责任，晃眼一看我们会决定这是对的！但仔细一分析农活接口其中包含的耕菜地和耕水田两个责任。</p>\n<ul>\n<li><p>牛耕水田，但它耕不动菜地，只能调用耕水田的接口，因此耕菜地的接口对于牛来说就是多余的。但耕地机即能耕菜地，也能耕水田。这就像是牛本来是耕田的，我们却说它还能去耕菜地，耕地机能做的事情，老牛表示无能为力！</p>\n</li>\n<li><p>这样违反了SRP，导致了严重的问题。因为我们给牛保留了一个多余而不会完成的责任，这让我们每次提到牛不仅说它能耕水田还能耕菜地。这让我们对牛的描述更加的复杂而没有准确性。程序也时这样，当没用的责任增加，就会让相应的类都变得臃肿腐臭。当我们要添加牛要耕后要吃草，耕地机耕地后要加油时，继续往农活接口中添加，这样使得农活什么都能干，使得后期修改维护等难度太大。</p>\n</li>\n<li>如果不分离责任，在不断变化和添加的需求面前，责任之间耦合度强导致我们的程序更加的脆弱。<h2 id=\"比如说？（实际举例说明）\"><a href=\"#比如说？（实际举例说明）\" class=\"headerlink\" title=\"比如说？（实际举例说明）\"></a>比如说？（实际举例说明）</h2></li>\n<li>例子一<blockquote>\n<p>农活责任(改)</p>\n</blockquote>\n</li>\n</ul>\n<div class=\"article-img\"><p><img src=\"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/ood/srp-nong-huo-gai.png\" alt=\"农活责任(改).png\" data-zoomable=\"\"></p></div>\n<p>如上图将两个责任分离，牛实现耕水田的时候，不会知道也不会去在意耕菜地，分离了责任，该做的才做，不做的不用管。</p>\n<ul>\n<li>例子二（来自敏捷软件开发第8章）[^foot]<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//调制解调器</span><br><span class=\"line\">interface Modem &#123;</span><br><span class=\"line\">    void dial(String pno);//拨号</span><br><span class=\"line\">    void hangup();//挂断</span><br><span class=\"line\">    void send(char c);//发送消息</span><br><span class=\"line\">    void recv();//接收消息</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>这个接口中显示了两个职责，一个是连接管理，一个是数据通信。dial和hangup函数进行调制解调器的连接处理，而send和recv函数进行数据的通信。</p>\n</blockquote>\n<p>这两个责任应该被分开吗？这决定于应用程序以何种方式变化。如果应用程序的变化会影响连接函数的部署，那么这个设计就具有僵化性的臭味。因为调用send和recv的类必须要重新编译连接处理函数，部署的次数常常会超过我们希望的次数。在这种情况下，这两个职责应该被分离。如图下图所示，这样避免了客户应用程序和这两个职责耦合在一起。</p>\n<blockquote>\n<p>分离的Modem接口</p>\n</blockquote>\n<div class=\"article-img\"><p><img src=\"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/ood/srp-fen-li.png\" alt=\"分离的Modem接口\" data-zoomable=\"\"></p></div>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">注意</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">另一方面，如果应用程序的变化方式总是会导致两个职责同时变化，那么就不必分离他们，分离后会导致不必要的复杂性。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">此外还有个推论：变化的曲线是仅当变化实际发生时才具有真正的意义。如果没有征兆，那么去应用SRP，或者其他原则都是不明智的。</td>\n</tr>\n</tbody>\n</table></div></div>\n<h2 id=\"结论总结\">结论总结<a href=\"post/ood-srp#结论总结\"></a></h2><ul>\n<li>SRP为最简单的原则，也是最难运用好的原则</li>\n<li>软件设计真正要做的其实就是发现责任并把那些责任分离</li>\n<li>其他原则都将能追溯到SRP</li>\n<li>大道至简，只有不断在代码中运用才能真正体会其中的奥妙</li>\n</ul>\n<h2 id=\"参考文章\">参考文章<a href=\"post/ood-srp#参考文章\"></a></h2><p>[1]《敏捷软件开发：原则、模式与实践》第8章 单一职责原则<br>[2]<a href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener\">维基百科</a><br>[3]<a href=\"http://www.oschina.net/translate/how-i-explained-ood-to-my-wife?lang=chs&amp;page=1#\" target=\"_blank\" rel=\"noopener\">我是怎样向妻子解释OOD的</a></p>\n","prev":{"title":"面向对象设计-开闭原则(OCP)","link":"post/ood-ocp"},"next":{"title":"Ubuntu安装Android studio","link":"post/install-android-studio-linux"},"plink":"https://blog.xujiaji.com/post/ood-srp/","toc":[{"title":"何为SRP？","id":"何为SRP？","index":"1"},{"title":"何为职责(R)?","id":"何为职责-R","index":"2"},{"title":"为何要提倡SRP？","id":"为何要提倡SRP？","index":"3"},{"title":"","id":"比如说？（实际举例说明）","index":"4"},{"title":"结论总结","id":"结论总结","index":"5"},{"title":"参考文章","id":"参考文章","index":"6"}],"reward":true,"copyright":{"author":"xujiaji","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","link":"<a href=\"https://blog.xujiaji.com/post/ood-srp/\" title=\"面向对象设计-单一职责原则(SRP)\">https://blog.xujiaji.com/post/ood-srp/</a>"}}