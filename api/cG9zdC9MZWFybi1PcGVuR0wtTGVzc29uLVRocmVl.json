{"title":"OpenGL Android课程三：使用每片段照明","date":"2019-01-26T09:55:49.000Z","author":"xujiaji","thumbnail":"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/Screenshot_2019-02-07-13-45-15-213_com.xujiaji.le.png","slug":"Learn-OpenGL-Lesson-Three","comments":true,"tags":["Android","OpenGL","学习","翻译"],"categories":["OpenGL"],"updated":"2019-03-24T09:07:50.597Z","content":"<blockquote>\n<p>翻译文</p>\n</blockquote>\n<p>原文标题：Android Lesson Three: Moving to Per-Fragment Lighting<br>原文链接：<a href=\"http://www.learnopengles.com/android-lesson-three-moving-to-per-fragment-lighting/\" target=\"_blank\" rel=\"noopener\">http://www.learnopengles.com/android-lesson-three-moving-to-per-fragment-lighting/</a><br><a id=\"more\"></a></p>\n<hr>\n<h1 id=\"使用每片段照明\">使用每片段照明<a href=\"post/Learn-OpenGL-Lesson-Three#使用每片段照明\"></a></h1><div class=\"article-bounded\"><div class=\"article-table\"><table>\n\n<tbody>\n<tr>\n<td>欢迎来到第三课！这节课，我们将会在<a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two\">第二课</a>的基础上，<br>学习如何使用每像素技术来达到相同的照明。<br>简单的正方体即使使用标准的漫射照明我们也能看到差异。</td>\n<td><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190126183929.png\" alt=\"screenshot\"></td>\n</tr>\n</tbody>\n</table></div></div>\n<h2 id=\"前提条件\">前提条件<a href=\"post/Learn-OpenGL-Lesson-Three#前提条件\"></a></h2><p>本系列的每节课都以前面的课程为基础，本节课是<a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two\">第二课</a>的补充，因此请务在阅读了之前的课程后再来回顾。</p>\n<blockquote>\n<p>下面是本系列课程的前几课：</p>\n</blockquote>\n<ul>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One\">OpenGL Android课程一：入门</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two\">OpenGL Android课程二：环境光和漫射光</a></li>\n</ul>\n<h2 id=\"什么是每像素照明\">什么是每像素照明<a href=\"post/Learn-OpenGL-Lesson-Three#什么是每像素照明\"></a></h2><p>随着着色器的使用，每像素照明在游戏中是一种相对较新的现象。许多有名的旧游戏，例如原版的<a href=\"https://en.wikipedia.org/wiki/Half-Life_(video_game)\" target=\"_blank\" rel=\"noopener\">半条命</a>，都是在着色器之前开发出来的，主要使用静态照明，通过一些技巧模拟动态照明，使用每顶点（也称为<a href=\"http://en.wikipedia.org/wiki/Gouraud_shading\" target=\"_blank\" rel=\"noopener\">Gouraud阴影</a>）照明或其他技术，如动态<a href=\"https://en.wikipedia.org/wiki/Lightmap\" target=\"_blank\" rel=\"noopener\">光照贴图</a>。</p>\n<p>光照贴图可以提供非常好的效果，有时可以比单独的着色器提供更好的效果，因为可以预先计算昂贵的光线计算。但缺点是它们占用了大量内存并使用它们进行动态照明仅限于简单的计算。</p>\n<p>使用着色器，现在很多这些计算转给GPU，这可以完成更多实时的效果。</p>\n<h2 id=\"从每顶点照明转移到每片段照明\">从每顶点照明转移到每片段照明<a href=\"post/Learn-OpenGL-Lesson-Three#从每顶点照明转移到每片段照明\"></a></h2><p>这本课中，我们将针对每顶点解决方案和每片段解决方案查看相同的照明代码。尽管我将这种类型称为每像素，但在OpenGL ES中我们实际上使用片段，并且几个片段可以贡献一个像素的最终值。</p>\n<p>手机的GPU变得越来越快，但是性能仍然是一个问题。对于“软”照明例如地形，每顶点照明可能足够好。确保您在质量和速度之间取得适当的平衡。</p>\n<p>在某些情况下可以看到两种类型的照明之间的显著差异。看看下面的屏幕截图：</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n\n<tbody>\n<tr>\n<td><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190127004415.png\" alt=\"Per vertex lighting\"><br>每顶点照明；<br>在正方形四个顶点为中心</td>\n<td><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190127004455.png\" alt=\"Per fragment lighting\"><br>每片段照明；<br>在正方形四个顶点为中心</td>\n<td>在左图的每顶点照明中正方体的<br>正面看起来像是平面阴影，不能<br>表明附近有光源。这是因为正面<br>的四个顶点和光源距离差不多相<br>等，并且四个点的低光强度被简<br>单的插入两个三角形构成的正面。<hr>相对比，每片段照明很好的<br>显示了亮点特性</td>\n</tr>\n<tr>\n<td><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190127004542.png\" alt=\"Per vertex lighting\"><br>每顶点照明；<br>在正方形角落</td>\n<td><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/learn-opengl/20190127004615.png\" alt=\"Per fragment lighting\"><br>每片段照明；<br>在正方形角落</td>\n<td>左图显示了一个<a href=\"http://en.wikipedia.org/wiki/Gouraud_shading\" target=\"_blank\" rel=\"noopener\">Gouraud阴影</a><br>立方体。当光源移动到立方体正<br>面角落时，可以看到类似三角形<br>的效果。这是因为正面实际上是<br>由两个三角形组成，并且在每个<br>三角形不同方向插值，我们能看<br>到构成立方体的基础几何图形。<hr>每片段的版本显示上没有此类插<br>值的问题并且它在边缘附近显示<br>了一个漂亮的圆形高光。</td>\n</tr>\n</tbody>\n</table></div></div>\n<h3 id=\"每顶点照明概述\">每顶点照明概述<a href=\"post/Learn-OpenGL-Lesson-Three#每顶点照明概述\"></a></h3><p>我们来看看<a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two\">第二课</a>讲的着色器；在该课程中可以找到详细的着色器说明。</p>\n<h3 id=\"顶点着色器\">顶点着色器<a href=\"post/Learn-OpenGL-Lesson-Three#顶点着色器\"></a></h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">mat4</span> u_MVPMatrix;      <span class=\"comment\">// 一个表示组合model、view、projection矩阵的常量</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">mat4</span> u_MVMatrix;       <span class=\"comment\">// 一个表示组合model、view矩阵的常量</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec3</span> u_LightPos;       <span class=\"comment\">// 光源在眼睛空间的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> a_Position;     <span class=\"comment\">// 我们将要传入的每个顶点的位置信息</span></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> a_Color;        <span class=\"comment\">// 我们将要传入的每个顶点的颜色信息</span></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec3</span> a_Normal;       <span class=\"comment\">// 我们将要传入的每个顶点的法线信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec4</span> v_Color;          <span class=\"comment\">// 这将被传入片段着色器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main()                    <span class=\"comment\">// 顶点着色器入口</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">// 将顶点转换成眼睛空间</span></span><br><span class=\"line\">   <span class=\"type\">vec3</span> modelViewVertex = <span class=\"type\">vec3</span>(u_MVMatrix * a_Position);</span><br><span class=\"line\"><span class=\"comment\">// 将法线的方向转换成眼睛空间</span></span><br><span class=\"line\">   <span class=\"type\">vec3</span> modelViewNormal = <span class=\"type\">vec3</span>(u_MVMatrix * <span class=\"type\">vec4</span>(a_Normal, <span class=\"number\">0.0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 将用于哀减</span></span><br><span class=\"line\">   <span class=\"type\">float</span> <span class=\"built_in\">distance</span> = <span class=\"built_in\">length</span>(u_LightPos - modelViewVertex);</span><br><span class=\"line\"><span class=\"comment\">// 获取从光源到顶点方向的光线向量</span></span><br><span class=\"line\">   <span class=\"type\">vec3</span> lightVector = <span class=\"built_in\">normalize</span>(u_LightPos - modelViewVertex);</span><br><span class=\"line\"><span class=\"comment\">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class=\"line\">   <span class=\"type\">float</span> diffuse = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(modelViewNormal, lightVector), <span class=\"number\">0.1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 根据距离哀减光线</span></span><br><span class=\"line\">   diffuse = diffuse * (<span class=\"number\">1.0</span> / (<span class=\"number\">1.0</span> + (<span class=\"number\">0.25</span> * <span class=\"built_in\">distance</span> * <span class=\"built_in\">distance</span>)));</span><br><span class=\"line\"><span class=\"comment\">// 将颜色乘以亮度，它将被插入三角形中</span></span><br><span class=\"line\">   v_Color = a_Color * diffuse;</span><br><span class=\"line\"><span class=\"comment\">// gl_Position是一个特殊的变量用来存储最终的位置</span></span><br><span class=\"line\"><span class=\"comment\">// 将顶点乘以矩阵得到标准化屏幕坐标的最终点</span></span><br><span class=\"line\">   <span class=\"built_in\">gl_Position</span> = u_MVPMatrix * a_Position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"片段着色器\">片段着色器<a href=\"post/Learn-OpenGL-Lesson-Three#片段着色器\"></a></h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">mediump</span> <span class=\"type\">float</span>;     <span class=\"comment\">// 我们将默认精度设置为中等，我们不需要片段着色器中的高精度</span></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec4</span> v_Color;        <span class=\"comment\">// 这是从三角形每个片段内插的顶点着色器的颜色</span></span><br><span class=\"line\"><span class=\"type\">void</span> main()                  <span class=\"comment\">// 片段着色器入口</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = v_Color;   <span class=\"comment\">// 直接将颜色传递</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正如您所见，大部分工作都在我们的着色器中做的。转移到每片段着色照明意味着，我们的片段着色器还有更多的工作要做。</p>\n<h3 id=\"实现每片段照明\">实现每片段照明<a href=\"post/Learn-OpenGL-Lesson-Three#实现每片段照明\"></a></h3><p>以下是移动到每片段照明后的代码的样子。</p>\n<h3 id=\"顶点着色器-new\">顶点着色器 new<a href=\"post/Learn-OpenGL-Lesson-Three#顶点着色器-new\"></a></h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">mat4</span> u_MVPMatrix;    <span class=\"comment\">// 一个表示组合model、view、projection矩阵的常量</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">mat4</span> u_MVMatrix;     <span class=\"comment\">// 一个表示组合model、view矩阵的常量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> a_Position;   <span class=\"comment\">// 我们将要传入的每个顶点的位置信息</span></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> a_Color;      <span class=\"comment\">// 我们将要传入的每个顶点的颜色信息</span></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec3</span> a_Normal;     <span class=\"comment\">// 我们将要传入的每个顶点的法线信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec3</span> v_Position;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec4</span> v_Color;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec3</span> v_Normal;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顶点着色器入口点</span></span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 将顶点位置转换成眼睛空间的位置</span></span><br><span class=\"line\">   v_Position = <span class=\"type\">vec3</span>(u_MVMatrix * a_Position);</span><br><span class=\"line\">   <span class=\"comment\">// 传入颜色</span></span><br><span class=\"line\">   v_Color = a_Color;</span><br><span class=\"line\">   <span class=\"comment\">// 将法线的方向转换在眼睛空间</span></span><br><span class=\"line\">   v_Normal = <span class=\"type\">vec3</span>(u_MVMatrix * <span class=\"type\">vec4</span>(a_Normal, <span class=\"number\">0.0</span>));</span><br><span class=\"line\">   <span class=\"comment\">// gl_Position是一个特殊的变量用来存储最终的位置</span></span><br><span class=\"line\">   <span class=\"comment\">// 将顶点乘以矩阵得到标准化屏幕坐标的最终点</span></span><br><span class=\"line\">   <span class=\"built_in\">gl_Position</span> = u_MVPMatrix * a_Position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>顶点着色器比之前更加的简单。我们添加了两个线性插值变量用来传入到片段着色器：顶点位置和顶点法线。它们将在片段着色器计算光亮的时候被使用。</p>\n<h3 id=\"片段着色器-new\">片段着色器 new<a href=\"post/Learn-OpenGL-Lesson-Three#片段着色器-new\"></a></h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">mediump</span> <span class=\"type\">float</span>; <span class=\"comment\">//我们将默认精度设置为中等，我们不需要片段着色器中的高精度</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec3</span> u_LightPos; <span class=\"comment\">// 光源在眼睛空间的位置</span></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec3</span> v_Position; <span class=\"comment\">// 插入的位置</span></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec4</span> v_Color;    <span class=\"comment\">// 插入的位置颜色</span></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec3</span> v_Normal;   <span class=\"comment\">// 插入的位置法线</span></span><br><span class=\"line\"><span class=\"type\">void</span> main()              <span class=\"comment\">// 片段着色器入口</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 将用于哀减</span></span><br><span class=\"line\">   <span class=\"type\">float</span> <span class=\"built_in\">distance</span> = <span class=\"built_in\">length</span>(u_LightPos - v_Position);</span><br><span class=\"line\">   <span class=\"comment\">// 获取从光源到顶点方向的光线向量</span></span><br><span class=\"line\">   <span class=\"type\">vec3</span> lightVector = <span class=\"built_in\">normalize</span>(u_LightPos - v_Position);</span><br><span class=\"line\">   <span class=\"comment\">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class=\"line\">   <span class=\"type\">float</span> diffuse = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(v_Normal, lightVector), <span class=\"number\">0.1</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 根据距离哀减光线</span></span><br><span class=\"line\">   diffuse = diffuse * (<span class=\"number\">1.0</span> / (<span class=\"number\">1.0</span> + (<span class=\"number\">0.25</span> * <span class=\"built_in\">distance</span> * <span class=\"built_in\">distance</span>)));</span><br><span class=\"line\">   <span class=\"comment\">// 颜色乘以亮度哀减得到最终的颜色</span></span><br><span class=\"line\">   <span class=\"built_in\">gl_FragColor</span> = v_Color * diffuse;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用每片段照明，我们的片段着色器还有更多的工作要做。我们基本上将<a href=\"https://en.wikipedia.org/wiki/Lambert%27s_cosine_law\" target=\"_blank\" rel=\"noopener\">朗伯计算</a>和哀减移到了每像素级别，这为我们提供了更逼真的照明，而无需添加更多顶点。</p>\n<h2 id=\"进一步练习\">进一步练习<a href=\"post/Learn-OpenGL-Lesson-Three#进一步练习\"></a></h2><p>我们可以在顶点着色器中计算距离，然后赋值给变量通过线性插值传入片段着色器吗？</p>\n<h2 id=\"教程目录\">教程目录<a href=\"post/Learn-OpenGL-Lesson-Three#教程目录\"></a></h2><ul>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One\">OpenGL Android课程一：入门</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two\">OpenGL Android课程二：环境光和漫射光</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three\">OpenGL Android课程三：使用每片段照明</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four\">OpenGL Android课程四：介绍纹理基础</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five\">OpenGL Android课程五：介绍混合（Blending）</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six\">OpenGL Android课程六：介绍纹理过滤</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven\">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VBOs）</a></li>\n</ul>\n<h2 id=\"打包教材\">打包教材<a href=\"post/Learn-OpenGL-Lesson-Three#打包教材\"></a></h2><p>可以在Github下载本课程源代码：<a href=\"https://github.com/learnopengles/Learn-OpenGLES-Tutorials\" target=\"_blank\" rel=\"noopener\">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href=\"https://market.android.com/details?id=com.learnopengles.android\" target=\"_blank\" rel=\"noopener\">google play 下载apk</a><br>“我”也编译了个apk，方便大家下载：<a href=\"https://github.com/xujiaji/LearnOpenGL/releases\" target=\"_blank\" rel=\"noopener\">github download</a></p>\n","prev":{"title":"OpenGL Android课程四：介绍纹理基础","slug":"Learn-OpenGL-Lesson-Four"},"next":{"title":"OpenGL Android课程二：环境光和漫射光","slug":"Learn-OpenGL-Lesson-Two"},"link":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three/","toc":[{"title":"使用每片段照明","id":"使用每片段照明","index":"1","children":[{"title":"前提条件","id":"前提条件","index":"1.1"},{"title":"什么是每像素照明","id":"什么是每像素照明","index":"1.2"},{"title":"从每顶点照明转移到每片段照明","id":"从每顶点照明转移到每片段照明","index":"1.3","children":[{"title":"每顶点照明概述","id":"每顶点照明概述","index":"1.3.1"},{"title":"顶点着色器","id":"顶点着色器","index":"1.3.2"},{"title":"片段着色器","id":"片段着色器","index":"1.3.3"},{"title":"实现每片段照明","id":"实现每片段照明","index":"1.3.4"},{"title":"顶点着色器 new","id":"顶点着色器-new","index":"1.3.5"},{"title":"片段着色器 new","id":"片段着色器-new","index":"1.3.6"}]},{"title":"进一步练习","id":"进一步练习","index":"1.4"},{"title":"教程目录","id":"教程目录","index":"1.5"},{"title":"打包教材","id":"打包教材","index":"1.6"}]}],"reward":true,"copyright":{"author":"xujiaji","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","link":"<a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three/\" title=\"OpenGL Android课程三：使用每片段照明\">https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three/</a>"}}