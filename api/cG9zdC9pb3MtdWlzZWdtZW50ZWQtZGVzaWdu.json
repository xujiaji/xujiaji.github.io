{"title":"iOS用UISegmentedControl设计一个顶部分页导航-Swift（翻译文）","date":"2018-07-23T06:36:32.000Z","author":"xujiaji","thumbnail":"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/ios-uisegmented-design/display.gif","slug":"ios-uisegmented-design","comments":true,"tags":["Swift","UI","iOS","翻译"],"categories":["iOS"],"updated":"2018-12-25T15:22:37.002Z","content":"<blockquote>\n<p>原文：《<a href=\"https://www.codementor.io/kevinfarst/designing-a-button-bar-style-uisegmentedcontrol-in-swift-cg6cf0dok\" target=\"_blank\" rel=\"noopener\">Designing a Button Bar-Style UISegmentedControl in Swift</a>》</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>我正在做一个项目，项目里面我想用<code>UISegmentedControl</code>做一个简洁的“底部条形样式”的设计。它没有边框，所选下方有一个小长条，当你选择一个元素后他会相应的移动过去。我找到几个非常好的第三方库来处理这个问题，但是我在这些类库上遇到了一些麻烦，于是我尝试自己做。我以自动布局约束，以swift代码方式构建视图，并为了简单起见，将所有主题内联完成。</p>\n<h2 id=\"准备开始\">准备开始<a href=\"post/ios-uisegmented-design#准备开始\"></a></h2><p>我们在Swift playground中做这些事情，因此让我们从基本的东西开始，创建一个新的UIView并且添加一个带有3个片段的UISegmentedControl，另外需要注意，我构建约束的方式是假设所有片段长度想等的情况。如果不是的话，会导致底部长条在相应的位置上变得太宽或不够宽。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 容器View</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> view = <span class=\"type\">UIView</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">400</span>, height: <span class=\"number\">100</span>))</span><br><span class=\"line\">view.backgroundColor = .white</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> segmentedControl = <span class=\"type\">UISegmentedControl</span>()</span><br><span class=\"line\"><span class=\"comment\">// 添加片段</span></span><br><span class=\"line\">segmentedControl.insertSegment(withTitle: <span class=\"string\">\"One\"</span>, at: <span class=\"number\">0</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">segmentedControl.insertSegment(withTitle: <span class=\"string\">\"Two\"</span>, at: <span class=\"number\">1</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">segmentedControl.insertSegment(withTitle: <span class=\"string\">\"Three\"</span>, at: <span class=\"number\">2</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"comment\">// 让第一个片段默认选中</span></span><br><span class=\"line\">segmentedControl.selectedSegmentIndex = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置为false，我们才能使用自动布局约束</span></span><br><span class=\"line\">segmentedControl.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加UISegmentedControl到容器View</span></span><br><span class=\"line\">view.addSubview(segmentedControl)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 约束到容器的顶部</span></span><br><span class=\"line\">segmentedControl.topAnchor.constraint(equalTo: view.topAnchor).isActive = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 限制为容器view的宽度</span></span><br><span class=\"line\">segmentedControl.widthAnchor.constraint(equalTo: view.widthAnchor).isActive = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 设置高度</span></span><br><span class=\"line\">segmentedControl.heightAnchor.constraint(equalToConstant: <span class=\"number\">40</span>).isActive = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = view</span><br></pre></td></tr></table></figure>\n<p>此时实时窗口已经为我们展示了基本的<code>UISegmentedControl</code>。不要忘记将<code>isActive</code>属性附加到每个自动布局约束，其值为true，否则他们将不起作用。<br><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/ios-uisegmented-design/basic-uisegmentedcontrol.png\" alt=\"Basic UISegmentedControl\"></p>\n<h2 id=\"颜色、字体和边框Oh-My！\">颜色、字体和边框Oh My！<a href=\"post/ios-uisegmented-design#颜色、字体和边框Oh-My！\"></a></h2><p>接下来，让我们删除掉<code>backgroundColor</code>和<code>tintColor</code>，删除后边框和已选择的片段背景颜色将会消失。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将下面的代码添加到 selectedSegmentIndex下面</span></span><br><span class=\"line\">segmentedControl.backgroundColor = .clear</span><br><span class=\"line\">segmentedControl.tintColor = .clear</span><br></pre></td></tr></table></figure></p>\n<p>如果你看实时窗口，我们删除了<code>tintColor</code>后，<code>UISegmentedControl</code>已经消失，现在没有颜色了。要恢复标签，让我们更改所选片段和未选片段的字体、文本颜色和大小。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加这些代码到 segmentedControl.tintColor = .clear 后</span></span><br><span class=\"line\">segmentedControl.setTitleTextAttributes([</span><br><span class=\"line\">    <span class=\"type\">NSAttributedStringKey</span>.font: <span class=\"type\">UIFont</span>(name: <span class=\"string\">\"DINCondensed-Bold\"</span>, size: <span class=\"number\">18</span>)!,</span><br><span class=\"line\">    <span class=\"type\">NSAttributedStringKey</span>.foregroundColor: <span class=\"type\">UIColor</span>.lightGray</span><br><span class=\"line\">    ], <span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\"></span><br><span class=\"line\">segmentedControl.setTitleTextAttributes([</span><br><span class=\"line\">    <span class=\"type\">NSAttributedStringKey</span>.font : <span class=\"type\">UIFont</span>(name: <span class=\"string\">\"DINCondensed-Bold\"</span>, size: <span class=\"number\">18</span>)!,</span><br><span class=\"line\">    <span class=\"type\">NSAttributedStringKey</span>.foregroundColor: <span class=\"type\">UIColor</span>.orange</span><br><span class=\"line\">    ], <span class=\"keyword\">for</span>: .selected)</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/ios-uisegmented-design/change-color-font.png\" alt=\"change-color-font\"><br>到这儿差不多了！现在我们必须在所选段下方添加一个长条栏。</p>\n<h2 id=\"为选定片段底部添加长条\">为选定片段底部添加长条<a href=\"post/ios-uisegmented-design#为选定片段底部添加长条\"></a></h2><p>这个长条只是一个简单的UIView，然后将其<code>backgroundColor</code>与其所选片段字体的颜色相匹配。我们将选择的片段字体颜色和长条都设置为橙色。并且我们要为长条设置<code>translatesAutoresizingMaskIntoConstraints</code>为false。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> buttonBar = <span class=\"type\">UIView</span>()</span><br><span class=\"line\"><span class=\"comment\">// 设置为false，我们才能使用自动布局约束</span></span><br><span class=\"line\">buttonBar.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">false</span></span><br><span class=\"line\">buttonBar.backgroundColor = <span class=\"type\">UIColor</span>.orange</span><br></pre></td></tr></table></figure></p>\n<p>接下来，将<code>buttonBar</code>作为子View添加到容器view中<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加到 view.addSubview(segmentedControl)之后</span></span><br><span class=\"line\">view.addSubview(buttonBar)</span><br></pre></td></tr></table></figure></p>\n<p>最终，我们需要给它个宽度、高度和位置，在<code>segmentedControl</code>之后添加这些约束<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 约束它的顶部位置在片段的底部位置</span></span><br><span class=\"line\">buttonBar.topAnchor.constraint(equalTo: segmentedControl.bottomAnchor).isActive = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 设置长条的高度</span></span><br><span class=\"line\">buttonBar.heightAnchor.constraint(equalToConstant: <span class=\"number\">5</span>).isActive = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 约束它的左侧和片段的左侧重合</span></span><br><span class=\"line\">buttonBar.leftAnchor.constraint(equalTo: segmentedControl.leftAnchor).isActive = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">// 约束它的宽度 = 片段容器宽度 / 片段个数</span></span><br><span class=\"line\">buttonBar.widthAnchor.constraint(equalTo: segmentedControl.widthAnchor, multiplier: <span class=\"number\">1</span> / <span class=\"type\">CGFloat</span>(segmentedControl.numberOfSegments)).isActive = <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<p>正如最后那条注释所说，我们需要长条的宽度为<code>segmentedControl</code>的宽度除以片段个个数。这保证了长条宽度将与单个片段的宽度完全匹配，同样这里是假设所有的段都是想等的宽度。<br><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/ios-uisegmented-design/added-bar.png\" alt=\"added-bar\"><br>初始视图现在已完成！最后一步，我们需要让长条随所选的片段移动。</p>\n<h2 id=\"长条栏动画\">长条栏动画<a href=\"post/ios-uisegmented-design#长条栏动画\"></a></h2><p>当所选片段发生改变时，<code>segmentedControl</code>需要调用一个函数来处理长条栏在x轴上的位置转换，使其跑到选择的片段下方。定义个<code>Responder</code>类，并添加方法，然后在<code>segmentedControl</code>变量上添加回调，<code>segmentedControl</code>的值改变时会触发。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在import声明下方</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Responder</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">segmentedControlValueChanged</span><span class=\"params\">(<span class=\"number\">_</span> sender: UISegmentedControl)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> responder = <span class=\"type\">Responder</span>()</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// 在PlaygroundPage.current.liveView = view声明的上方</span></span><br><span class=\"line\">segmentedControl.addTarget(responder, action: #selector(responder.segmentedControlValueChanged(<span class=\"number\">_</span>:)), <span class=\"keyword\">for</span>: <span class=\"type\">UIControlEvents</span>.valueChanged)</span><br></pre></td></tr></table></figure></p>\n<p>一定要确保<code>sender</code>作为方法参数类型，因为我们需要在调用函数时访问它。最后让我们来完成最后一块拼图，<code>buttonBar</code>在x轴的移动，它将移动到被选中的片段下<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">segmentedControlValueChanged</span><span class=\"params\">(<span class=\"number\">_</span> sender: UISegmentedControl)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">      buttonBar.frame.origin.x = (segmentedControl.frame.width / <span class=\"type\">CGFloat</span>(segmentedControl.numberOfSegments)) * <span class=\"type\">CGFloat</span>(segmentedControl.selectedSegmentIndex)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>长条因该去的x轴位置 = (<code>segmentedControl</code>的宽度 / 片段个数) * 当前片段的下标</p>\n<p>瞧瞧！我们的动画按钮栏出来了<br><img src=\"https://raw.githubusercontent.com/xujiaji/xujiaji.github.io/pictures/blog/ios-uisegmented-design/display.gif\" alt=\"finished\"></p>\n<h2 id=\"结论\">结论<a href=\"post/ios-uisegmented-design#结论\"></a></h2><p>我希望这篇文章所提供的信息，能作为你在看了许多类库或iOS应用后的一个DIY解决方案。你可以将这里的<code>UISegmentedControl</code>连接到<code>UIPageViewController</code>或<code>UIScrollView</code>作为分段内容直接移动的方式。你这可以在<a href=\"https://gist.github.com/kfarst/9f8a1eb59cce2004b15f0b682c92eeed\" target=\"_blank\" rel=\"noopener\">这里</a>找到playgroud代码在Github Gist，祝您iOS开发顺利！</p>\n<hr>\n<blockquote>\n<p>补充说明：下面链接到的是我在练习的时候写的代码，供参考！</p>\n</blockquote>\n<p><a href=\"https://github.com/xujiaji/Learn-iOS/blob/master/TabSegmentedControl.playground/Contents.swift\" target=\"_blank\" rel=\"noopener\">https://github.com/xujiaji/Learn-iOS/blob/master/TabSegmentedControl.playground/Contents.swift</a></p>\n","prev":{"title":"Git Commit Standard","slug":"Git-Commit-Standard"},"next":{"title":"iOS开发-零碎笔记","slug":"ios-study-note"},"link":"https://blog.xujiaji.com/post/ios-uisegmented-design/","toc":[{"title":"准备开始","id":"准备开始","index":"1"},{"title":"颜色、字体和边框Oh My！","id":"颜色、字体和边框Oh-My！","index":"2"},{"title":"为选定片段底部添加长条","id":"为选定片段底部添加长条","index":"3"},{"title":"长条栏动画","id":"长条栏动画","index":"4"},{"title":"结论","id":"结论","index":"5"}],"reward":true,"copyright":{"author":"xujiaji","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","link":"<a href=\"https://blog.xujiaji.com/post/ios-uisegmented-design/\" title=\"iOS用UISegmentedControl设计一个顶部分页导航-Swift（翻译文）\">https://blog.xujiaji.com/post/ios-uisegmented-design/</a>"}}