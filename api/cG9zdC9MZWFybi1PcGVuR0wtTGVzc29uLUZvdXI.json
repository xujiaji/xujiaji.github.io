{"title":"OpenGL Android课程四：介绍纹理基础","date":"2019-02-08T11:26:29.000Z","author":"xujiaji","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190211205340.jpg","slug":"Learn-OpenGL-Lesson-Four","comments":true,"tags":["Android","OpenGL","学习","翻译"],"categories":["OpenGL"],"updated":"2019-04-08T06:56:03.158Z","content":"<blockquote>\n<p>翻译文</p>\n</blockquote>\n<p>原文标题：Android Lesson Four: Introducing Basic Texturing<br>原文链接：<a href=\"http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/\" target=\"_blank\" rel=\"noopener\">http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/</a><br><a id=\"more\"></a></p>\n<hr>\n<h1 id=\"介绍纹理基础\">介绍纹理基础<a href=\"post/Learn-OpenGL-Lesson-Four#介绍纹理基础\"></a></h1><div class=\"article-bounded\"><div class=\"article-table\"><table>\n\n<tbody>\n<tr>\n<td>这是我们Android系列的第四个课程。<br>在本课中，我们将添加我们在<a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three\">第三课</a><br>中学到的内容，并学习如何添加纹理。<br>我们来看看如何从应用资源中获取一张<br>图片加载到OpenGLES中，并展示到<br>屏幕上。<br><br>跟着我一起来，你将马上明白纹理的<br>基本使用方式。</td>\n<td><img src=\"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190208193740.png\" alt=\"screenshot\"></td>\n</tr>\n</tbody>\n</table></div></div>\n<h2 id=\"前提条件\">前提条件<a href=\"post/Learn-OpenGL-Lesson-Four#前提条件\"></a></h2><p>本系列每个课程构建都是以前一个课程为基础，这节课是<a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three\">第三课</a>的扩展，因此请务必在继续之前复习该课程。</p>\n<blockquote>\n<p>已下是本系列课程的前几课：</p>\n</blockquote>\n<ul>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One\">OpenGL Android课程一：入门</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two\">OpenGL Android课程二：环境光和漫射光</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three\">OpenGL Android课程三：使用每片段照明</a></li>\n</ul>\n<h2 id=\"纹理基础\">纹理基础<a href=\"post/Learn-OpenGL-Lesson-Four#纹理基础\"></a></h2><p>纹理映射的艺术（以及照明）是构建逼真的3D世界最重要的部分。没有纹理映射，一切都是平滑的阴影，看起来很人工，就像是90年代的老式控制台游戏。</p>\n<p>第一个开始大量使用纹理的游戏，如Doom和Duke Nukem 3D，通过增加视觉冲击力，大大提升了游戏的真实感——如果在晚上玩可能会真的吓唬到我们。</p>\n<blockquote>\n<p>这里我们来看有纹理和没有纹理的场景</p>\n</blockquote>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190208215006.png\" alt=\"pre-fragment lighting\"><br><em>每片段照明；<br>正方形四个顶点中心位置</em></td>\n<td style=\"text-align:center\"><img src=\"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190208215108.png\" alt=\"added texture\"><br><em>添加了纹理；<br>正方形四个顶点中心位置</em></td>\n<td>看左边的图片，这个场景通过每像<br>素照明和着色点亮。这个场景看起<br>来非常平滑，现实生活中我们走进<br>一个房间有充满了光滑阴影的东西<br>就像是这个立方体。<br><br>在看右边的图片，同样的场景现在<br>纹理化了。环境光也增加了，因为<br>纹理的使用使整个场景变暗，也可<br>以看到纹理对侧面立方体的影响。<br>立方体具有和以前相同数量的多边<br>形，但它们有新纹理看起来更加详<br>细。<br><br>满足于那些好奇的人，这个纹理的<br>资源来自于<a href=\"http://pdtextures.blogspot.com/2008/03/first-set.html\" target=\"_blank\" rel=\"noopener\">公共领域的资源</a></td>\n</tr>\n</tbody>\n</table></div></div>\n<h2 id=\"纹理坐标\">纹理坐标<a href=\"post/Learn-OpenGL-Lesson-Four#纹理坐标\"></a></h2><p>在OpengGL中，纹理坐标时常使用坐标(s,t)代替(x,y)。(s,t)表示纹理上的一个纹理元素，然后映射到多边形。另外需要注意这些纹理坐标和其他OpengGL坐标相似：t(或y)轴指向上方，所以值越高您走的越远。</p>\n<p>大多数计算机图形，y轴指向下方。这意味着左上角是图片的原点(0,0)，并且y值向下递增。换句话说，OpenGL的坐标系和大多数计算机图形相反，这是您需要考虑到的。</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><em>OpenGL的纹理坐标系</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><img src=\"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190208225905.png\" alt=\"coordiante\"></td>\n</tr>\n</tbody>\n</table></div></div>\n<h2 id=\"纹理映射基础\">纹理映射基础<a href=\"post/Learn-OpenGL-Lesson-Four#纹理映射基础\"></a></h2><p>在本课中，我们将来看看常规2D纹理（<code>GL_TEXTURE_2D</code>）和红，绿，蓝颜色信息（<code>GL_RGB</code>）。OpenGL ES 也提供其他纹理模式让你做更多不同的特殊效果。我们将使用<code>GL_NEAREST</code>查看点采样，<code>GL_LINEAR</code>和MIP-映射将在后面的课程中讲解。</p>\n<p>让我们一起来到代码部分，看看怎样开始在Android中使用基本的纹理。</p>\n<h3 id=\"顶点着色器\">顶点着色器<a href=\"post/Learn-OpenGL-Lesson-Four#顶点着色器\"></a></h3><p>我们将采用上节课中的每像素照明着色器，并添加纹理支持。</p>\n<blockquote>\n<p>这儿是新的变化：</p>\n</blockquote>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec2</span> a_TexCoordinate;<span class=\"comment\">// 我们将要传入的每个顶点的纹理坐标信息</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec2</span> v_TexCoordinate;  <span class=\"comment\">// 这将会传入到片段着色器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 传入纹理坐标</span></span><br><span class=\"line\">   v_TexCoordinate = a_TexCoordinate;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在顶点着色器中，我们添加一个新的属性类型<code>vec2</code>（一个包含两个元素的数组），将用来放入纹理坐标信息。这将是每个顶点都有，同位置，颜色，法线数据一样。我们也添加了一个新的变量，它将通过三角形表面上的线性插值将数据传入片段着色器。</p>\n<h3 id=\"片段着色器\">片段着色器<a href=\"post/Learn-OpenGL-Lesson-Four#片段着色器\"></a></h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform sampler2D u_Texture;\" +  // 传入纹理</span><br><span class=\"line\">...</span><br><span class=\"line\">varying vec2 v_TexCoordinate;\" + // 插入的纹理坐标</span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"comment\">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class=\"line\">   float diffuse = max(dot(v_Normal, lightVector), 0.1);\" +</span><br><span class=\"line\">   <span class=\"comment\">// 根据距离哀减光线</span></span><br><span class=\"line\">   diffuse = diffuse * (1.0 / (1.0 + (0.10 * distance * distance)));\" +</span><br><span class=\"line\">   <span class=\"comment\">// 添加环境照明</span></span><br><span class=\"line\">   diffuse = diffuse + 0.3;\" +</span><br><span class=\"line\">   <span class=\"comment\">// 颜色乘以亮度哀减和纹理值得到最终的颜色</span></span><br><span class=\"line\">   gl_FragColor = v_Color * diffuse * texture2D(u_Texture, v_TexCoordinate);\" +</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们添加了一个新的常量类型<code>sampler2D</code>来表示实际纹理数据（与纹理坐标对应），<br>由定点着色器插值传入纹理坐标，我们再调用<code>texture2D(texture, textureCoordinate)</code><br>得到纹理在当前坐标的值，我们得到这个值后再乘以其他项得到最终输出的颜色。</p>\n<p>这种方式添加纹理会使整个场景变暗，因此我们还会稍微增强环境光照并减少光照哀减。</p>\n<h3 id=\"将一个图片加载到纹理\">将一个图片加载到纹理<a href=\"post/Learn-OpenGL-Lesson-Four#将一个图片加载到纹理\"></a></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">loadTexture</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> resourceId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] textureHandle = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    GLES20.glGenTextures(<span class=\"number\">1</span>, textureHandle, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (textureHandle[<span class=\"number\">0</span>] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BitmapFactory.Options options = <span class=\"keyword\">new</span> BitmapFactory.Options();</span><br><span class=\"line\">        options.inScaled = <span class=\"keyword\">false</span>; <span class=\"comment\">// 没有预先缩放</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 得到图片资源</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), resourceId, options);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在OpenGL中绑定纹理</span></span><br><span class=\"line\">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 设置过滤</span></span><br><span class=\"line\">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);</span><br><span class=\"line\">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 将位图加载到已绑定的纹理中</span></span><br><span class=\"line\">        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, <span class=\"number\">0</span>, bitmap, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回收位图，因为它的数据已加载到OpenGL中</span></span><br><span class=\"line\">        bitmap.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (textureHandle[<span class=\"number\">0</span>] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Error loading texture.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> textureHandle[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码将Android<code>res</code>文件夹中的图形文件读取并加载到OpenGL中，我会解释每一部分的作用。</p>\n<p>我们首先需要告诉OpenGL去为我们创建一个新的<code>handle</code>，这个<code>handle</code>作为一个唯一标识，我们想在OpenGL中引用纹理时就会使用它。</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final <span class=\"type\">int</span>[] textureHandle = new <span class=\"type\">int</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">GLES20.glGenTextures(<span class=\"number\">1</span>, textureHandle, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>这个OpenGL方法可以用来同时生成多个<code>handle</code>，这里我们仅生成一个。</p>\n<p>因为我们这里只需要一个handle去加载纹理。首先，我们需要得到OpenGL能理解的纹理格式。<br>我们不能只从PNG或JPG提供原始数据，因为它不会理解。我们需要做的第一步是将图像文件解码为Android Bitmap对象：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class=\"line\">options.inScaled = <span class=\"literal\">false</span>; <span class=\"comment\">// 没有预先缩放</span></span><br><span class=\"line\"><span class=\"comment\">// 得到图片资源</span></span><br><span class=\"line\">final Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), resourceId, options);</span><br></pre></td></tr></table></figure>\n<p>默认情况下，Android会根据设备的分辨率和你放置图片的资源文件目录而预先缩放位图。我们不希望Android根据我们的情况对位图进行缩放，因此我们将<code>inScaled</code>设置为<code>false</code></p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在OpenGL中绑定纹理</span></span><br><span class=\"line\">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置过滤</span></span><br><span class=\"line\">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);</span><br><span class=\"line\">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);</span><br></pre></td></tr></table></figure>\n<p>然后我们绑定纹理，并设置几个参数，绑定一个纹理，并告诉OpenGL后续OpenGL调用需要这样过滤这个纹理。我们将默认过滤器设置为<code>GL_NEAREST</code>，这是最快，也是最粗糙的过滤形式。它所做的就是在屏幕的每个点选择最近的纹素，这可能导致图像伪像和锯齿。</p>\n<ul>\n<li><code>GL_TEXTURE_MIN_FILTER</code> 这是告诉OpenGL在绘制小于原始大小（以像素为单位）的纹理时要应用哪种类型的过滤。</li>\n<li><code>GL_TEXTURE_MAG_FILTER</code> 这是告诉OpenGL在放大纹理到原始大小时要应用哪种类型的过滤。</li>\n</ul>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将位图加载到已绑定的纹理中</span></span><br><span class=\"line\">GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, <span class=\"number\">0</span>, bitmap, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 回收位图，因为它的数据已加载到OpenGL中</span></span><br><span class=\"line\">bitmap.recycle();</span><br></pre></td></tr></table></figure>\n<p>安卓有一个非常实用的功能可以直接将位图加载到OpenGL中。一旦您将资源读入Bitmap对象<code>GLUtils.texImage2D()</code>将负责其他事情，这个方法的签名：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">texImage2D</span> <span class=\"params\">(<span class=\"keyword\">int</span> target, <span class=\"keyword\">int</span> level, Bitmap bitmap, <span class=\"keyword\">int</span> border)</span></span></span><br></pre></td></tr></table></figure>\n<p>我们想要一个常规的2D位图，因此我们传入<code>GL_TEXTURE_2D</code>作为第一个参数。第二个参数用于MIP-映射，并允许您指定要在哪个级别使用的图像。我们这里没有使用MIP-映射，因此我们将传入0设置为默认级别。我们传入位图，由于我们没有使用边框，所以我们传入0。</p>\n<p>然后原始位图对象调用<code>recycle()</code>，这提醒Android可以回收这部分内存。由于纹理已被加载到OpenGL，我们不需要继续保留这个副本。<br>是的，Android应用程序在执行垃圾收集的Dalvik VM下运行，但Bitmap对象包含驻留在native内存中的数据，如果你不明确的回收它们，它们需要几个周期来进行垃圾收集。<br>这意味着如果您忘记执行此操作，实际上可能会因内存不足错误而崩溃，即使您不再持有对位图的任何引用。</p>\n<h3 id=\"将纹理应用到我们的场景\">将纹理应用到我们的场景<a href=\"post/Learn-OpenGL-Lesson-Four#将纹理应用到我们的场景\"></a></h3><p>首先，我们需要添加各种成员变量来持有我们纹理所需要的东西：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存放我们的模型数据在浮点缓冲区</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FloatBuffer mCubeTextureCoordinates;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用来传入纹理</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mTextureUniformHandle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用来传入模型纹理坐标</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mTextureCoordinateHandle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个数据元素的纹理坐标大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> mTextureCoordinateDataSize = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 纹理数据</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mTextureDataHandle;</span><br></pre></td></tr></table></figure>\n<p>我们基本上是需要添加新成员变量来跟踪我们添加到着色器的内容，以及保持对纹理的引用。</p>\n<h3 id=\"定义纹理坐标\">定义纹理坐标<a href=\"post/Learn-OpenGL-Lesson-Four#定义纹理坐标\"></a></h3><p>我们在构造方法中定义我们的纹理坐标</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// S, T （或 X， Y）</span></span><br><span class=\"line\"><span class=\"comment\">// 纹理坐标数据</span></span><br><span class=\"line\"><span class=\"comment\">// 因为图像Y轴指向下方（向下移动图片时值会增加），OpenGL的Y轴指向上方</span></span><br><span class=\"line\"><span class=\"comment\">// 我们通过翻转Y轴来调整它</span></span><br><span class=\"line\"><span class=\"comment\">// 每个面的纹理坐标都是相同的</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span>[] cubeTextureCoordinateData =</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 正面</span></span><br><span class=\"line\">                <span class=\"number\">0.0F</span>, <span class=\"number\">0.0F</span>,</span><br><span class=\"line\">                <span class=\"number\">0.0F</span>, <span class=\"number\">1.0F</span>,</span><br><span class=\"line\">                <span class=\"number\">1.0F</span>, <span class=\"number\">0.0F</span>,</span><br><span class=\"line\">                <span class=\"number\">0.0F</span>, <span class=\"number\">1.0F</span>,</span><br><span class=\"line\">                <span class=\"number\">1.0F</span>, <span class=\"number\">1.1F</span>,</span><br><span class=\"line\">                <span class=\"number\">1.0F</span>, <span class=\"number\">0.0F</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>这坐标数据看起来可能有点混乱。如果您返回去看第三课中点的位置是如何定义的，您将会发现我们为正方体每个面都定义了两个三角形。点的定义方式像下面这样：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（三角形<span class=\"number\">1</span>）</span><br><span class=\"line\">左上，</span><br><span class=\"line\">左下，</span><br><span class=\"line\">右上</span><br><span class=\"line\">（三角形<span class=\"number\">2</span>）</span><br><span class=\"line\">左下，</span><br><span class=\"line\">右下，</span><br><span class=\"line\">右上</span><br></pre></td></tr></table></figure>\n<p>纹理坐标和正面的位置坐标对应，但是由于Y轴翻转，Y轴指向和OpenGL的Y轴相反的方向。</p>\n<blockquote>\n<p>看下图，实线坐标表示在OpenGL中正方体正面X，Y坐标。虚线表示翻转后的坐标，可以看出和上面定义的纹理坐标是一一对应的</p>\n</blockquote>\n<div class=\"article-img\"><p><img src=\"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190211153435.jpg\" alt=\"纹理坐标对应\" data-zoomable=\"\"></p></div>\n<h3 id=\"设置纹理\">设置纹理<a href=\"post/Learn-OpenGL-Lesson-Four#设置纹理\"></a></h3><p>我们在<code>onSurfaceCreated()</code>方法中加载纹理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSurfaceCreated</span><span class=\"params\">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mProgramHandle = ShaderHelper.createAndLinkProgram(vertexShaderHandle, fragmentShaderHandle, <span class=\"string\">\"a_Position\"</span>, <span class=\"string\">\"a_Color\"</span>, <span class=\"string\">\"a_Normal\"</span>, <span class=\"string\">\"a_TexCoordinate\"</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 加载纹理</span></span><br><span class=\"line\">    mTextureDataHandle = TextureHelper.loadTexture(mActivityContext, R.drawable.bumpy_bricks_public_domain);</span><br></pre></td></tr></table></figure>\n<p>我们传入一个新的属性<code>a_TexCoordinate</code>绑定到我们的着色器中，并且我们通过之前创建的<code>loadTexture()</code>方法加载着色器。</p>\n<h3 id=\"使用纹理\">使用纹理<a href=\"post/Learn-OpenGL-Lesson-Four#使用纹理\"></a></h3><p>我们也需要在<code>onDrawFrame(GL10 gl)</code>方法中添加一些代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDrawFrame</span><span class=\"params\">(GL10 gl)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mTextureUniformHandle = GLES20.glGetUniformLocation(mProgramHandle, <span class=\"string\">\"u_Texture\"</span>);</span><br><span class=\"line\">    mTextureCoordinateHandle = GLES20.glGetAttribLocation(mProgramHandle, <span class=\"string\">\"a_TexCoordinate\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将纹理单元设置为纹理单元0</span></span><br><span class=\"line\">    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将纹理绑定到这个单元</span></span><br><span class=\"line\">    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureDataHandle);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过绑定到纹理单元0，告诉纹理标准采样器在着色器中使用此纹理</span></span><br><span class=\"line\">    GLES20.glUniform1i(mTextureUniformHandle, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>我们得到着色器中的纹理数据和纹理坐标句柄。在OpenGL中，纹理能在着色之前，需要绑定到纹理单元。纹理单元是读取纹理并实际将它传入着色器的中，因此可以再屏幕上显示。不同的图形芯片有不同数量的纹理单元，因此在使用它们之前，您需要检查是否存在其他纹理单元。</p>\n<p>首先，我们告诉OpenGL我们想设置使用的纹理单元到第一个单元，纹理单元0。然后自动绑定纹理到第一个单元，通过调用<code>glBindTexture()</code>。最后，我们告诉OpenGL，我们想将<code>mTextureUniformHandle</code>绑定到第一个纹理单元，它引用了片段着色器中<code>u_Texture</code>属性。</p>\n<p>简而言之：</p>\n<ol>\n<li>设置纹理单元</li>\n<li>绑定纹理到这个单元</li>\n<li>将此单元指定给片段着色器中的纹理标准</li>\n</ol>\n<p>根据需要重复多个纹理。</p>\n<h3 id=\"进一步练习\">进一步练习<a href=\"post/Learn-OpenGL-Lesson-Four#进一步练习\"></a></h3><p>一旦您做到这儿，您就完成的差不多了！当然这这并没有您预期的那么糟糕…或者确实糟糕？😉作为下一个练习，尝试通过加载另一个纹理，将其绑定到另一个单元，并在着色器中使用它。</p>\n<h2 id=\"回顾\">回顾<a href=\"post/Learn-OpenGL-Lesson-Four#回顾\"></a></h2><p>现在我们回顾一下所有的着色器代码，以及我们添加了一个新的帮助功能用来从资源目录读取着色器代码，而不是存储在java字符串中：</p>\n<h3 id=\"顶点着色器-all\">顶点着色器 all<a href=\"post/Learn-OpenGL-Lesson-Four#顶点着色器-all\"></a></h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">mat4</span> u_MVPMatrix;                      <span class=\"comment\">// 一个表示组合model、view、projection矩阵的常量</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">mat4</span> u_MVMatrix;                       <span class=\"comment\">// 一个表示组合model、view矩阵的常量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> a_Position;                     <span class=\"comment\">// 我们将要传入的每个顶点的位置信息</span></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> a_Color;                        <span class=\"comment\">// 我们将要传入的每个顶点的颜色信息</span></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec3</span> a_Normal;                       <span class=\"comment\">// 我们将要传入的每个顶点的法线信息</span></span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec2</span> a_TexCoordinate;                <span class=\"comment\">// 我们将要传入的每个顶点的纹理坐标信息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec3</span> v_Position;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec4</span> v_Color;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec3</span> v_Normal;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec2</span> v_TexCoordinate;                  <span class=\"comment\">// 这将会传入到片段着色器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 顶点着色器入口点</span></span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 传入纹理坐标</span></span><br><span class=\"line\">   v_TexCoordinate = a_TexCoordinate;</span><br><span class=\"line\">   <span class=\"comment\">// 将顶点位置转换成眼睛空间的位置</span></span><br><span class=\"line\">   v_Position = <span class=\"type\">vec3</span>(u_MVMatrix * a_Position);</span><br><span class=\"line\">   <span class=\"comment\">// 传入颜色</span></span><br><span class=\"line\">   v_Color = a_Color;</span><br><span class=\"line\">   <span class=\"comment\">// 将法线的方向转换在眼睛空间</span></span><br><span class=\"line\">   v_Normal = <span class=\"type\">vec3</span>(u_MVMatrix * <span class=\"type\">vec4</span>(a_Normal, <span class=\"number\">0.0</span>));</span><br><span class=\"line\">   <span class=\"comment\">// gl_Position是一个特殊的变量用来存储最终的位置</span></span><br><span class=\"line\">   <span class=\"comment\">// 将顶点乘以矩阵得到标准化屏幕坐标的最终点</span></span><br><span class=\"line\">   <span class=\"built_in\">gl_Position</span> = u_MVPMatrix * a_Position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"片段着色器-all\">片段着色器 all<a href=\"post/Learn-OpenGL-Lesson-Four#片段着色器-all\"></a></h3><figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">mediump</span> <span class=\"type\">float</span>; <span class=\"comment\">//我们将默认精度设置为中等，我们不需要片段着色器中的高精度</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> u_Texture;  <span class=\"comment\">// 传入纹理</span></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec3</span> u_LightPos; <span class=\"comment\">// 光源在眼睛空间的位置</span></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec3</span> v_Position; <span class=\"comment\">// 插入的位置</span></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec4</span> v_Color; <span class=\"comment\">// 插入的位置颜色</span></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec3</span> v_Normal; <span class=\"comment\">// 插入的位置法线</span></span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"type\">vec2</span> v_TexCoordinate; <span class=\"comment\">// 插入的纹理坐标</span></span><br><span class=\"line\"><span class=\"type\">void</span> main()  <span class=\"comment\">// 片段着色器入口</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 将用于哀减</span></span><br><span class=\"line\">   <span class=\"type\">float</span> <span class=\"built_in\">distance</span> = <span class=\"built_in\">length</span>(u_LightPos - v_Position);</span><br><span class=\"line\">   <span class=\"comment\">// 获取从光源到顶点方向的光线向量</span></span><br><span class=\"line\">   <span class=\"type\">vec3</span> lightVector = <span class=\"built_in\">normalize</span>(u_LightPos - v_Position);</span><br><span class=\"line\">   <span class=\"comment\">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class=\"line\">   <span class=\"type\">float</span> diffuse = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(v_Normal, lightVector), <span class=\"number\">0.1</span>);</span><br><span class=\"line\">   <span class=\"comment\">// 根据距离哀减光线</span></span><br><span class=\"line\">   diffuse = diffuse * (<span class=\"number\">1.0</span> / (<span class=\"number\">1.0</span> + (<span class=\"number\">0.25</span> * <span class=\"built_in\">distance</span> * <span class=\"built_in\">distance</span>)));</span><br><span class=\"line\">   <span class=\"comment\">// 添加环境照明</span></span><br><span class=\"line\">   diffuse = diffuse + <span class=\"number\">0.3</span>;</span><br><span class=\"line\">   <span class=\"comment\">// 颜色乘以亮度哀减和纹理值得到最终的颜色</span></span><br><span class=\"line\">   <span class=\"built_in\">gl_FragColor</span> = v_Color * diffuse * <span class=\"built_in\">texture2D</span>(u_Texture, v_TexCoordinate);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"怎样从raw资源目录中读取文本？\">怎样从raw资源目录中读取文本？<a href=\"post/Learn-OpenGL-Lesson-Four#怎样从raw资源目录中读取文本？\"></a></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RawResourceReader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">readTextFileFromRawResource</span><span class=\"params\">(<span class=\"keyword\">final</span> Context context, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> resurceId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> InputStream inputStream = context.getResources().openRawResource(resurceId);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> InputStreamReader inputStreamReader = <span class=\"keyword\">new</span> InputStreamReader(inputStream);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(inputStreamReader);</span><br><span class=\"line\"></span><br><span class=\"line\">        String nextLine;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> StringBuilder body = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((nextLine = bufferedReader.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                body.append(nextLine).append(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                bufferedReader.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> body.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"教程目录\">教程目录<a href=\"post/Learn-OpenGL-Lesson-Four#教程目录\"></a></h2><ul>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One\">OpenGL Android课程一：入门</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two\">OpenGL Android课程二：环境光和漫射光</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three\">OpenGL Android课程三：使用每片段照明</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four\">OpenGL Android课程四：介绍纹理基础</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five\">OpenGL Android课程五：介绍混合（Blending）</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six\">OpenGL Android课程六：介绍纹理过滤</a></li>\n<li><a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven\">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）</a></li>\n</ul>\n<h2 id=\"打包教材\">打包教材<a href=\"post/Learn-OpenGL-Lesson-Four#打包教材\"></a></h2><p>可以在Github下载本课程源代码：<a href=\"https://github.com/learnopengles/Learn-OpenGLES-Tutorials\" target=\"_blank\" rel=\"noopener\">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href=\"https://market.android.com/details?id=com.learnopengles.android\" target=\"_blank\" rel=\"noopener\">google play 下载apk</a><br>“我”也编译了个apk，方便大家下载：<a href=\"https://github.com/xujiaji/LearnOpenGL/releases\" target=\"_blank\" rel=\"noopener\">github download</a></p>\n","prev":{"title":"OpenGL Android课程五：介绍混合（Blending）","slug":"Learn-OpenGL-Lesson-Five"},"next":{"title":"OpenGL Android课程三：使用每片段照明","slug":"Learn-OpenGL-Lesson-Three"},"link":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four/","toc":[{"title":"介绍纹理基础","id":"介绍纹理基础","index":"1","children":[{"title":"前提条件","id":"前提条件","index":"1.1"},{"title":"纹理基础","id":"纹理基础","index":"1.2"},{"title":"纹理坐标","id":"纹理坐标","index":"1.3"},{"title":"纹理映射基础","id":"纹理映射基础","index":"1.4","children":[{"title":"顶点着色器","id":"顶点着色器","index":"1.4.1"},{"title":"片段着色器","id":"片段着色器","index":"1.4.2"},{"title":"将一个图片加载到纹理","id":"将一个图片加载到纹理","index":"1.4.3"},{"title":"将纹理应用到我们的场景","id":"将纹理应用到我们的场景","index":"1.4.4"},{"title":"定义纹理坐标","id":"定义纹理坐标","index":"1.4.5"},{"title":"设置纹理","id":"设置纹理","index":"1.4.6"},{"title":"使用纹理","id":"使用纹理","index":"1.4.7"},{"title":"进一步练习","id":"进一步练习","index":"1.4.8"}]},{"title":"回顾","id":"回顾","index":"1.5","children":[{"title":"顶点着色器 all","id":"顶点着色器-all","index":"1.5.1"},{"title":"片段着色器 all","id":"片段着色器-all","index":"1.5.2"},{"title":"怎样从raw资源目录中读取文本？","id":"怎样从raw资源目录中读取文本？","index":"1.5.3"}]},{"title":"教程目录","id":"教程目录","index":"1.6"},{"title":"打包教材","id":"打包教材","index":"1.7"}]}],"reward":true,"copyright":{"author":"xujiaji","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow noopener\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","link":"<a href=\"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four/\" title=\"OpenGL Android课程四：介绍纹理基础\">https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four/</a>"}}