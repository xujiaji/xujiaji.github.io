[{"title":"玩清单，莫得感情的使用说明","date":"2019-05-19T07:58:19.879Z","updated":"2019-05-19T11:10:30.563Z","content":"\n\n\n\n\n\n\n\n\n\n\n\n\n截图\n说明\n\n\n\n\n\n每日一句，每次打开都会弹出一句话和一张精选图片。可以在“我的”里面关闭\n\n\n\n当进去后，没有登录时的贴心提示\n\n\n\n未登录时，点击上面提示的加号按钮将会弹出登录框。输入账号密码后，点击登录可进行登录。如果没有账号密码可以点击“注册”切换到注册\n\n\n\n点击底部左下角的默认分类处可弹出该气泡，用来切换分类，目前只有这四个固定分类\n\n\n\n现在点击右下的加号按钮就会进入到清单添加界面，此时可输入清单内容\n\n\n\n执行日期选择点击弹出该视图，现在可以选择当前清单的执行日期选择后的按钮会变色不选，默认当天时间\n\n\n\n分类选择点击弹出该视图，现在可以选择当前清单的分类选择后按钮会变色不选，默认分类\n\n\n\n优先级选择点击弹出该视图，现在可以选择当前清单的优先级选择后按钮会变色不选，默认优先级\n\n\n\n添加详情点击弹出该视图，现在可以输入清单的详情内容了，输入完成请点击确定输入了按钮会变色标识可选输入\n\n\n\n确认添加清单点击确认添加该清单，添加成功后将会跳转到对应的分类列表\n\n\n\n添加成功后跳转到对应列表，如果是前两次显示列表还会有操作提示\n\n\n\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/wantodo/banner.jpg","plink":"https://blog.xujiaji.com/post/wantodo-guide/"},{"title":"OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VBO）","date":"2019-03-09T08:49:10.000Z","author":"xujiaji","updated":"2019-04-12T17:44:07.238Z","content":"\n翻译文\n\n原文标题：Android Lesson Seven: An Introduction to Vertex Buffer Objects (VBOs)原文链接：http://www.learnopengles.com/android-lesson-seven-an-introduction-to-vertex-buffer-objects-vbos/\n\n介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VBO）\n\n\n\n在这节课中，我们将介绍如何定义和如何去使用顶点缓冲对象（VBO）。下面是我们要讲到的几点：1.怎样用顶点缓冲对象定义和渲染2.单个缓冲区、所有数据打包进去、多个缓冲区之间的区别3.问题和陷阱我们如何取处理它们\n\n\n\n\n什么是顶点缓冲区对象？为什么使用它们？到目前为止，我们所有的课程都是将对象数据存储在客户端内存中，只有在渲染时将其传输到GPU中。没有大量数据传输时，这很好，但随着我们的场景越来越复杂，有更多的物体和三角形，这会给GPU和内存增加额外的成本。\n我们能做些什么呢？我们可以使用顶点缓冲对象，而不是每帧从客户端内存传输顶点信息，信息将被传输一次，然后渲染器将从该图形存储器缓存中得到数据。\n前提条件请阅读OpenGL Android课程一：入门介绍如何从客户端的内存上传顶点数据。了解OpenGL ES如何与顶点数组一起工作对于理解本课至关重要。\n更详细的了解客户端缓冲区一但了解了如何使用客户端内存进行渲染，切换到使用VBO实际上并不太难。其主要的不同在于添加了一个上传数据到图形内存的额外步骤，以及渲染时添加了绑定这个缓冲区的额外调用。\n本节课将使用四种不同的模式：\n\n客户端，单独的缓冲区\n客户端，打包的缓冲\n顶点缓冲对象，单独的缓冲区\n顶点缓冲对象，打包的缓冲\n\n无论我们是否使用顶点缓冲对象，我们都需要先将我们的数据存储在客户端本地缓冲区。会想到第一课中OpenGL ES 是一个本地系统库，而java是运行在Android上的一个虚拟机中。如何去桥接这个距离？我们需要使用一组特殊的缓冲区类来在本地堆上分配内存，并使使其供OpenGL访问：\n123456789101112131415// Java 数组float[] cubePositions;...// 浮点缓冲区final FloatBuffer cubePositionsBuffer;...// 在本地堆上直接分配一块内存// 字节大小为cubePositions的长度乘以每个浮点数的字节大小// 每个float的字节大小为4，因为float是32位或4字节cubePositionsBuffer = ByteBuffer.allocateDirect(cubePositions.length * BYTES_PRE_FLOAT)// 浮点会以大端（big-endian）或小段（little-endian）的顺序排列// 我想让其同本地平台相同的排列.order(ByteOrder.nativeOrder())// 在这个字节缓冲区上给我们一个浮点视角.asFloatBuffer();\n将Java堆上数据转换到本地堆上，就是两方法调用的事情：\n12345// 将java堆上的数据拷贝到本地堆cubePositionsBuffer.put(cubePositions)// 重置这个缓冲区开始的缓冲位置.position(0);\n缓冲位置的目的是什么？通常，Java没有为我们提供一种在内存中使用指针，任意指定位置的方法。然而，设置缓冲区的位置在功能上等同于更改指向内存块指针的值。通过改变指针的位置，我们可以将缓冲区中任意的内存位置传递给OpenGL调用。当我们使用打包的缓冲作业时，这将派上用场。\n一但数据存放到本地堆上，我们就不需要长时间持有float[]数组了，我们可以让垃圾回收器清理它。\n使用客户端缓冲区进行渲染非常简单，我们仅需要启动对应属性的顶点素组，并将指针传递给我们的数据：\n1234// 传入位置信息GLES20.glEnableVertexAttribArray(mPositionHandle);GLES20.glVertexAttriPointer(mPositionHandle, POSITION_DATA_SIZE,    GLES20.GL_FLOAT, false, 0, mCubePositions)\nglVertexAttriPointer参数说明：\n\nmPositionHandle： 我们着色器程序的位置属性索引\nPOSITION_DATA_SIZE： 定义这个属性需要多少个float元素\nGL_FLOAT： 每个元素的类型\nfalse： 定点数据因该标准化吗？由于我们使用的是浮点数据，因此不适用。\n0： 跨度，设置0，以为着应安顺序读取。第一课中设置为7，表示每次读取跨度7个位置\nmCubePositions： 指向缓冲区的的指针，包含所有位置数据\n\n使用打包缓冲区使用打包缓冲区是非常相似的，替换了每个位置、法线等的缓冲区，现在一个缓冲区将包含所有这些数据。不同点看下面：\n\n使用单缓冲区\n\n123positions = X,Y,Z,X,Y,Z,X,Y,Z,...colors = R,G,B,A,R,G,B,A,...textureCoordinates = S,T,S,T,S,T...\n\n使用打包缓冲区\n\n1buffer = X,Y,Z,R,G,B,A,S,T...\n使用打包缓冲区的好处是它将会使GPU更高效的渲染，因为渲染三角形所需的所有信息都位于内存同一块地方。缺点是，如果我们使用动态数据，更新可能会更困难，更慢。\n当我们使用打包缓冲区时，我们需要以下几种方式更改渲染调用。首先，我们需要告诉OpenGL跨度（stride） ，定义一个顶点的字节数。\n123456789101112131415final int stride = (POSITION_DATA_SIZE + NORMAL_DATA_SIZE + TEXTURE_COORDINATE_DATA_SIZE)    * BYTES_PER_FLOAT;// 传入位置信息mCubeBuffer.position(0);GLES20.glEnableVertexAttribArray(mPositionHandle);GLES20.glVertexAttribPointer(mPositionHandle, POSITION_DATA_SIZE,    GLES20.GL_FLOAT, false, stride, mCubeBuffer);// 传入法线信息mCubeBuffer.position(POSITION_DATA_SIZE);GLES20.glEnableVertexAttribArray(mNormalHandle);GLES20.glVertexAttribPointer(mNormalHandle, NORMAL_DATA_SIZE,    GLES20.GL_FLOAT, false, stride, mCubeBuffer);...\n这个跨度告诉OpenGL ES下一个顶点的同样的属性要再跨多远才能找到。例如：如果元素0是第一个顶点的开始位置，并且这里每个顶点有8个元素，然后这个跨度将是8个元素，也就是32个字节。下一个顶点的位置将找到第8个元素，下下个顶点的位置将找到第16个元素，以此类推。\n请记住，传递给glVertexAttriPointer的跨度单位是字节，而不是元素，因此请记住进行该转换。\n注意，当我们从指定位置切换到指定法线时，我们要更改缓冲区的其实位置。这是我们之前提到的指针算法，这是我们在使用OpengGL ES时用Java做的方式。我们仍然使用同一个缓冲区mCubeBuffer，但是我们告诉OpenGL从位置数据后的第一个元素开始读取法线信息。我们也告诉OpenGL下一个法线要跨越8个元素（也可以说是32个字节）开始。\nDalvik和本地堆上的内存如果你在本地堆上分配大量内存把并将其释放，您迟早会遇到心爱的OutOfMemoryError ，背后有几个原因：\n\n您可能认为通过让引用超出范围而自动释放了内存，但是本地内存似乎需要一些额外的GC周期才能完全清理，如果没有足够可用的内存并且尚未释放本地内存，Dalvik将抛出异常。\n本地堆可能会碎片化，调用allocateDirect()将会莫名其妙失败，尽管似乎有足够的内存可用。有时它有助于进行较小的分配，释放它，然后再次尝试更大的分配。\n\n如何能避免这些问题？除了希望Google在未来的版本中改进Dalvik的行为之外，并不多。或者通过本地代码进行分配或预先分配一大块内存来自行管理堆，并根据此分离缓冲区。\n\n注意：这些信息最初写于2012年初，现在Android使用了一个名为ART的不同运行时，它可能在相同程度上不会遇到这些问题。\n\n移动到顶点缓冲区对象现在我们已经回顾了使用客户端缓冲区，让我们继续讨论顶点缓冲区对象！首先，我们需要回顾几个非常重要的问题：\n1. 缓冲区必须创建在一个有效的OpenGL上下文中这似乎是一个明显的观点，但是它仅仅提醒你必须等到onSurfaceCreated()执行，并且你必须注意OpenGL ES调用是在GL线程上完成的。看这个文档：iOS OpenGL ES编程指南，它可能是为iOS写的，但是OpenGL ES在Android的行为和这相同。\n2. 顶点缓冲区对象使用不当会导致图形驱动程序崩溃当你使用顶点缓冲对象时，需要注意传递的数据。不当的值将会导致OpenGL ES系统库或图形驱动库本地崩溃。在我的Nexus S上，一些游戏完全卡在我的手机上或导致手机重启，因为图形驱动因为他们的指令崩溃。并非所有的崩溃都会锁定您的设备，但至少您不会看到“此应用已停止工作”的对话框。您的活动将在没有警告的情况下重新启动，您将获得唯一的信息可能是日志中的本地调试跟踪。\n上传顶点数据到GPU要上传数据到GPU，我们需要像以前一样创建客户端缓冲区的相同步骤：\n12345...cubePositionsBuffer = ByteBuffer.allocateDirect(cubePositions.length * BYTES_PER_FLOAT).order(ByteOrder.nativeOrder()).asFloatBuffer();cubePositionsBuffer.put(cubePositions).position(0);...\n一旦我们有了客户端缓冲区，我们就可以创建一个顶点缓冲区对象，并使用一下指令将数据从客户端内存上传到GPU：\n123456789101112131415// 首先，我们要尽可能的申请更多的缓冲区// 这将为我们提供这些缓冲区的handlefinal int buffers[] = new int[3];GLES20.glGenBuffers(3, buffers, 0);// 绑定这个缓冲区，将来的指令将单独影响此缓冲区GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, buffers[0]);// 客户端内存中的数据转移到缓冲区// 我们能在此次调动后释放客户端内存GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, cubePositionsBuffer.capacity() * BYTES_PER_FLOAT,    cubePositionsBuffer, GLES20.GL_STATIC_DRAW);// 重要提醒：完成缓冲后，从缓冲区取消绑定GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0);\n一旦数据上传到了OpenGL ES，我们就可以释放这个客户端内存，因为我们不需要再继续保留它。这是glBufferData的解释：\n\nGL_ARRAY_BUFFER： 这个缓冲区包含顶点数据数组\ncubePositionsBuffer.capacity()  BYTES_PER_FLOAT：* 这个缓冲区因该包含的字节数\ncubePositionsBuffer： 将要拷贝到这个顶点缓冲区对象的源\nGL_STATIC_DRAW： 这个缓冲区不会动态更新\n\n我们对glVertexAttribPointer的调用看起来有点儿不同，因为最后一个参数现在是偏移量而不是指向客户端内存的指针：\n12345// 传入位置信息GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, mCubePositionsBufferIdx);GLES20.glEnableVertexAttribArray(mPositionHandle);mGlEs20.glVertexAttribPointer(mPositionHandle, POSITION_DATA_SIZE, GLES20.GL_FLOAT, false, 0, 0);...\n像以前一样，我们绑定到缓冲区，然后启用顶点数组。由于缓冲区早已绑定，当从缓冲区读取数据时，我们仅需要告诉OpenGL开始的偏移。因为我们使用的特定的缓冲区，我们传入偏移量0。另请注意，我们使用自定义绑定来调用glVertexAttribPointer，因为官方SKD缺少此特定函数调用。\n一旦我们用缓冲区绘制完成，我们应该解除它：\n1GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0);\n当我们不想在保留缓冲区时，我们可以释放内存：\n123final int[] buffersToDelete = new int[] &#123; mCubePositionsBufferIdx, mCubeNormalsBufferIdx,    mCubeTexCoordsBufferIdx &#125;;GLES20.glDeleteBuffers(buffersToDelete.length, buffersToDelete, 0);\n打包顶点缓冲区对象我们还可以使用单个缓冲区打包顶点缓冲区对象的所有顶点数据。打包顶点缓冲区的创建和上面相同，唯一的区别是我们从打包客户端缓冲区开始。打包缓冲区渲染也是一样的，除了我们需要传偏移量，就像在客户端内存中使用打包缓冲区一样：\n123456789101112131415final int stride = (POSITION_DATA_SIZE + NORMAL_DATA_SIZE + TEXTURE_COORDINATE_DATA_SIZE)    * BYTES_PER_FLOAT;// 传入位置信息GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, mCubeBufferIdx);GLES20.glEnableVertexAttribArray(mPositionHandle);mGlEs20.glVertexAttribPointer(mPositionHandle, POSITION_DATA_SIZE,    GLES20.GL_FLOAT, false, stride, 0);// 传入法线信息GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, mCubeBufferIdx);GLES20.glEnableVertexAttribArray(mNormalHandle);mGlEs20.glVertexAttribPointer(mNormalHandle, NORMAL_DATA_SIZE,    GLES20.GL_FLOAT, false, stride, POSITION_DATA_SIZE * BYTES_PER_FLOAT);...\n注意：偏移量需要以字节为单位指定。与之前一样解除绑定和删除缓冲区的相同注意事项也适用。\n将顶点数据放到一起这节课已构建了多立方体组成的立方体，每个面的立方体数量体相同。它将在1x1x1立方体和16x16x16立方体之间构建立方体。由于每个立方体共享相同的法线和纹理数据，因此在初始化客户端缓冲区时将重复复制此数据。所有立方体都将在同一个缓冲区对象中结束。\n您可以查看课程中的代码并查看使用和不使用VBO，以及使用和不使用打包缓冲区进行渲染的示例。检查代码以查看如何处理一下某些操作：\n\n通过runOnUiThread()将事件从OpenGL线程发布回UI主线程\n异步生成顶点数据\n处理内存溢出异常\n我们移除了glEnable(GL_TEXTURE_2D)的调用，因为它实际在OpenGL ES 2是一个无效枚举。这是以前的固定写法延续下来的，在OpenGLES2中，这些东西由着色器处理，因此不需要使用glEnable或glDisable。\n怎样使用不同的方式进行渲染，而不添加太多的if语句和条件。\n\n进一步练习您何时使用顶点缓冲区？什么时候从客户端内存传输数据更好？使用顶点缓冲区对象有哪些缺点？您将如何改进异步加载代码？\n教程目录\nOpenGL Android课程一：入门\nOpenGL Android课程二：环境光和漫射光\nOpenGL Android课程三：使用每片段照明\nOpenGL Android课程四：介绍纹理基础\nOpenGL Android课程五：介绍混合（Blending）\nOpenGL Android课程六：介绍纹理过滤\nOpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VBO）\n\n打包教材可以在Github下载本课程源代码：下载项目本课的编译版本也可以再Android市场下：google play 下载apk为了方便大家下载，“我”也编译了个apk，：github download\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190324170029.png","plink":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven/"},{"title":"OpenGL Android课程六：介绍纹理过滤","date":"2019-02-19T08:24:18.000Z","author":"xujiaji","updated":"2019-04-08T06:56:15.793Z","content":"\n翻译文\n\n原文标题：Android Lesson Six: An Introduction to Texture Filtering原文链接：http://www.learnopengles.com/android-lesson-six-an-introduction-to-texture-filtering/\n\n介绍纹理过滤\n\n\n\n这节课，我们将介绍基本纹理过滤的不同类型和怎样使用它们，包括最邻近（nearest-neighbour）过滤，双线性(bilinear)过滤，和使用mipmap的三线性(trilinear)过滤。你将学习如何使纹理看起来更平滑，以及平滑带来的缺点。[这儿有旋转物体][]的不同方式，本课使用了其中一。\n\n\n\n\n前提条件强烈建议您先阅读OpenGL Android课程四：介绍纹理基础，理解纹理映射在OpenGL中的基本使用。\n什么是纹理过滤？OpenGLES中的纹理由元素数组组成，被称为纹素(texels)，其中包含颜色和alpha值。这与显示器相对应，显示器由一堆像素组成，并在每个点显示不同的颜色。在OpenGL中纹理被用在三角形上并绘制到屏幕，因此这些纹理能绘制出各种各样的尺寸和方向。OpenGL中的纹理过滤选项告诉它如何根据具体情况将纹理像素过滤到设备的像素上。\n\n有三种情况：\n\n\n每个纹素映射到多个像素，这被称为放大(magnification)\n每个纹素精确的映射到一个像素，过滤不适合这种情况\n每个纹素映射少于一个像素，这被称为缩小(minification)\n\nOpenGL允许我们为放大和缩小分配过滤器，并允许我们使用最邻近、双线性和三线性过滤。我们将在下面解释这些意思。\n放大和缩小这里是放大和缩小的最邻近渲染的可视化，当您用USB连接你的Android设备时使用这个可爱的Android显示成功连接。\n\n放大\n正如您所见，纹素现在很容易看到，因为当前一个纹素覆盖了很多像素展示出来。\n缩小\n随着缩小，许多纹素不能渲染到有限的像素上，许多细节将会丢失。\n纹理过滤模式双线性插值（Bilinear interpolation）当纹素值之间没有插值时，在放大示例中，纹理的纹素清晰可见为大正方形。当使用最邻近方式时，像素将会分配到最邻近的像素。\n通过切换到双线性插值，渲染质量显著提高。这些值将会在邻近的四个像素之间线性插值，而不是将一组像素分配给邻近相同的纹素值。每个像素被平滑化，使得最后的图片看起来也更平滑：\n\n一些块效果仍然很明显，但是这个图片看起来比之前更加平滑。那些在3D加速卡出现前玩过3D游戏的人将会记得软件渲染游戏和硬件加速游戏之间的特性：软件渲染游戏根本没有进行预计算处理，所以一切都显示得块状和锯齿状。一旦人们开始使用图形加速，这些东西都将变得平滑。\n\n双线性插值大多使用在放大。它也能使用在缩小，但是超过某个度，我们将会遇到同样的问题，我们在尝试将太多的纹素放到相同的像素上。OpenGL仅使用最多4个纹素渲染一个像素，因此许多信息仍然会丢失。\n如果我们看应用了双线性插值的纹理，当我们在远处看它移动时看起来会很嘈杂，因为每帧都会选择不同的纹素。\n纹理映射（Mipmapping）我们如何才能在缩小纹理时不引用嘈杂并使用上所有纹素呢？我们可以生成一组优化后的不同尺寸的纹理，然后在我们运行的时候使用它们。由于这些纹理已预先生成，它们能使用更多高昂的技术去过滤所有纹素，并且在运行时OpenGL会根据纹理在屏幕上的最终大小选择最合适的层。\n\n生成的图片可以具有更多细节，更少噪点，并且整体上看起来更好。尽管需要更多的内存，但渲染速度也会更快，因为较小的层级能更容易保存在GPU的纹理缓存中。让我们来仔细研究一下原尺寸的1/8倍的图片，在使用了双线性过滤使用纹理映射和双线性过滤没有使用映射。为了清楚图片已被扩大：\n双线性过滤没有mipmap\n双线性过滤+mipmap\n使用mipmap的版本拥有更多细节，由于图像预处理到单独的层级，所有纹素最终都会在最终的图像中使用。\n三线性过滤（Trilinear filtering）当使用双线性过滤的mipmap时，有时在渲染场景中可以看到明显的跳跃或线，由于OpenGL在纹理的不同mipmap层级之间切换。比较不同的OpenGL纹理的过滤模式将在下面进一步指出。\n三线性插值通过在不同mipmap层级之间插值来解决这个问题，这样总共8个纹素将用于插值得到最终的像素值，使得图像更平滑。\nOpenGL 纹理过滤模式OpenGL有两个可被设置的参数：\n\nGL_TEXTURE_MIN_FILTER 纹理缩小时的过滤模式\nGL_TEXTURE_MAG_FILTER 纹理放大时的过滤模式\n\n这些相对应于上面的缩小和放大描述。  \n\nGL_TEXTURE_MIN_FILTER接受以下选项：\nGL_NEAREST\nGL_LINEAR\nGL_NEAREST_MIPMAP_NEAREST\nGL_NEAREST_MIPMAP_LINEAR\nGL_LINEAR_MIPMAP_NEAREST\nGL_LINEAR_MIPMAP_LINEAR\n\n\nGL_TEXTURE_MAG_FILTER接受以下选项：\nGL_NEAREST\nGL_LINEAR\n\n\n\nGL_NEAREST 对应最邻近渲染；GL_LINEAR 对应双线性过滤；GL_LINEAR_MIPMAP_NEAREST 对应双线性过滤+mipmap；GL_LINEAR_MIPMAP_LINEAR 对应三线性过滤；本课中将进一步介绍图形示例和最常见选项的进一步说明。\n怎样设置纹理过滤模式我们首先需要绑定纹理，然后我们在这个纹理上设置合适的过滤参数：\n12GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureHandle);GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, filter);\n怎样生成mipmap这真的很容易！在加载纹理到OpenGL中后，纹理仍然是绑定的，我们可以简单的调用：\n1GLES20.glGenerateMipmap(GLES20.GL_TEXTURE_2D);\n它将为我们生成所有的mipmap层级，并且这些层级会根据纹理过滤自动使用。\n它看起来怎么样？以下是可用的最常见的组合的屏幕截图，当你看到它运动中时，效果更加引人注目，因此我建议下载这个App并试一试。\n最邻近渲染这个模式让人想起旧版3D游戏软件的渲染。\n12GL_TEXTURE_MIN_FILTER = GL_NEARESTGL_TEXTURE_MAG_FILTER = GL_NEAREST\n\n双线性过滤，mipmap许多支持3D加速的首批游戏都使用此模式，这是今天在Android手机上平滑纹理的有效方式。\n12GL_TEXTURE_MIN_FILTER = GL_LINEAR_MIPMAP_NEARESTGL_TEXTURE_MAG_FILTER = GL_LINEAR\n\n静态图上很难看图问题，但是当物体运动时，您可能会注意到渲染的像素在mipmap层级之间切换的水平条带。\n三线性过滤此模式通过在mipmap层级之间进行插值，改进了使用mipmap的双线性过滤的渲染质量。\n12GL_TEXTURE_MIN_FILTER = GL_LINEAR_MIPMAP_LINEARGL_TEXTURE_MAG_FILTER = GL_LINEAR\n\n像素在近距离和远距离之间完全平滑；事实上，纹理现在可能在倾斜角度下显示的过于平滑。各向异性过滤（Anisotropic filtering）是一种更先进的技术，受到某些移动GPU的支持，可用于改善最终结果，超出三线性过滤所能提供的效果。\n进一步练习使用其他模式可以达到什么样的效果？例如，您何时会使用像GL_NEAREST_MIPMAP_LINEAR这样的东西？\n教程目录\nOpenGL Android课程一：入门\nOpenGL Android课程二：环境光和漫射光\nOpenGL Android课程三：使用每片段照明\nOpenGL Android课程四：介绍纹理基础\nOpenGL Android课程五：介绍混合（Blending）\nOpenGL Android课程六：介绍纹理过滤\nOpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）\n\n打包教材可以在Github下载本课程源代码：下载项目本课的编译版本也可以再Android市场下：google play 下载apk“我”也编译了个apk，方便大家下载：github download\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190224214007.jpg","plink":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six/"},{"title":"OpenGL Android课程五：介绍混合（Blending）","date":"2019-02-12T08:37:00.000Z","author":"xujiaji","updated":"2019-04-08T06:55:57.729Z","content":"\n翻译文\n\n原文标题：Android Lesson Five: An Introduction to Blending原文链接：http://www.learnopengles.com/android-lesson-five-an-introduction-to-blending/\n\n介绍混合（Blending）\n\n\n\n这节课，我们来学习混合(blending)在OpenGL中的基本使用。我们来看看如何打开或关闭混合，怎样设置不同的混合模式，以及不同的混合模式如何模仿显示生活中的效果。在后面的课程中，我们还将介绍如何使用alpha通道，如何使用深度缓冲区在同一个场景中渲染半透明和不透明的物体，以及什么时候按深度排序对象，以及为什么。我们还将研究如何监听触摸事件，然后基于此更改渲染状态。\n基本混合\n\n\n\n前提条件本系列每个课程构建都是以前一个课程为基础。然而，对于这节课，如果您理解了OpenGL Android课程一：入门就足够了。尽管代码基本上是前一课的，照明和纹理部分已在本课中移除，因此我们仅关注混合。\n混合（Blending）混合是将一种颜色与另一种颜色组合以获得第三种颜色的行为。我们在现实世界任何时候都能看到混合：当光穿过玻璃时，当它从表面反射时，当光源本身叠加在背景上时，例如我们在晚上看到一盏明亮的路灯周围的耀斑。\nOpenGL有不同的混合模式，我们能使用它模拟这种效果。在OpenGL中，混合发生在渲染过程的后期：一旦片段着色器计算出片段的最终输出颜色并且它即将被写入帧缓冲区，就会发生这种情况。通常情况下，这片段会覆盖之前所有内容，但如果启用了混合，那么该片段将与之前的片段混合。\n默认情况下，当glBlendEquation()设置为默认值GL_FUNC_ADD时OpenGL的默认混合方程式为：\n12// 输出 = （源因子 * 源片段） + （目标因子 * 目标片段）output = (source factor * source fragment) + (destination factor * destination fragment)\nOpenGL ES 2 中还有另外两种模式GL_FUNC_SUBTRACT和GL_FUNC_REVERSE_SUBTRACT。这些可能在以后的教程中介绍，然而，当我尝试调用此函数时，我在Nexus S上遇到了UnsupportedOperationException，因此Android实现可能实际上不支持此功能。这不是世界末日，因为你可以用GL_FUNC_ADD做很多事情。\n使用函数glBlendFunc()设置源因子和目标因子。下面将给出几个常见混合因子的概述；更多信息以及不同可能的因素的列举，请参阅Khronos在线手册：\n\nglBlendFunc()\nglBlendEquation()\n\n截取（Clamping）OpenGL预期的输入被限制在[0,1]的范围内，并且输入也被限制在[0,1]。这在实践中意味着当您进行混合时，颜色可以在色调中移动。如果继续想帧缓冲区添加红色（RGB = 1，0，0），最终颜色会是红色。如果想添加一点儿绿色，您要添加（RGB = 1，0.1，0）到缓冲区，即使您开始带红色的色调，最后也会得到黄色！打开混合时，您可以在本课程的Demo中看到此效果：不同颜色的重叠的颜色变得过饱和。\n不同类型的混合以及它们有怎样不同的效果相加混合（Additive blending）\n\n\n\n\n\n\n\nRGB颜色相加模型； 来源：Wikipedia\n\n\n\n相加混合是当我们添加不同颜色在一起的混合，这就是我们的视觉与光一起工作的模式，这就是我们如何在我们的显示器上感知数百万种不同的颜色——它们实际上只是将三种不同的原色混合在一起。\n这种混合在3D混合中很有用，例如在粒子效果中，它们似乎发出光线和覆盖物，例如灯光周围的光晕，或光剑周围的发光效果。\n相加混合能通过调用glBlendFunc(GL_ONE, GL_ONE)指定，混合的结果等式输出=（1 * 源片段） + （1 * 目标片段），运算后：输出=源片段 + 目标片段\n相乘混合（Multiplicative blending）\n\n\n\n\n\n\n\n光照贴图的一个例子\n\n\n\n相乘混合（也称为调制）是另一种有用的混合模式，它表示光在通过过滤器时的行为方式，或从被点燃的物体反射并进入我们的眼睛。一个红色的物体看上去是红色是因为白光照射到这个物体上，蓝光和绿光被吸收，只有红光反射回我们的眼睛。在上面的例子中，我们能看到一些红色和绿色，但是很少会有一点蓝色。\n当多纹理不可用时，乘法混合用于在游戏中实现光照贴图。纹理与光照贴图相乘，以填充在明亮和阴影的区域。\n相乘混合能通过调用glBlendFunc(GL_DST_COLOR, GL_ZERO)指定，其混合的结果等式输出=（目标片段 * 源片段）+ （0 * 目标片段），写作：输出=目标片段 * 源片段。\n插值混合（Interpolative blending）\n\n\n\n\n\n\n\n一个两个纹理一起插值的案例\n\n\n\n插值混合结合了乘法和加法，以提供插值效果。与添加和调制本身不同，此混合模式也可是依赖绘制顺序的。因此在某些情况下，如果您先画出最远的半透明物体，然后绘制更近的物体，结果才会是正确。即使排序也不是完美，因为三角形可能重叠并相交，但产生的伪像可能是可接受的。\n插值通常是将相邻的表面混合在一起，以及做有色玻璃或淡入淡出的效果。上面这个图片显示了两个纹理（纹理来自公共领域纹理）使用插值混合在一起。\n插值混合能通过调用glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)指定，其混合结果等式输出 = （源alpha * 源片段） + （（1 - 源alpha） * 目标片段）。这是一个例子：\n想象一下，我们正在绘制一个只有25%不透明的绿色（0，1，0），当前屏幕上的物体时红色（1，0，0）。\n123456输出 = （源因子 * 源片段） + （目标因子 * 目标片段）输出 = （源alpha * 源片段） + （（1 - 源alpha） * 目标片段）输出 = (0.25 * (0, 1, 0)) + (0.72 * (1, 0, 0))输出 = (0, 0.25, 0) + (0.75, 0, 0)输出 = (0.75, 0.25, 0)\n注意，我们不需要对目标alpha做任何涉及，因为这个帧缓冲区本身不需要alpha通道，这为我们提供了更多的颜色通道位。\n使用混合在我们的课程中，我们的Demo将使用相加混合将立方体显示为光的发射器。发光的东西不需要其他光源照亮，因此这个Demo中没有灯光。我也删除了纹理，虽然它可以很好地使用。本课程的着色器程序很简单；我们只需要一个可传递颜色的着色器。\n顶点着色器1234567891011uniform mat4 u_MVPMatrix;attribute vec4 a_Position;attribute vec4 a_Color;varying vec4 v_Color;void main()&#123;    v_Color = a_Color;    gl_Position = u_MVPMatrix * a_Position;&#125;\n片段着色器1234567precision mediump float;varying vec4 v_Color;void main()&#123;    gl_FragColor = v_Color;&#125;\n打开混合打开混合就像是做一些方法调用那么简单：\n12345678// 关闭剔除去掉背面GLES20.glDisable(GLES20.GL_CULL_FACE);// 关闭深度测试GLES20.glDisable(GLES20.GL_DEPTH_TEST);// 启动混合GLES20.glEnable(GLES20.GL_BLEND);GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE);\n我们关闭背面剔除，是因为如果立方体是半透明的，那么现在我们能看到立方体的背面。我们需要绘制它们，否则可能看起来会很奇怪。出于同样的原因我们关闭了深度测试。\n学习触摸事件并进行操作你将注意到，当您运行Demo时，可以通过点击屏幕来打开和关闭混合。\n现实触摸事件，您首先需要创建您的GLSurfaceView自定义view。在这个view中，创建一个默认构造用来调用父类，创建一个新的方法来接收特定的渲染器替换常用接口，并覆写onTouchEvent()。我们传入一个具体的渲染器类，因为我们将要在onTouchEvent()方法中调用这个类的特定方法。\n在Android中，OpenGL渲染器在独立的线程中完成，因此我们还将看看如何安全的从正在监听触摸事件的主线程调度到单独的渲染器线程。\n1234567891011121314151617181920212223242526272829303132public class LessonFiveGLSurfaceView extends GLSurfaceView &#123;    private LessonFiveRenderer mRenderer;    public LessonFiveGLSurfaceView(Context context) &#123;        super(context);    &#125;    @Override    public boolean onTouchEvent(MotionEvent event) &#123;        if (                event == null                || event.getAction() != MotionEvent.ACTION_DOWN                || mRenderer == null) &#123;            return super.onTouchEvent(event);        &#125;        // 确保我们在OpenGL线程上调用switchMode()        // queueEvent() 是GLSurfaceView的一个方法，它将为我们做到这点        queueEvent(new Runnable() &#123;            @Override            public void run() &#123;                mRenderer.switchMode();            &#125;        &#125;);        return true;    &#125;    public void setRenderer(LessonFiveRenderer renderer) &#123;        mRenderer = renderer;        super.setRenderer(renderer);    &#125;&#125;\n在LessonFiveRenderer中实现switchMode()\n123456789101112131415161718public void switchMode() &#123;    mBlending = !mBlending;    if (mBlending) &#123;        // 关闭剔除去掉背面        GLES20.glDisable(GLES20.GL_CULL_FACE);        // 关闭深度测试        GLES20.glDisable(GLES20.GL_DEPTH_TEST);        // 启动混合        GLES20.glEnable(GLES20.GL_BLEND);        GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE);    &#125; else &#123;        GLES20.glEnable(GLES20.GL_CULL_FACE);        GLES20.glEnable(GLES20.GL_DEPTH_TEST);        GLES20.glDisable(GLES20.GL_BLEND);    &#125;&#125;\n仔细看LessonFiveGLSurfaceView::onTouchEvent()，主要记住触摸事件都是在UI主线程中，而GLSurfaceView在一个单独的线程中创建OpenGL ES上下文，这意味着我们的渲染器的回调也在一个单独的线程中运行。这是一个需要记住的重点，因为我们不能再其他线程调用OpenGL并希望其工作。\n辛运的是，编写GLSurfaceView的人也想到了这点，并提供了一个queueEvent()方法，这使得你可以调用OpenGL线程上的东西。因此，当我们想通过点击屏幕打开和关闭混合时，我们确保通过在UI线程中使用queueEvent()来正确调用OpenGL线程中的内容。\n进一步练习这个Demo目前仅使用相加混合，尝试改变其为插值混合并重新添加灯光和纹理。如果您只在黑色背景上绘制两个半透明纹理，绘制顺序是否重要？什么时候重要？\n教程目录\nOpenGL Android课程一：入门\nOpenGL Android课程二：环境光和漫射光\nOpenGL Android课程三：使用每片段照明\nOpenGL Android课程四：介绍纹理基础\nOpenGL Android课程五：介绍混合（Blending）\nOpenGL Android课程六：介绍纹理过滤\nOpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）\n\n打包教材可以在Github下载本课程源代码：下载项目本课的编译版本也可以再Android市场下：google play 下载apk“我”也编译了个apk，方便大家下载：github download\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190219114206.jpg","plink":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five/"},{"title":"OpenGL Android课程四：介绍纹理基础","date":"2019-02-08T11:26:29.000Z","author":"xujiaji","updated":"2019-04-08T06:56:03.158Z","content":"\n翻译文\n\n原文标题：Android Lesson Four: Introducing Basic Texturing原文链接：http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/\n\n介绍纹理基础\n\n\n\n这是我们Android系列的第四个课程。在本课中，我们将添加我们在第三课中学到的内容，并学习如何添加纹理。我们来看看如何从应用资源中获取一张图片加载到OpenGLES中，并展示到屏幕上。跟着我一起来，你将马上明白纹理的基本使用方式。\n\n\n\n\n前提条件本系列每个课程构建都是以前一个课程为基础，这节课是第三课的扩展，因此请务必在继续之前复习该课程。\n\n已下是本系列课程的前几课：\n\n\nOpenGL Android课程一：入门\nOpenGL Android课程二：环境光和漫射光\nOpenGL Android课程三：使用每片段照明\n\n纹理基础纹理映射的艺术（以及照明）是构建逼真的3D世界最重要的部分。没有纹理映射，一切都是平滑的阴影，看起来很人工，就像是90年代的老式控制台游戏。\n第一个开始大量使用纹理的游戏，如Doom和Duke Nukem 3D，通过增加视觉冲击力，大大提升了游戏的真实感——如果在晚上玩可能会真的吓唬到我们。\n\n这里我们来看有纹理和没有纹理的场景\n\n\n\n\n\n每片段照明；正方形四个顶点中心位置\n添加了纹理；正方形四个顶点中心位置\n看左边的图片，这个场景通过每像素照明和着色点亮。这个场景看起来非常平滑，现实生活中我们走进一个房间有充满了光滑阴影的东西就像是这个立方体。在看右边的图片，同样的场景现在纹理化了。环境光也增加了，因为纹理的使用使整个场景变暗，也可以看到纹理对侧面立方体的影响。立方体具有和以前相同数量的多边形，但它们有新纹理看起来更加详细。满足于那些好奇的人，这个纹理的资源来自于公共领域的资源\n\n\n\n纹理坐标在OpengGL中，纹理坐标时常使用坐标(s,t)代替(x,y)。(s,t)表示纹理上的一个纹理元素，然后映射到多边形。另外需要注意这些纹理坐标和其他OpengGL坐标相似：t(或y)轴指向上方，所以值越高您走的越远。\n大多数计算机图形，y轴指向下方。这意味着左上角是图片的原点(0,0)，并且y值向下递增。换句话说，OpenGL的坐标系和大多数计算机图形相反，这是您需要考虑到的。\n\n\n\nOpenGL的纹理坐标系\n\n\n\n\n\n\n\n\n纹理映射基础在本课中，我们将来看看常规2D纹理（GL_TEXTURE_2D）和红，绿，蓝颜色信息（GL_RGB）。OpenGL ES 也提供其他纹理模式让你做更多不同的特殊效果。我们将使用GL_NEAREST查看点采样，GL_LINEAR和MIP-映射将在后面的课程中讲解。\n让我们一起来到代码部分，看看怎样开始在Android中使用基本的纹理。\n顶点着色器我们将采用上节课中的每像素照明着色器，并添加纹理支持。\n\n这儿是新的变化：\n\n12345678910attribute vec2 a_TexCoordinate;// 我们将要传入的每个顶点的纹理坐标信息...varying vec2 v_TexCoordinate;  // 这将会传入到片段着色器void main()&#123;   // 传入纹理坐标   v_TexCoordinate = a_TexCoordinate;   ...&#125;\n在顶点着色器中，我们添加一个新的属性类型vec2（一个包含两个元素的数组），将用来放入纹理坐标信息。这将是每个顶点都有，同位置，颜色，法线数据一样。我们也添加了一个新的变量，它将通过三角形表面上的线性插值将数据传入片段着色器。\n片段着色器123456789101112131415uniform sampler2D u_Texture;\" +  // 传入纹理...varying vec2 v_TexCoordinate;\" + // 插入的纹理坐标void main()&#123;   ...   // 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明   float diffuse = max(dot(v_Normal, lightVector), 0.1);\" +   // 根据距离哀减光线   diffuse = diffuse * (1.0 / (1.0 + (0.10 * distance * distance)));\" +   // 添加环境照明   diffuse = diffuse + 0.3;\" +   // 颜色乘以亮度哀减和纹理值得到最终的颜色   gl_FragColor = v_Color * diffuse * texture2D(u_Texture, v_TexCoordinate);\" +&#125;\n我们添加了一个新的常量类型sampler2D来表示实际纹理数据（与纹理坐标对应），由定点着色器插值传入纹理坐标，我们再调用texture2D(texture, textureCoordinate)得到纹理在当前坐标的值，我们得到这个值后再乘以其他项得到最终输出的颜色。\n这种方式添加纹理会使整个场景变暗，因此我们还会稍微增强环境光照并减少光照哀减。\n将一个图片加载到纹理12345678910111213141516171819202122232425262728293031public static int loadTexture(final Context context, final int resourceId) &#123;    final int[] textureHandle = new int[1];    GLES20.glGenTextures(1, textureHandle, 0);    if (textureHandle[0] != 0) &#123;        final BitmapFactory.Options options = new BitmapFactory.Options();        options.inScaled = false; // 没有预先缩放        // 得到图片资源        final Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), resourceId, options);        // 在OpenGL中绑定纹理        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[0]);        // 设置过滤        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);        // 将位图加载到已绑定的纹理中        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);        // 回收位图，因为它的数据已加载到OpenGL中        bitmap.recycle();    &#125;    if (textureHandle[0] == 0) &#123;        throw new RuntimeException(\"Error loading texture.\");    &#125;    return textureHandle[0];&#125;\n这段代码将Androidres文件夹中的图形文件读取并加载到OpenGL中，我会解释每一部分的作用。\n我们首先需要告诉OpenGL去为我们创建一个新的handle，这个handle作为一个唯一标识，我们想在OpenGL中引用纹理时就会使用它。\n12final int[] textureHandle = new int[1];GLES20.glGenTextures(1, textureHandle, 0);\n这个OpenGL方法可以用来同时生成多个handle，这里我们仅生成一个。\n因为我们这里只需要一个handle去加载纹理。首先，我们需要得到OpenGL能理解的纹理格式。我们不能只从PNG或JPG提供原始数据，因为它不会理解。我们需要做的第一步是将图像文件解码为Android Bitmap对象：\n1234final BitmapFactory.Options options = new BitmapFactory.Options();options.inScaled = false; // 没有预先缩放// 得到图片资源final Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), resourceId, options);\n默认情况下，Android会根据设备的分辨率和你放置图片的资源文件目录而预先缩放位图。我们不希望Android根据我们的情况对位图进行缩放，因此我们将inScaled设置为false\n123456// 在OpenGL中绑定纹理GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[0]);// 设置过滤GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);\n然后我们绑定纹理，并设置几个参数，绑定一个纹理，并告诉OpenGL后续OpenGL调用需要这样过滤这个纹理。我们将默认过滤器设置为GL_NEAREST，这是最快，也是最粗糙的过滤形式。它所做的就是在屏幕的每个点选择最近的纹素，这可能导致图像伪像和锯齿。\n\nGL_TEXTURE_MIN_FILTER 这是告诉OpenGL在绘制小于原始大小（以像素为单位）的纹理时要应用哪种类型的过滤。\nGL_TEXTURE_MAG_FILTER 这是告诉OpenGL在放大纹理到原始大小时要应用哪种类型的过滤。\n\n12345// 将位图加载到已绑定的纹理中GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);// 回收位图，因为它的数据已加载到OpenGL中bitmap.recycle();\n安卓有一个非常实用的功能可以直接将位图加载到OpenGL中。一旦您将资源读入Bitmap对象GLUtils.texImage2D()将负责其他事情，这个方法的签名：\n1public static void texImage2D (int target, int level, Bitmap bitmap, int border)\n我们想要一个常规的2D位图，因此我们传入GL_TEXTURE_2D作为第一个参数。第二个参数用于MIP-映射，并允许您指定要在哪个级别使用的图像。我们这里没有使用MIP-映射，因此我们将传入0设置为默认级别。我们传入位图，由于我们没有使用边框，所以我们传入0。\n然后原始位图对象调用recycle()，这提醒Android可以回收这部分内存。由于纹理已被加载到OpenGL，我们不需要继续保留这个副本。是的，Android应用程序在执行垃圾收集的Dalvik VM下运行，但Bitmap对象包含驻留在native内存中的数据，如果你不明确的回收它们，它们需要几个周期来进行垃圾收集。这意味着如果您忘记执行此操作，实际上可能会因内存不足错误而崩溃，即使您不再持有对位图的任何引用。\n将纹理应用到我们的场景首先，我们需要添加各种成员变量来持有我们纹理所需要的东西：\n1234567891011121314// 存放我们的模型数据在浮点缓冲区private final FloatBuffer mCubeTextureCoordinates;// 用来传入纹理private int mTextureUniformHandle;// 用来传入模型纹理坐标private int mTextureCoordinateHandle;// 每个数据元素的纹理坐标大小private final int mTextureCoordinateDataSize = 2;// 纹理数据private int mTextureDataHandle;\n我们基本上是需要添加新成员变量来跟踪我们添加到着色器的内容，以及保持对纹理的引用。\n定义纹理坐标我们在构造方法中定义我们的纹理坐标\n12345678910111213141516// S, T （或 X， Y）// 纹理坐标数据// 因为图像Y轴指向下方（向下移动图片时值会增加），OpenGL的Y轴指向上方// 我们通过翻转Y轴来调整它// 每个面的纹理坐标都是相同的final float[] cubeTextureCoordinateData =        &#123;                // 正面                0.0F, 0.0F,                0.0F, 1.0F,                1.0F, 0.0F,                0.0F, 1.0F,                1.0F, 1.1F,                1.0F, 0.0F,        &#125;;...\n这坐标数据看起来可能有点混乱。如果您返回去看第三课中点的位置是如何定义的，您将会发现我们为正方体每个面都定义了两个三角形。点的定义方式像下面这样：\n12345678（三角形1）左上，左下，右上（三角形2）左下，右下，右上\n纹理坐标和正面的位置坐标对应，但是由于Y轴翻转，Y轴指向和OpenGL的Y轴相反的方向。\n\n看下图，实线坐标表示在OpenGL中正方体正面X，Y坐标。虚线表示翻转后的坐标，可以看出和上面定义的纹理坐标是一一对应的\n\n\n设置纹理我们在onSurfaceCreated()方法中加载纹理\n1234567@Overridepublic void onSurfaceCreated(GL10 gl, EGLConfig config) &#123;    ...    mProgramHandle = ShaderHelper.createAndLinkProgram(vertexShaderHandle, fragmentShaderHandle, \"a_Position\", \"a_Color\", \"a_Normal\", \"a_TexCoordinate\");    ...    // 加载纹理    mTextureDataHandle = TextureHelper.loadTexture(mActivityContext, R.drawable.bumpy_bricks_public_domain);\n我们传入一个新的属性a_TexCoordinate绑定到我们的着色器中，并且我们通过之前创建的loadTexture()方法加载着色器。\n使用纹理我们也需要在onDrawFrame(GL10 gl)方法中添加一些代码。\n1234567891011121314@Overridepublic void onDrawFrame(GL10 gl) &#123;    ...    mTextureUniformHandle = GLES20.glGetUniformLocation(mProgramHandle, \"u_Texture\");    mTextureCoordinateHandle = GLES20.glGetAttribLocation(mProgramHandle, \"a_TexCoordinate\");    // 将纹理单元设置为纹理单元0    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);    // 将纹理绑定到这个单元    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureDataHandle);    // 通过绑定到纹理单元0，告诉纹理标准采样器在着色器中使用此纹理    GLES20.glUniform1i(mTextureUniformHandle, 0);\n我们得到着色器中的纹理数据和纹理坐标句柄。在OpenGL中，纹理能在着色之前，需要绑定到纹理单元。纹理单元是读取纹理并实际将它传入着色器的中，因此可以再屏幕上显示。不同的图形芯片有不同数量的纹理单元，因此在使用它们之前，您需要检查是否存在其他纹理单元。\n首先，我们告诉OpenGL我们想设置使用的纹理单元到第一个单元，纹理单元0。然后自动绑定纹理到第一个单元，通过调用glBindTexture()。最后，我们告诉OpenGL，我们想将mTextureUniformHandle绑定到第一个纹理单元，它引用了片段着色器中u_Texture属性。\n简而言之：\n\n设置纹理单元\n绑定纹理到这个单元\n将此单元指定给片段着色器中的纹理标准\n\n根据需要重复多个纹理。\n进一步练习一旦您做到这儿，您就完成的差不多了！当然这这并没有您预期的那么糟糕…或者确实糟糕？😉作为下一个练习，尝试通过加载另一个纹理，将其绑定到另一个单元，并在着色器中使用它。\n回顾现在我们回顾一下所有的着色器代码，以及我们添加了一个新的帮助功能用来从资源目录读取着色器代码，而不是存储在java字符串中：\n顶点着色器 all12345678910111213141516171819202122232425262728uniform mat4 u_MVPMatrix;                      // 一个表示组合model、view、projection矩阵的常量uniform mat4 u_MVMatrix;                       // 一个表示组合model、view矩阵的常量attribute vec4 a_Position;                     // 我们将要传入的每个顶点的位置信息attribute vec4 a_Color;                        // 我们将要传入的每个顶点的颜色信息attribute vec3 a_Normal;                       // 我们将要传入的每个顶点的法线信息attribute vec2 a_TexCoordinate;                // 我们将要传入的每个顶点的纹理坐标信息varying vec3 v_Position;varying vec4 v_Color;varying vec3 v_Normal;varying vec2 v_TexCoordinate;                  // 这将会传入到片段着色器// 顶点着色器入口点void main()&#123;   // 传入纹理坐标   v_TexCoordinate = a_TexCoordinate;   // 将顶点位置转换成眼睛空间的位置   v_Position = vec3(u_MVMatrix * a_Position);   // 传入颜色   v_Color = a_Color;   // 将法线的方向转换在眼睛空间   v_Normal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));   // gl_Position是一个特殊的变量用来存储最终的位置   // 将顶点乘以矩阵得到标准化屏幕坐标的最终点   gl_Position = u_MVPMatrix * a_Position;&#125;\n片段着色器 all12345678910111213141516171819202122precision mediump float; //我们将默认精度设置为中等，我们不需要片段着色器中的高精度uniform sampler2D u_Texture;  // 传入纹理uniform vec3 u_LightPos; // 光源在眼睛空间的位置varying vec3 v_Position; // 插入的位置varying vec4 v_Color; // 插入的位置颜色varying vec3 v_Normal; // 插入的位置法线varying vec2 v_TexCoordinate; // 插入的纹理坐标void main()  // 片段着色器入口&#123;   // 将用于哀减   float distance = length(u_LightPos - v_Position);   // 获取从光源到顶点方向的光线向量   vec3 lightVector = normalize(u_LightPos - v_Position);   // 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明   float diffuse = max(dot(v_Normal, lightVector), 0.1);   // 根据距离哀减光线   diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));   // 添加环境照明   diffuse = diffuse + 0.3;   // 颜色乘以亮度哀减和纹理值得到最终的颜色   gl_FragColor = v_Color * diffuse * texture2D(u_Texture, v_TexCoordinate);&#125;\n怎样从raw资源目录中读取文本？123456789101112131415161718192021222324252627public class RawResourceReader &#123;    public static String readTextFileFromRawResource(final Context context, final int resurceId) &#123;        final InputStream inputStream = context.getResources().openRawResource(resurceId);        final InputStreamReader inputStreamReader = new InputStreamReader(inputStream);        final BufferedReader bufferedReader = new BufferedReader(inputStreamReader);        String nextLine;        final StringBuilder body = new StringBuilder();        try &#123;            while ((nextLine = bufferedReader.readLine()) != null) &#123;                body.append(nextLine).append('\\n');            &#125;        &#125; catch (IOException e) &#123;            return null;        &#125; finally &#123;            try &#123;                bufferedReader.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        return body.toString();    &#125;&#125;\n教程目录\nOpenGL Android课程一：入门\nOpenGL Android课程二：环境光和漫射光\nOpenGL Android课程三：使用每片段照明\nOpenGL Android课程四：介绍纹理基础\nOpenGL Android课程五：介绍混合（Blending）\nOpenGL Android课程六：介绍纹理过滤\nOpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）\n\n打包教材可以在Github下载本课程源代码：下载项目本课的编译版本也可以再Android市场下：google play 下载apk“我”也编译了个apk，方便大家下载：github download\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/20190211205340.jpg","plink":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four/"},{"title":"OpenGL Android课程三：使用每片段照明","date":"2019-01-26T09:55:49.000Z","author":"xujiaji","updated":"2019-04-08T08:32:50.360Z","content":"\n翻译文\n\n原文标题：Android Lesson Three: Moving to Per-Fragment Lighting原文链接：http://www.learnopengles.com/android-lesson-three-moving-to-per-fragment-lighting/\n\n使用每片段照明\n\n\n\n欢迎来到第三课！这节课，我们将会在第二课的基础上，学习如何使用每像素技术来达到相同的照明。简单的正方体即使使用标准的漫射照明我们也能看到差异。\n\n\n\n\n前提条件本系列的每节课都以前面的课程为基础，本节课是第二课的补充，因此请务在阅读了之前的课程后再来回顾。\n\n下面是本系列课程的前几课：\n\n\nOpenGL Android课程一：入门\nOpenGL Android课程二：环境光和漫射光\n\n什么是每像素照明随着着色器的使用，每像素照明在游戏中是一种相对较新的现象。许多有名的旧游戏，例如原版的半条命，都是在着色器之前开发出来的，主要使用静态照明，通过一些技巧模拟动态照明，使用每顶点（也称为Gouraud阴影）照明或其他技术，如动态光照贴图。\n光照贴图可以提供非常好的效果，有时可以比单独的着色器提供更好的效果，因为可以预先计算昂贵的光线计算。但缺点是它们占用了大量内存并使用它们进行动态照明仅限于简单的计算。\n使用着色器，现在很多这些计算转给GPU，这可以完成更多实时的效果。\n从每顶点照明转移到每片段照明这本课中，我们将针对每顶点解决方案和每片段解决方案查看相同的照明代码。尽管我将这种类型称为每像素，但在OpenGL ES中我们实际上使用片段，并且几个片段可以贡献一个像素的最终值。\n手机的GPU变得越来越快，但是性能仍然是一个问题。对于“软”照明例如地形，每顶点照明可能足够好。确保您在质量和速度之间取得适当的平衡。\n在某些情况下可以看到两种类型的照明之间的显著差异。看看下面的屏幕截图：\n\n\n\n\n每顶点照明；在正方形四个顶点为中心\n每片段照明；在正方形四个顶点为中心\n在左图的每顶点照明中正方体的正面看起来像是平面阴影，不能表明附近有光源。这是因为正面的四个顶点和光源距离差不多相等，并且四个点的低光强度被简单的插入两个三角形构成的正面。相对比，每片段照明很好的显示了亮点特性\n\n\n每顶点照明；在正方形角落\n每片段照明；在正方形角落\n左图显示了一个Gouraud阴影立方体。当光源移动到立方体正面角落时，可以看到类似三角形的效果。这是因为正面实际上是由两个三角形组成，并且在每个三角形不同方向插值，我们能看到构成立方体的基础几何图形。每片段的版本显示上没有此类插值的问题并且它在边缘附近显示了一个漂亮的圆形高光。\n\n\n\n每顶点照明概述我们来看看第二课讲的着色器；在该课程中可以找到详细的着色器说明。\n顶点着色器123456789101112131415161718192021222324252627282930uniform mat4 u_MVPMatrix;      // 一个表示组合model、view、projection矩阵的常量uniform mat4 u_MVMatrix;       // 一个表示组合model、view矩阵的常量uniform vec3 u_LightPos;       // 光源在眼睛空间的位置attribute vec4 a_Position;     // 我们将要传入的每个顶点的位置信息attribute vec4 a_Color;        // 我们将要传入的每个顶点的颜色信息attribute vec3 a_Normal;       // 我们将要传入的每个顶点的法线信息varying vec4 v_Color;          // 这将被传入片段着色器void main()                    // 顶点着色器入口&#123;// 将顶点转换成眼睛空间   vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);// 将法线的方向转换成眼睛空间   vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));// 将用于哀减   float distance = length(u_LightPos - modelViewVertex);// 获取从光源到顶点方向的光线向量   vec3 lightVector = normalize(u_LightPos - modelViewVertex);// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明   float diffuse = max(dot(modelViewNormal, lightVector), 0.1);// 根据距离哀减光线   diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));// 将颜色乘以亮度，它将被插入三角形中   v_Color = a_Color * diffuse;// gl_Position是一个特殊的变量用来存储最终的位置// 将顶点乘以矩阵得到标准化屏幕坐标的最终点   gl_Position = u_MVPMatrix * a_Position;&#125;\n片段着色器123456precision mediump float;     // 我们将默认精度设置为中等，我们不需要片段着色器中的高精度varying vec4 v_Color;        // 这是从三角形每个片段内插的顶点着色器的颜色void main()                  // 片段着色器入口&#123;    gl_FragColor = v_Color;   // 直接将颜色传递&#125;\n正如您所见，大部分工作都在我们的着色器中做的。转移到每片段着色照明意味着，我们的片段着色器还有更多的工作要做。\n实现每片段照明以下是移动到每片段照明后的代码的样子。\n顶点着色器 new123456789101112131415161718192021222324uniform mat4 u_MVPMatrix;    // 一个表示组合model、view、projection矩阵的常量uniform mat4 u_MVMatrix;     // 一个表示组合model、view矩阵的常量attribute vec4 a_Position;   // 我们将要传入的每个顶点的位置信息attribute vec4 a_Color;      // 我们将要传入的每个顶点的颜色信息attribute vec3 a_Normal;     // 我们将要传入的每个顶点的法线信息varying vec3 v_Position;varying vec4 v_Color;varying vec3 v_Normal;// 顶点着色器入口点void main()&#123;   // 将顶点位置转换成眼睛空间的位置   v_Position = vec3(u_MVMatrix * a_Position);   // 传入颜色   v_Color = a_Color;   // 将法线的方向转换在眼睛空间   v_Normal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));   // gl_Position是一个特殊的变量用来存储最终的位置   // 将顶点乘以矩阵得到标准化屏幕坐标的最终点   gl_Position = u_MVPMatrix * a_Position;&#125;\n顶点着色器比之前更加的简单。我们添加了两个线性插值变量用来传入到片段着色器：顶点位置和顶点法线。它们将在片段着色器计算光亮的时候被使用。\n片段着色器 new123456789101112131415161718precision mediump float; //我们将默认精度设置为中等，我们不需要片段着色器中的高精度uniform vec3 u_LightPos; // 光源在眼睛空间的位置varying vec3 v_Position; // 插入的位置varying vec4 v_Color;    // 插入的位置颜色varying vec3 v_Normal;   // 插入的位置法线void main()              // 片段着色器入口&#123;   // 将用于哀减   float distance = length(u_LightPos - v_Position);   // 获取从光源到顶点方向的光线向量   vec3 lightVector = normalize(u_LightPos - v_Position);   // 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明   float diffuse = max(dot(v_Normal, lightVector), 0.1);   // 根据距离哀减光线   diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));   // 颜色乘以亮度哀减得到最终的颜色   gl_FragColor = v_Color * diffuse;&#125;\n使用每片段照明，我们的片段着色器还有更多的工作要做。我们基本上将朗伯计算和哀减移到了每像素级别，这为我们提供了更逼真的照明，而无需添加更多顶点。\n进一步练习我们可以在顶点着色器中计算距离，然后赋值给变量通过线性插值传入片段着色器吗？\n教程目录\nOpenGL Android课程一：入门\nOpenGL Android课程二：环境光和漫射光\nOpenGL Android课程三：使用每片段照明\nOpenGL Android课程四：介绍纹理基础\nOpenGL Android课程五：介绍混合（Blending）\nOpenGL Android课程六：介绍纹理过滤\nOpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）\n\n打包教材可以在Github下载本课程源代码：下载项目本课的编译版本也可以再Android市场下：google play 下载apk“我”也编译了个apk，方便大家下载：github download\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/Screenshot_2019-02-07-13-45-15-213_com.xujiaji.le.png","plink":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three/"},{"title":"OpenGL Android课程二：环境光和漫射光","date":"2019-01-23T07:50:51.000Z","author":"xujiaji","updated":"2019-04-08T06:56:23.990Z","content":"\n翻译文\n\n原文标题：OpenGL Android Lesson One: Getting Started原文链接：http://www.learnopengles.com/android-lesson-two-ambient-and-diffuse-lighting/\n\n环境光和漫射光\n\n\n\n欢迎来到第二课，我们将学习如何使用着色器实现朗伯反射（ Lambertian reflectance ），也称为标准漫射照明。在OpengGLES2，我们需要实现我们自己的照明算法，因此我们要学会数学如何工作以及如何应用到我们的场景中。\n\n\n\n\n阅读本文前提条件本系列的每节课都以前面的课程为基础。在开始前，请看第一课，因为本课程将以此为基础概念介绍。\n什么是光没错！一个没有光的世界是昏暗的。没有[光]，我们甚至不能感知世界或我们周围的物体，除了声音和触摸等其他感官。光向我们展示了物体是明亮还是昏暗，是远还是近，它的角度是什么。\n在现实世界，我们所感知的光实际是数万亿微小粒子的聚集，称为光子。它从光源飞出，反弹数千或数百万次，最终到达我们的眼镜我们称之为光。\n我们如何通过计算机图形模拟光的影响？有两种流行的方法：光线追踪和光栅化光线跟踪的工作原理是通过数学计算跟踪实际光线并查看它们的最终位置。该技术可以得到非常精准和逼真的结果，但缺点是模拟所有这些光线的计算成本非常高，并且通常对于实时渲染来说太慢了。由于这个限制，大多数实时图形计算使用光栅化，它通过近似值模拟光照。鉴于当前游戏的真实性，光栅化看起来非常好，即使在手机上也可以快速实现实时图形。OpengGL ES主要是一个光栅化库，因此我们主要关注这个。\n不同种类的光事实证明，我们可以抽象出光的工作方式，并提出三种基本的光照方式\n\n\n\n\n环境光\n环境光这是基本的照明水平，似乎遍布整个场景。它似乎不是来自任何光源的光，因为它在到达你之前已经反弹了很多次。这种类型的光在户外的阴天可以体验，或者在户内作为许多不同光源的积累影响。我们可以为物体或场景设置一个基本的亮度，而不是为所有的光单独计算。\n\n\n环境照明和漫射照明的例子\n漫射照明这是直接从一个物体上跳弹后到达您眼睛中的光，物体的亮度随着它与照明的角度而变化，面向灯光的方向比其他角度更加明亮此外，无论我们相对于物体的角度怎样，我们都觉得物体是相同的亮度，这也被称为Lambert的余弦定律。漫射照明或朗伯反射率在日常生活中很常见，您可以在室内灯光照明的白墙上轻松看到。\n\n\n镜面高光的一个例子\n镜面照明与漫射照明不同，当我们相对于物体移动时，镜面光照也会发生改变。这给物体带来“光泽”，并且可以在“更光滑”的表面上看到，例如玻璃和其他有光泽的物体。\n\n\n\n模拟光正如3D场景中的3中主要类型的光照一样，还有三种主要类型的光源：定向光源，点光源，聚光灯，这些也可以在日常生活中轻松看到。\n\n\n\n\n一个明亮的风景\n定向光源定向光照通常来自于一个很远的光源，它可以均匀的照亮整个场景达到相同的亮度。这种光源是最简单的类型，无论您处在场景哪里，光照都具有相同的强度和方向。\n\n\n一个点光源的例子\n点光源点光源可以添加到场景中，以提供更多样化和逼真的照明。点光的照射随着距离而下降，并且它的光线在所有方向上向外传播，光源位于中心。\n\n\n聚光灯\n聚光灯除了具有点光源的特性外，聚光灯也有光哀减的方向，通常呈锥形。\n\n\n\n数学本节课，我们来看看来自一个点光源的环境照明和漫射照明。\n环境照明环境照明其实是间接漫射照明，但它也可以被认为是遍布整个场景的低级光。如果我们这么想，那么它将非常好计算：\n12// 最终颜色 = 材质颜色 * 环境光颜色final color = material color * ambient light color\n例如，我们有个红色的物体和一个暗白色的环境照明。我们假设三个颜色（红，绿，蓝）的数组存储颜色，使用RGB颜色模型：\n12// 最终颜色 = 红色 * 暗白色 = 暗红色final color = &#123;1, 0, 0&#125; * &#123;0.1, 0.1, 0.1&#125; = &#123;0.1, 0.0, 0.0&#125;\n物体的最终颜色将是暗红色，如果您有一个被昏暗的白光照明的红色物体，那么这就是您的预期。基本的环境光真的没有比这更多的了，除非您想加入更先进的照明技术，如光能传递。\n漫射照明-点光源对于漫射照明，我们需要添加哀减和光源位置。光源位置将用来计算光线和表面的角度，它将影响表面的整体光照水平。它还将用于计算光源到表面的距离，这决定了光在这个点上的强度。\n第一步：计算朗伯因子（lambert factor）我们最重要的是需要弄清楚表面和光线之间的角度。面向光直射的表面因该全强度照射，而倾斜的表面因该得到较少的照射，比较合适的计算方式是使用Lambert的余弦定律。果我们有两个向量，一个是从光到表面上的一个点，第二个是表面的法线（如果表面是平面，则表面法线是指向上或垂直于该表面的矢量），然后我们可以通过对每个向量进行归一化来计算余弦，使其长度为1，然后通过计算两个向量的点积（数量积）。这个操作可以由OpenGL ES 2轻松完成。\n我们称这位朗伯因子，它的取值范围在0~1之间\n123456// 光线向量 = 光源位置 - 物体位置light vector = light position - object position// 余弦 = 物体法线和归一化后的光线向量的点积cosine = dot product(object normal, normalize(light vector))// 朗伯因子 = 取余弦和0中最大的lambert factor = max(cosine, 0)\n首先我们通过光源位置减去物体位置得到光线向量，然后我们通过物体法线和光向量的点积得到余弦。我们标准化光向量，这意味着改变它的长度，长度为1，这个物体的法线长度也是1，两个归一化向量的点积得到他们之间的余弦。因为点积的取值范围是-1~1，所以我们将其限制到0~1。\n这儿有个处在原点的平面，其表面法线指向天空的例子。\n\n光的位置在{0, 10, -10}，我们想要计算在原点的光。\n\n1234// 光线向量light vector = &#123;0, 10, -10&#125; - &#123;0, 0, 0&#125; = &#123;0, 10, -10&#125;// 物体法线object normal = &#123;0, 1, 0&#125;\n\n简洁的说，如果们沿着光线矢量走，我们到达光源的位置。为了归一化矢量，我们将每个分量除以矢量长度：\n\n1234// 光线向量长度 = 平方根(0*0 + 10*10 + (-10 * -10)) = 平方根(200) = 14.14light vector length = square root(0*0 + 10*10 + (-10 * -10)) = square root(200) = 14.14// 归一化光线向量normalize light vector = &#123;0, 10/14.14, -10/14.14&#125; = &#123;0, 0.707, -0.707&#125;\n\n然后我们计算点积：\n\n12// 点积dot product(&#123;0, 1, 0&#125;, &#123;0, 0.707, -0.707&#125;) = (0 * 0) + (1 * 0.707) + (0 * -0.707) = 0.707\n这里有个一对点积计算很好的解释\n\n最后我们限制范围：\n\n12// 朗伯因子lambert factor = max(0.707, 0) = 0.707\nOpenGL ES 2的着色器语言内置了对其中一些函数的支持，因此我们不需要手动完成所有数学运算，但它仍然有助于理解正在发生的事情。\n第二步：计算哀减系数接下来，我们需要计算哀减。来自光源的实际光哀减遵循反平方定律\n\n也可以这样表示：\n\n12// 亮度 = 1 / 距离的平方luminosity = 1 / (distance * distance)\n\n回到我们的列子，因为我们有光线长度为14.14，这儿我们最终的亮度：\n\n1luminosity = 1 / (14.14 * 14.14) = 1 / 200 = 0.005\n正如您所见，反平方定律会导致距离的强烈哀减。这就是点光源的光在现实世界中的作用，但是由于我们图形展示范围有限，控制这个哀减系数是非常有用的，因此我们仍然能获得逼真的照明而不会让其看起来很昏暗。\n第三步：计算最终颜色\n现在我们知道了余弦和哀减度，我们可以计算我们最终的亮度：\n\n12// 最终颜色 = 材质颜色 * （光的颜色 * 朗伯因子 * 亮度）final color = material color * (light color * lambert factor * luminosity)\n\n继续我们之前的红色物体和白光源的例子，这儿计算最终颜色：\n\n1final color = &#123;1, 0, 0&#125; * (&#123;1, 1, 1&#125; * 0.707 * 0.005) = &#123;1, 0, 0&#125; * &#123;0.0035, 0.0035, 0.0035&#125; = &#123;0.0035, 0, 0&#125;\n回顾一下，对于漫射照明，我们需要使用表面和光线之间的角度以及距离，用来计算最终的整体漫射亮度。\n\n以下是步骤：\n\n12345678910// 第一步light vector = light position - object positioncosine = dot product(object normal, normalize(light vector))lambert factor = mac(cosine, 0)// 第二步luminosity = 1 / (distance * distance)// 第三步final color = material color * (light color * lambert factor * luminosity)\n将这一切放到OpenGL ES 2着色器中顶点着色器12345678910111213141516171819202122232425262728293031final String vertexShader =        \"uniform mat4 u_MVPMatrix;      \\n\" + // 一个表示组合model、view、projection矩阵的常量        \"uniform mat4 u_MVMatrix;       \\n\" + // 一个表示组合model、view矩阵的常量        \"uniform vec3 u_LightPos;       \\n\" + // 光源在眼睛空间（相对于相机视角）的位置        \"attribute vec4 a_Position;     \\n\" + // 我们将要传入的每个顶点的位置信息        \"attribute vec4 a_Color;        \\n\" + // 我们将要传入的每个顶点的颜色信息        \"attribute vec3 a_Normal;       \\n\" + // 我们将要传入的每个顶点的法线信息        \"varying vec4 v_Color;          \\n\" + // 这将被传入片段着色器        \"void main()                    \\n\" + // 顶点着色器入口        \"&#123;                              \\n\" +        // 将顶点转换成眼睛空间（相对于相机视角）        \"   vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);                \\n\" +        // 将法线的方向转换成眼睛空间（相对于相机视角）        \"   vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));       \\n\" +        // 将用于哀减        \"   float distance = length(u_LightPos - modelViewVertex);               \\n\" +        // 获取从光源到顶点方向的光线向量        \"   vec3 lightVector = normalize(u_LightPos - modelViewVertex);          \\n\" +        // 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明        \"   float diffuse = max(dot(modelViewNormal, lightVector), 0.1);         \\n\" +        // 根据距离哀减光线        \"   diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));    \\n\" +        // 将颜色乘以亮度，它将被插入三角形中        \"   v_Color = a_Color * diffuse;                                         \\n\" +        // gl_Position是一个特殊的变量用来存储最终的位置        // 将顶点乘以矩阵得到标准化屏幕坐标的最终点        \"   gl_Position = u_MVPMatrix * a_Position;                              \\n\" +        \"&#125;                                                                       \\n\";\n这里有相当多的事情要做。我们在第一课讲到过我们要有一个model/view/projection的组合矩阵，但是我们还要添加了一个model/view矩阵。为什么？因为我们将需要这个矩阵去计算光源位置到当前顶点位置之间的距离。对于漫射照明，无论您使用世界空间（model矩阵）或眼睛空间（model/view矩阵）只要你能计算出合适的距离和角度实际上都没有问题。\n我们传入顶点的颜色和位置信息，以及它的法线。我们会将最终的颜色传入片段着色器，它将在顶点之间插值，这也被称为Gouraud着色法。\n让我们来看看着色器每一部分的意义：\n12// 将顶点转换成眼睛空间（相对于相机视角）\"   vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);                \\n\"\n因为我们是在眼睛空间观察光源位置，我们转换当前的顶点位置到眼睛空间的坐标系中，因此我们能计算出对应的距离和角度。\n\n12// 将法线的方向转换成眼睛空间（相对于相机视角）\"   vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));       \\n\" +\n我们也需要转换法线的方向。这里我们只是想上面位置一样做了个常规乘法，但是如果model或view矩阵做过旋转或倾斜，那么将不能工作：我们实际上需要通过将法线乘以原始矩阵的反转来消除倾斜或缩放的影响。这个网站很好的解释了为什么我们必须这么做\n\n12// 将用于哀减\"   float distance = length(u_LightPos - modelViewVertex);               \\n\"\n如前面数学部分所示，我们需要这个距离去计算哀减系数\n\n12// 获取从光源到顶点方向的光线向量\"   vec3 lightVector = normalize(u_LightPos - modelViewVertex);          \\n\"\n我们也需要光线向量去计算朗伯反射因子\n\n12// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明\"   float diffuse = max(dot(modelViewNormal, lightVector), 0.1);         \\n\"\n这与上面的数学部分相同，只是在OpenGL ES 2着色器中完成。后面的0.1是一种非常便宜的环境照明方式（最小值将被限制在0.1）。\n\n12// 根据距离哀减光线\"   diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));    \\n\"\n这里和上面的数学部分略有不同。我们将距离的平方缩放0.25以抑制衰减的效应，并且我们还将修改的距离加1，这样当光源非常接近物体时我们就不会过饱和（否则，当距离小于1时，该等式实际上回照亮光源而不是哀减它）。\n\n12345// 将颜色乘以亮度，它将被插入三角形中\"   v_Color = a_Color * diffuse;                                         \\n\" +// gl_Position是一个特殊的变量用来存储最终的位置// 将顶点乘以矩阵得到标准化屏幕坐标的最终点\"   gl_Position = u_MVPMatrix * a_Position;                              \\n\"\n当我们有了最终的光色，我们将它乘以顶点的颜色得到最终输出的颜色，然后我们将这个顶点的位置投影到屏幕上。\n像素着色器1234567final String fragmentShader =        \"precision mediump float;       \\n\" + // 我们将默认精度设置为中等，我们不需要片段着色器中的高精度                \"varying vec4 v_Color;          \\n\" + // 这是从三角形每个片段内插的顶点着色器的颜色                \"void main()                    \\n\" + // 片段着色器入口                \"&#123;                              \\n\" +                \"   gl_FragColor = v_Color;     \\n\" + // 直接将颜色传递                \"&#125;                              \\n\";\n因为我们是在每个顶点的基础上计算光，我们的片段着色器和上节课一样，我们所做的是将颜色直接传过去。在下节课中，我们将学习每像素照明。\n每顶点照明和每像素照明这节课我们的关注点在实现每顶点照明。对于具有光滑表面的物体（如地形），或具有许多三角形的物体的漫反射，这通常是足够了。然而，当您的物体没有包含许多顶点时（例如我们的在这个案例中的正方体），或者有尖角，顶点光照可能会导致伪影，因为亮度在多边形上线性插值；当镜面高光添加到图像时，这些伪影也会变得更加明显。更多关于Gouraud着色法的Wiki文章\n正方体的构造在第一课中，我们将位置和颜色属性打包到一个数组中，但是OpengGL ES 2也允许让我们将属性单独存放：\n1234567891011121314151617181920212223242526//X, Y, Zfinal float[] cubePositionData = &#123;        // 在OpenGL，逆时针绕组（下面的点事逆时针顺序）是默认的。        // 这意味着当我们在观察一个三角形时，如果这些电视逆时针的，那么我们正在看\"前面\"，如果不是我们则正在看背面        // OpenGL有一个优化，所有背面的三角形都会被剔除，因为它们通常代表一个物体的背面，无论如何都不可见        // 正面        -1.0F, 1.0F, 1.0F,        -1.0F, -1.0F, 1.0F,        1.0F, 1.0F, 1.0F,        -1.0F, -1.0F, 1.0F,        1.0F, -1.0F, 1.0F,        1.0F, 1.0F, 1.0F,        ...&#125;;// R，G，B，Afinal float[] cubeColorData = &#123;        // 正面红色        1.0F, 0.0F, 0.0F, 1.0F,        1.0F, 0.0F, 0.0F, 1.0F,        1.0F, 0.0F, 0.0F, 1.0F,        1.0F, 0.0F, 0.0F, 1.0F,        1.0F, 0.0F, 0.0F, 1.0F,        1.0F, 0.0F, 0.0F, 1.0F,        ...&#125;;\n新的OpenGL flag我们还使用了glEnable()调用启用了剔除和深度缓冲：\n1234// 使用剔除去掉背面GLES20.glEnable(GLES20.GL_CULL_FACE);// 启用深度测试GLES20.glEnable(GLES20.GL_DEPTH_TEST);\n作为优化，您可以告诉OpenGL剔除物体背面的三角形。当我们定义正方体时，我们还定义了每个三角形的三个点，以便当我们在查看正面的时候是逆时针的。当我们翻转三角形以便我们到背面时，这些点将会顺时针展示。您只能同时看到一个正方体的三个面，所以这个优化告诉OpenGL不要浪费时间去绘制背面的三角形。\n之后当我们绘制透明的物体时，我们希望关闭剔除，然后物体背面将会变得可见。\n我们还开启了深度测试。如果你总是从后面向前面绘制物体，那么深度测试绝非必要，但是通过启用它您不仅不需要担心绘制顺序（尽管如果你先画最近的物体渲染会更快），一些显卡也将进行优化，通过花费更少的时间绘制像素来加速渲染。\n加载着色器程序的修改因为在OpenGL中加载着色器程序的步骤大致相同，这些步骤可以很容易的重构为一个单独的方法。我们还添加了以下调用来检索调试信息，以防编译/链接失败：\n12GLES20.glGetProgramInfoLog(programHandle);GLES20.glGetShaderInfoLog(shaderHandle);\n光点的顶点和着色程序这个新的顶点和着色器程序绘制在屏幕上代表当前光源的位置：\n123456789101112131415// 定义一个简单的着色程序final String pointVertexShader =        \"uniform mat4 u_MVPMatrix;                  \\n\" +        \"attribute vec4 a_Position;                 \\n\" +        \"void main()                                \\n\" +        \"&#123;                                          \\n\" +        \"   gl_Position = u_MVPMatrix * a_Position; \\n\" +        \"   gl_PointSize = 5.0;                     \\n\" +        \"&#125;                                          \\n\";final String pointFragmentShader =        \"precision mediump float;                   \\n\" +        \"void main()                                \\n\" +        \"&#123;                                          \\n\" +        \"   gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0) \\n\" +        \"&#125;                                          \\n\";\n这个着色器类似于第一课的简单着色器，这里有个新的成员gl_PointSize，直接固定它的值为5.0，这是点的像素尺寸。当我们使用GLES20.GL_POINTS模式绘制这个点的时候它会被使用。我们也直接设置了它的显示颜色为白色。\n进一步练习\n尝试删除“过渡饱和”看会发生什么\n这里的照明方式存在缺陷，你能发现是什么吗？提示：我们做环境照明的方式的缺点是什么，以及alpha会放生什么？\n如果将gl_PointSize添加到正方体着色器并使用GL_POINTS绘制它会发生什么？\n\n进一步阅读\nClockworkcoders教程：每片段照明\nLighthouse3d.com：法线矩阵\narcsynthesis.org: OpenGL教程：法线转换\nOpenGL编程指南：5章 照明\n\n在编写本教程时，上面的进一步阅读部分对我来说是非常宝贵的资源，因此我强烈建议您阅读它们以获得更多的信息和解释。\n教程目录\nOpenGL Android课程一：入门\nOpenGL Android课程二：环境光和漫射光\nOpenGL Android课程三：使用每片段照明\nOpenGL Android课程四：介绍纹理基础\nOpenGL Android课程五：介绍混合（Blending）\nOpenGL Android课程六：介绍纹理过滤\nOpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）\n\n打包教材可以在Github下载本课程源代码：下载项目本课的编译版本也可以再Android市场下：google play 下载apk“我”也编译了个apk，方便大家下载：github download\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/5C1BB79E-9092-4559-B6A6-D3288D0FA000.png","plink":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two/"},{"title":"OpenGL Android课程一：入门","date":"2019-01-21T08:10:46.000Z","author":"xujiaji","updated":"2019-04-08T06:56:07.337Z","content":"\n翻译文\n\n原文标题：OpenGL Android Lesson One: Getting Started原文链接：http://www.learnopengles.com/android-lesson-one-getting-started/\n\n这是在Android中使用OpenGL ES2的第一个教程。这一课中，我们将一步一步跟随代码，学习如何创建一个OpenGL ES 2并绘制到屏幕上。我们还将了解什么是着色器，它们如何工作，以及怎样使用矩阵将场景转换为您在屏幕上看到的图像。最后，您需要在清单文件中添加您正在使用OpenGL ES 2的说明，以告知Android应用市场支持的设备可见。\n入门我们将过一道下面所有的代码并且解释每一部分的作用。您可以跟着拷贝每一处的代码片段来创建您自己的项目，您也可以在文章末尾下载这个已完成的项目。在开发工具（如：Android Studio）中创建您的Android项目，名字不重要，这里由于这个课程我将MainActivity更名为LessonOneActivity。\n\n我们来看这段代码：\n\n12/** 保留对GLSurfaceView的引用*/private GLSurfaceView mGLSurfaceView;\n这个GLSurfaceView是一个特别的View，它为我们管理OpenGL界面并且将它绘制在Android View系统。它还添加了许多功能，使其更易于使用OpenGL，包括下面等等：\n\n它为OpenGL提供一个专用的着色线程，因此主线程不会停懈\n它支持连续或按需渲染\n它使用EGL (OpenGL和底层系统窗口之间的接口)来处理屏幕设置\n\n\nGLSurfaceView使得在Android中设置和使用OpenGL相对轻松\n\n1234567891011121314151617181920@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    super.onCreate(savedInstanceState);    mGLSurfaceView = new GLSurfaceView(this);    //检测系统是否支持OpenGL ES 2.0    final ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);    final ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();    final boolean supportsEs2 = configurationInfo.reqGlEsVersion &gt;= 0x20000;    if (supportsEs2) &#123;        // 请求一个OpenGL ES 2.0兼容的上下文        mGLSurfaceView.setEGLContextClientVersion(2);        // 设置我们的Demo渲染器，定义在后面讲        mGLSurfaceView.setRenderer(new LessonOneRenderer());    &#125; else &#123;        // 如果您想同时支持ES 1.0和2.0的话，这里您可以创建兼容OpenGL ES 1.0的渲染器        return;    &#125;    setContentView(mGLSurfaceView);&#125;\n在onCreate()方法中是我们创建OpenGL上下文以及一切开始发生的重要部分。在我们的onCreate()方法中,在调用super.onCreate()后我们首先创建了GLSurfaceView实例。然后我们需要弄清楚系统是否支持OpenGL ES 2.为此，我们获得一个ActivityManager实例，它允许我们与全局系统状态进行交互。然后我们使用它获取设备配置信息，它将告诉我们设备是否支持OpenGL ES 2。我们也可以通过传入不同的渲染器来支持OpenGL ES 1.x，尽管因为API不同，我们需要编写不同的代码。对于本课我们仅仅关注支持OpenGL ES 2。\n一旦我们知道设备是否支持OpenGL ES 2，我们告诉GLSurfaceView兼容OpenGL ES 2，然后传入我们的自定义渲染器。无论何时调整界面或绘制新帧，系统都会调用此渲染器。\n最后，我们调用setContentView()设置GLSurfaceView为显示内容，它告诉Android这个活动内容因该被我们的OpenGL界面填充。要入门OpenGL，就是这么简单。\n12345678910111213@Overrideprotected void onResume() &#123;    super.onResume();    //Activity 必须在onResume中调用GLSurfaceView的onResume方法    mGLSurfaceView.onResume();&#125;@Overrideprotected void onPause() &#123;    super.onPause();    //Activity 必须在onPause中调用GLSurfaceView的onPause方法    mGLSurfaceView.onPause();&#125;\nGLSurfaceView要求我们在ActivityonResume()和onPause()的父方法被调用后分别调用它的onResume()和onPause()方法。我们在此添加调用以完善我们的Activity。\n可视化3D世界在这部分，我们来看怎样让OpenGL ES 2工作，以及我们如何在屏幕上绘制东西。在Activity中我们传入自定义的GLSurfaceView.Renderer到GLSurfaceView，它将在这里定义。这个渲染器有三个重要的方法，每当系统事件发生时，它们将会自动被调用：\n\npublic void onSurfaceCreated(GL10 gl, EGLConfig config)\n\n当界面第一次被创建时调用，如果我们失去界面上下文并且之后由系统重建，也会被调用。\n\npublic void onSurfaceChanged(GL10 gl, int width, int height)\n\n每当界面改变时被调用；例如，从纵屏切换到横屏，在创建界面后也会被调用。\n\npublic void onDrawFrame(GL10 gl)\n\n每当绘制新帧时被调用。\n您可能注意到GL10的实例被传入名字是gl。当使用OpengGL ES 2绘制时，我们不能使用它；我们使用GLES20类的静态方法来代替。这个GL10参数仅仅是在这里，因为相同的接口被使用在OpenGL ES 1.x。\n\n在我们的渲染器可以显示任何内容之前，我们需要有些东西去显示。在OpenGL ES 2，我们通过制定数字数组传递内容。这些数字可以表示位置、颜色或任何我们需要的。在这个Demo中，我们将显示三个三角形。\n\n1234567891011121314151617181920212223242526272829303132// 新类成员private final FloatBuffer mTriangle1Verticels;private final FloatBuffer mTriangle2Verticels;private final FloatBuffer mTriangle3Verticels;/** 每个Float多少字节*/private final int mBytePerFloat = 4;/** * 初始Model数据 */public LessonOneRenderer() &#123;    // 这个三角形是红色，蓝色和绿色组成    final float[] triangle1VerticesData = &#123;        // X, Y, Z,        // R, G, B, A        -0.5F, -0.25F, 0.0F,        1.0F, 0.0F, 0.0F, 1.0F,        0.5F, -0.25F, 0.0F,        0.0F, 0.0F, 1.0F, 1.0F,        0.0F, 0.559016994F, 0.0F,        0.0F, 1.0F, 0.0F, 1.0F    &#125;;    ...    // 初始化缓冲区    mTriangle1Verticels = ByteBuffer.allocateDirect(triangle1VerticesData.length * mBytePerFloat).order(ByteOrder.nativeOrder()).asFloatBuffer();    ...    mTriangle1Verticels.put(triangle1VerticesData).position(0);    ...&#125;\n那么，这些是什么意思？如果您曾经使用过OpenGL 1， 您可能会习惯这样做：\n12345glBegin(GL_TRIANGLES);glVertex3f(-0.5f, -0.25f, 0.0f);glColor3f(1.0f, 0.0f, 0.0f);...glEnd();\n这种方法在OpenGL ES 2中不起作用。我们不是通过一堆方法调用来定义点，而是定义一个数组。让我们再来看看我们这个数组：\n1234567final float[] triangle1VerticesData = &#123;                // X, Y, Z,                // R, G, B, A                -0.5f, -0.25f, 0.0f,                1.0f, 0.0f, 0.0f, 1.0f,                ...&#125;;\n上面展示的代表三角形的一个点。我们已设置好前三个数字代表位置（X,Y,Z），随后的四个数字代表颜色（红，绿，蓝，透明度）。您不必太担心如何定义这个数组；只要记住当我们想绘制东西在OpenGL ES 2时，我们需要以块的形式传递数据，而不是一次传递一个。\n了解缓冲区123// 初始化缓冲区mTriangle1Verticels = ByteBuffer.allocateDirect(triangle1VerticesData.length * mBytePerFloat).order(ByteOrder.nativeOrder()).asFloatBuffer();...\n我们在Android上使用Java进行编码，但OpengGL ES 2底层实现其实使用C语言编写的。在我们将数据传递给OpenGL之前，我们需要将其转换成它能理解的形式。Java和native系统可能不会以相同的顺序存储它们的字节，因此我们使用一个特殊的缓冲类并创建一个足够大的ByteBuffer来保存我们的数据，并告诉它使用native字节顺序存储数据。然后我们将它转换成FloatBuffer，以便我们可以使用它来保存浮点数据。最后，我们将数组复制到缓冲区。\n这个缓冲区的东西看起来可能很混乱，单请记住，在将数据传递给OpenGL之前，我们需要做一个额外的步骤。我们现在的缓冲区已准备好可以用于将数据传入OpenGL。\n另外，float缓冲区在Froyo上很慢,在Gingerbread上缓慢，因此您可能不希望经常更换它们。\n理解矩阵123456789101112131415161718192021222324252627282930313233343536// new class 定义/** * 存储view矩阵。可以认为这是一个相机，我们通过相机将世界空间转换为眼睛空间 * 它定位相对于我们眼睛的东西 */private float[] mViewMatrix = new float[16];@Overridepublic void onSurfaceCreated(GL10 gl, EGLConfig config) &#123;    // 设置背景清理颜色为灰色    GLES20.glClearColor(0.5F, 0.5F, 0.5F, 0.5F);    // 将眼睛放到原点之后    final float eyeX = 0.0F;    final float eyeY = 0.0F;    final float eyeZ = 1.5F;    // 我们的眼睛望向哪    final float lookX = 0.0F;    final float lookY = 0.0F;    final float lookZ = -5.0F;    // 设置我们的向量，这是我们拿着相机时头指向的方向    final float upX = 0.0F;    final float upY = 1.0F;    final float upZ = 0.0F;    // 可以这样想象：我们在桥上拿着相机90°弯腰拍摄水平面下5米处的美人鱼    // 设置view矩阵，可以说这个矩阵代表相机的位置    // 注意：在OpenGL 1中使用ModelView matrix，这是一个model和view矩阵的组合。    //在OpenGL2中，我们选择分别跟踪这些矩阵    Matrix.setLookAtM(mViewMatrix, 0, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ);    ...&#125;\n另一个有趣的话题是矩阵！无论您何时进行3D编程，这些都将成为您最好的朋友。因此，您需要很好的了解他们。\n当我们的界面被创建，我们第一件事情是设置清理颜色为灰色。alpha部分也设置为灰色，但在我们本课程中没有进行alpha混合，因此该值未使用。我们只需要设置一次清理颜色，之后我们不会更改它。\n我们第二件事情是设置view矩阵。我们使用了几个不同种类的矩阵，它们都做了些重要的事情：\n\nmodel（模型）矩阵，该矩阵用于在“世界”中的某处放置模型。例如，您有一个模型车，你想将它放置在东边一千米处，您将使用矩阵模型来做这件事。\nview （视图)矩阵，该矩阵代表相机。如果我们想查看位于东边一千米处的车，我们也需要向东移动一千米（另一种思考方式是我们保持静止，世界向西移动一千米）。我们使用视图矩阵来做到这点。\nprojection（投影)矩阵。由于我们的屏幕是平面的，我们需要进行最后的转换，将我们的视图“投影”到我们的屏幕上并获得漂亮的3D视角。这就是投影矩阵的用途\n\n可以在SongHo的OpenGL教程中找到很好的解释。我建议您阅读几次直到您把握好这个想法为止；别担心，我也阅读了它好几次！\n在OpenGL 1中，模型和视图矩阵被组合并且假设了摄像机处于(0,0,0)坐标并面向Z轴方向。\n我们不需要手动构建这些矩阵，Android有一个Matrix帮助类，它能为我们做繁重的工作。这里，我为摄像机创建了一个视图矩阵，它位于原点后，朝向远处。\n定义vertex（顶点）和fragment（片段）着色器1234567891011121314final String vertexShader =        \"uniform mat4 u_MVPMatrix;    \\n\" + // 一个表示组合model、view、projection矩阵的常量        \"attribute vec4 a_Position;   \\n\" + // 我们将要传入的每个顶点的位置信息        \"attribute vec4 a_Color;      \\n\" + // 我们将要传入的每个顶点的颜色信息        \"varying vec4 v_Color;        \\n\" + // 他将被传入片段着色器        \"void main()                  \\n\" + // 顶点着色器入口        \"&#123;                            \\n\" +        \"   v_Color = a_Color;        \\n\" + // 将颜色传递给片段着色器                                            // 它将在三角形内插值        \"   gl_Position = u_MVPMatrix \\n\" + // gl_Position是一个特殊的变量用来存储最终的位置        \"               * a_Position  \\n\" + // 将顶点乘以矩阵得到标准化屏幕坐标的最终点        \"&#125;                            \\n\";\n在OpenGL ES 2中任何我们想展示在屏幕中的东西都必须先经过顶点和片段着色器，还好这些着色器并不像他们看起来的那么复杂。顶点着色器在每个顶点执行操作，并把这些操作的结果使用在片段着色器做额外的每像素计算。\n每个着色器基本由输入（input）、输出（output）和一个程序（program）组成。首先我们定义一个统一（uniform），它是一个包含所有变换的组合矩阵。它是所有顶点的常量，用于将它们投影到屏幕上。然后我们定义了位置和颜色属性（attribute），这些属性将从我们之前定义的缓存区中读入，并指定每个顶点的位置和颜色。接着我们定义了一个变量（varying），它负责在三角形中插值并传递到片段着色器。当它运行到片段着色器，它将为每个像素持有一个插值。\n假设我们定义了一个三角形每个点都是红色、绿色和蓝色，我们调整它的大小让它占用10像素屏幕。当片段着色器运行时，它将为每像素包含一个不同的变量（varying）颜色。在某一点上，变量（varying）将是红色，但是在红色和蓝色之间它可能是更紫的颜色。\n除了设置颜色，我们还告诉OpenGL顶点在屏幕上的最终位置。然后我们定义片段着色器：\n1234567final String fragmentShader =        \"precision mediump float;       \\n\" + // 我们将默认精度设置为中等，我们不需要片段着色器中的高精度        \"varying vec4 v_Color;          \\n\" + // 这是从三角形每个片段内插的顶点着色器的颜色        \"void main()                    \\n\" + // 片段着色器入口        \"&#123;                              \\n\" +        \"   gl_FragColor = v_Color;     \\n\" + // 直接将颜色传递        \"&#125;                              \\n\";\n这是个片段着色器，它会将东西放到屏幕上。在这个着色器中，我们得到的变量（varying）颜色来自顶点着色器，然后将它直接传递给OpenGL。该点已按像素插值，因为片段着色器将针对每个将要绘制的像素点运行。\n更多信息：OpenGL ES 2 API快速参考卡\n将着色器加载到OpenGL12345678910111213141516171819202122// 加载顶点着色器int vertexShaderHandle = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER);if (vertexShaderHandle != 0) &#123;    // 传入顶点着色器源代码    GLES20.glShaderSource(vertexShaderHandle, vertexShader);    // 编译顶点着色器    GLES20.glCompileShader(vertexShaderHandle);    // 获取编译状态    final int[] compileStatus = new int[1];    GLES20.glGetShaderiv(vertexShaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, 0);    // 如果编译失败则删除着色器    if (compileStatus[0] == 0) &#123;        GLES20.glDeleteShader(vertexShaderHandle);        vertexShaderHandle = 0;    &#125;&#125;if (vertexShaderHandle == 0) &#123;    throw new RuntimeException(\"Error creating vertex shader.\");&#125;\n首先，我们创建一个着色器对象。如果成功，我们将得到这个对象的引用。然后，我们使用这个引用传入着色器源码然后编译它。我们可以从OpenGL获取编译是否成功的状态，如果失败我们可以使用GLES20.glGetShaderInfoLog(shader)找到原因。我们按照相同的步骤加载片段着色器。\n将顶点和片段着色器链接到一个程序中12345678910111213141516171819202122232425// 创建一个程序对象并将引用放进去int programHandle = GLES20.glCreateProgram();if (programHandle != 0) &#123;    // 绑定顶点着色器到程序对象中    GLES20.glAttachShader(programHandle, vertexShaderHandle);    // 绑定片段着色器到程序对象中    GLES20.glAttachShader(programHandle, fragmentShaderHandle);    // 绑定属性    GLES20.glBindAttribLocation(programHandle, 0, \"a_Position\");    GLES20.glBindAttribLocation(programHandle, 1, \"a_Color\");    // 将两个着色器连接到程序    GLES20.glLinkProgram(programHandle);    // 获取连接状态    final int[] linkStatus = new int[1];    GLES20.glGetProgramiv(programHandle, GLES20.GL_LINK_STATUS, linkStatus, 0);    // 如果连接失败，删除这程序    if (linkStatus[0] == 0) &#123;        GLES20.glDeleteProgram(programHandle);        programHandle = 0;    &#125;&#125;if (programHandle == 0) &#123;    throw new RuntimeException(\"Error creating program.\");&#125;\n在我们使用顶点和片段着色器之前，我们需要将它们绑定到一个程序中，它连接了顶点着色器的输出和片段着色器的输入。这也是让我们从程序传递输入并使用着色器绘制形状的原因。\n我们创建一个程序对象，如果成功绑定着色器。我们想要将位置和颜色作为属性传递进去，因此我们需要绑定这些属性。然后我们将着色器连接到一起。\n123456789101112131415161718// 新类成员/** 这将用于传递变换矩阵*/private int mMVPMatrixHandle;/** 用于传递model位置信息*/private int mPositionHandle;/** 用于传递模型颜色信息*/private int mColorHandle;@Overridepublic void onSurfaceCreated(GL10 gl, EGLConfig config) &#123;    ...    // 设置程序引用，这将在之后传递值到程序时使用    mMVPMatrixHandle = GLES20.glGetUniformLocation(programHandle, \"u_MVPMatrix\");    mPositionHandle = GLES20.glGetAttribLocation(programHandle, \"a_Position\");    mColorHandle = GLES20.glGetAttribLocation(programHandle, \"a_Color\");    // 告诉OpenGL渲染的时候使用这个程序    GLES20.glUseProgram(programHandle);&#125;\n在我们成功连接程序后，我们还要完成几个任务，以便我们能实际使用它。第一个任务是获取引用，因为我们要传递数据到程序中。然后我们要告诉OpenGL在绘制时使用我们这个程序。由于本课我们仅使用了一个程序，我们可以将它放到onSurfaceCreated()方法中而不是onDrawFrame()\n设置透视投影1234567891011121314151617181920// 新类成员// 存放投影矩阵，用于将场景投影到2D视角private float[] mProjectionMatrix = new float[16];@Overridepublic void onSurfaceChanged(GL10 gl, int width, int height) &#123;    // 设置OpenGL界面和当前视图相同的尺寸    GLES20.glViewport(0, 0, width, height);    // 创建一个新的透视投影矩阵，高度保持不变，而高度根据纵横比而变换    final float ratio = (float) width / height;    final float left = -ratio;    final float right = ratio;    final float bottom = -1.0F;    final float top = 1.0F;    final float near = 1.0F;    final float far = 10.0F;    Matrix.frustumM(mProjectionMatrix, 0, left, right, bottom, top, near, far);&#125;\nonSurfaceChanged()方法至少被调用一次，每当界面改变也会被调用。因为我们需要每当界面改变的时候重置投影矩阵，那么onSurfaceChanged()方法中是个理想的地方。\n绘制东西到屏幕上！123456789101112131415161718// 新类成员// 存放模型矩阵，该矩阵用于将模型从对象空间（可以认为每个模型开始都位于宇宙的中心）移动到世界空间private float[] mModelMatrix = new float[16];@Overridepublic void onDrawFrame(GL10 gl) &#123;    GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);    // 每10s完成一次旋转    long time = SystemClock.uptimeMillis() % 10000L;    float angleDegrees = (360.0F / 10000.0F) * ((int)time);    // 画三角形    Matrix.setIdentityM(mModelMatrix, 0);    Matrix.rotateM(mModelMatrix, 0, angleDegrees, 0.0F, 0.0F, 1.0F);    drawTriangle(mTriangle1Verticels);    ...&#125;\n这是实际显示在屏幕上的内容。我们清理屏幕，因此不会得到任何奇怪的镜像效应影响，我们希望我们的三角形在屏幕上能有平滑的动画，通常使用时间而不是帧率更好。\n\n实际绘制在drawTriangle()方法中完成\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 新的类成员/** 为最终的组合矩阵分配存储空间，这将用来传入着色器程序*/private float[] mMVPMatrix = new float[16];/** 每个顶点有多少字节组成，每次需要迈过这么一大步（每个顶点有7个元素，3个表示位置，4个表示颜色，7 * 4 = 28个字节）*/private final int mStrideBytes = 7 * mBytePerFloat;/** 位置数据偏移量*/private final int mPositionOffset = 0;/** 一个元素的位置数据大小*/private final int mPositionDataSize = 3;/** 颜色数据偏移量*/private final int mColorOffset = 3;/** 一个元素的颜色数据大小*/private final int mColorDataSize = 4;/** * 从给定的顶点数据中绘制一个三角形 * @param aTriangleBuffer 包含顶点数据的缓冲区 */private void drawTriangle(FloatBuffer aTriangleBuffer) &#123;    aTriangleBuffer.position(mPositionOffset);    GLES20.glVertexAttribPointer(            mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, false,            mStrideBytes, aTriangleBuffer);    GLES20.glEnableVertexAttribArray(mPositionHandle);    // 传入颜色信息    aTriangleBuffer.position(mColorOffset);    GLES20.glVertexAttribPointer(mColorHandle, mColorDataSize, GLES20.GL_FLOAT, false,            mStrideBytes, aTriangleBuffer);    GLES20.glEnableVertexAttribArray(mColorHandle);    // 将视图矩阵乘以模型矩阵，并将结果存放到MVP Matrix（model * view）    Matrix.multiplyMM(mMVPMatrix, 0, mViewMatrix, 0, mModelMatrix, 0);    // 将上面计算好的视图模型矩阵乘以投影矩阵，并将结果存放到MVP Matrix（model * view * projection）    Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mMVPMatrix, 0);    GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix, 0);    GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3);&#125;\n您还记得我们最初创建渲染器时定义的那些缓冲区吗？我们终于可以使用它们了。我们需要使用GLES20.glVertexAttribPointer()来告诉OpenGL怎样使用这些数据。\n\n我们来看第一个使用\n\n12345aTriangleBuffer.position(mPositionOffset);GLES20.glVertexAttribPointer(        mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, false,        mStrideBytes, aTriangleBuffer);GLES20.glEnableVertexAttribArray(mPositionHandle);\n我们设置缓冲区的位置偏移，它位于缓冲区的开头。然后我们告诉OpenGL使用这些数据并将其提供给顶点着色器并将其应用到位置属性（a_Position）。我们也需要告诉OpenGL每个顶点或迈幅之间有多少个元素。\n\n注意：迈幅（Stride）需要定义为字节（byte），尽管每个顶点之间我们有7个元素（3个是位置，4个是颜色），但我们事实上有28个字节，因为每个浮点数（float）就是4个字节（byte）。忘记此步骤您可能没有任何错误，但是你会想知道为什么您的屏幕上看不到任何内容。\n\n最终，我们使用了顶点属性，往下我们使用了下一个属性。再往后点我们构建一个组合矩阵，将点投影到屏幕上。我们也可以在顶点着色器中执行此操作，但是由于它只需要执行一次我们也可以只缓存结果。我们使用GLES20.glUniformMatrix4fv()方法将最终的矩阵传入顶点着色器。GLES20.glDrawArrays()将我们的点转换为三角形并将其绘制在屏幕上。\n总结呼呼！这是重要的一课，如果您完成了本课，感谢您！我们学习了怎样创建OpenGL上下文，传入形状数据，加载顶点和片段着色器，设置我们的转换矩阵，最终放在一起。如果一切顺利，您因该看到了类似下面的截屏。\n这一课有很多需要消化的内容，您可能需要多次阅读这些步骤才能理解它。OpenGL ES 2需要更多的设置才能开始，但是一旦您完成了这个过程几次，您就会记住这个流程。\n在Android市场上发布当开发的应用我们不想在无法运行这些应用程序的人在市场上看到它们，否则当应用程序在其设备上崩溃时，我们可能会收到大量糟糕的评论和评分。要防止OpenGL ES 2 应用程序出现在不支持它的设备上，你可以在清单文件中添加：\n123&lt;uses-feature    android:glEsVersion=\"0x00020000\"    android:required=\"true\" /&gt;\n这告诉市场您的app需要有OpenGL ES 2支持，不支持的设备将会隐藏您的app。\n进一步探索尝试更改动画速度，顶点或颜色，看看会发生什么！可以在Github下载本课程源代码：下载项目本课的编译版本也可以再Android市场下：google play 下载apk“我”也编译了个apk，方便大家下载：github download\n教程目录\nOpenGL Android课程一：入门\nOpenGL Android课程二：环境光和漫射光\nOpenGL Android课程三：使用每片段照明\nOpenGL Android课程四：介绍纹理基础\nOpenGL Android课程五：介绍混合（Blending）\nOpenGL Android课程六：介绍纹理过滤\nOpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）\n\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-opengl/6093CCF8-F7C1-4F4E-A668-C9E76783063F.png","plink":"https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One/"},{"title":"C 学习笔记","date":"2018-12-25T15:18:45.000Z","author":"xujiaji","updated":"2019-05-15T08:15:04.969Z","content":"重学一次C语言，记录一下学习《C Primer Plus》的笔记，方便回忆！\n\n编译12gcc -o foo.exe foo.c -lregexgcc foo.c -o foo.exe -lregex\n字符串和格式化输入/输出\n字符串以char数组来存储\n常量用 #define 定义\n1#define DENSITY 62.4\n\nstrlen()获取字符串的长度，注意需要#include &lt;string.h&gt;\n\nchar类型数组和null字符\nC语言没有专门用于储存字符串的变量类型，字符串都被储存在char类型的数组中\n字符串以\\0（空字符）结束，它是不打印出来的字符\n如果有40哥存储单单元的字符串，只能储存39哥字符，剩下一个字节留给空字符\n\n\n一下代码%s作为转化说明，scanf()只会读取字符串中的一个单词。并且没有加&amp;取地址符，name就是地址\n12char name[40];scanf(\"%s\", name);\n\n&quot;x&quot;不同于&#39;x&#39;,&quot;x&quot;是字符串由x和\\0组成\n\nsizeof运算符，它以字节为单位给出对象的大小。strlen()只给出字符串长度，到空字符（不包括空字符）\nC99和C11标准专门为sizeof运算符的返回类型添加了%zd转换说明，对于strlen()也适用\nsizeof使用时，对于类型必须加括号。对于特定量，可有可无。类型：sizeof(char), sizeof(float); 特定量：sizeof 6.28, sizeof name\n\n\n\n常量和C预处理器\nC预处理器定义常量：#define NAME value，其中“NAME”为命令的常量名，约定大写；“value”是对应的值\n1234#define BEEP '\\a'#define TEE 'T'#define ESC '\\033'#define OOPS \"Now you have done it!\"\n\nconst限定符，C90标准新增该关键字，用于限定一个变量为只读\n\n明示常量：C头文件limits.h和float.h分别提供了与整数类型和浮点数类型大小限制相关的详细信息1234567891011#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;float.h&gt;int main()&#123;    printf(\"Some number limits for this system: \\n\");    printf(\"Biggest int: %d\\n\", INT_MAX);    printf(\"Smallest long long: %lld\\n\", LLONG_MIN);    return 0;&#125;\n\n\n","plink":"https://blog.xujiaji.com/post/c-learn-note/"},{"title":"一个项目如何编译多个不同签名、包名、资源等，的apk？","date":"2018-10-29T08:15:20.000Z","author":"xujiaji","updated":"2019-04-08T06:54:02.208Z","content":"简介如题所示！本篇文章就是为了解决这种问题。方便打包和运行的时候能做到无需手动替换配置，即可打包想要的apk。打包的时候，只需选一下想打哪种配置的apk就OK啦。 (^o^)/~\n\n先来看，有需求如下：\n\n\n同一个项目\n不同的apk图标\n不同的服务器域名\n不同的包名\n不同的名称\n不同的签名\n不同的第三方key\n不同的版本名版本号\n\n\n解决思路\n\n\n当然最直接的方式不过于每次打不同包的时候都去替换对应的配置，这种方式的麻烦之处不言而喻。\n将所有配置，资源等都配置入项目中，打包的时候，根据选择渠道打包不同配置的apk。（本篇文章就是要讲怎么这么做的）\n相信还有其他的。。。\n\n相关的几个要点\n首先我们需要知道productFlavors来配置渠道，这里我将渠道用来表示哪种apk，如下我需要配置四种应用:\n123456productFlavors &#123;  userquhua &#123;&#125;  quhua &#123;&#125;  cuntuba &#123;&#125;  xemh &#123;&#125;&#125;\n\n如果我们选择了某一个渠道，那么运行打包的时候会根据渠道名选择资源文件（可结合第6点一起看）\n\n签名可在signingConfigs中配置多个（我将所有签名文件放在了项目跟目录的key文件夹中），这样我们就可以通过signingConfigs指定预制好的签名配置。\n1234567891011121314151617181920212223242526272829signingConfigs &#123;    userquhuaRelease &#123;        storeFile file(\"../key/xxx1.keystore\")        storePassword \"xxxxxx\"        keyAlias \"alias\"        keyPassword \"xxxxxx\"    &#125;    quhuaRelease &#123;        storeFile file(\"../key/xxx2.keystore\")        storePassword \"xxxxxx\"        keyAlias \"alias\"        keyPassword \"xxxxxx\"    &#125;    cuntubaRelease &#123;        storeFile file(\"../key/xxx3.keystore\")        storePassword \"xxxxxx\"        keyAlias \"alias\"        keyPassword \"xxxxxx\"    &#125;    xemhRelease &#123;        storeFile file(\"../key/xxx4.keystore\")        storePassword \"xxxxxx\"        keyAlias \"alias\"        keyPassword \"xxxxxx\"    &#125;&#125;\n\n可在build.gradle中配置动态配置java代码调用的常量数据（如：通过该方式我们可根据不同渠道动态配置第三方appid，或其他需要根据渠道而改变的数据）\n\n比如：我们在defaultConfig {} 中定义了:\n1buildConfigField &quot;String&quot;, &quot;SERVER_URL&quot;, &apos;&quot;http://xx.xxxx.com/&quot;&apos;\n\n此时，您看一下清单文件中manifest标签里的，package的值，假如是：\n1com.xxx.xx\n\n那么，您就可以在java代码中通过导入文件：\n1import com.xxx.xx.BuildConfig;\n\n然后调用\n1BuildConfig.SERVER_URL\n\n\n它的值就是上边配置的字符串：http://xx.xxxx.com/。\n\n您可以进入BuildConfig看一看，里面还包含了一些当前的包名版本号等信息。\n\n\n在渠道配置那里可以配置对应的包名版本名签名等等如下所示：\n12345678910111213141516171819202122232425262728293031323334// 省略其他配置...android &#123;  // 省略其他配置...  productFlavors &#123;      userquhua &#123;          applicationId \"com.xxx.xx\"          versionCode 1          versionName \"1.0.0\"          signingConfig signingConfigs.userquhuaRelease // 配置签名          String qq_id = '\"xxxxxxxxx\"' //配置qq appid          buildConfigField \"String\",           \"QQ_ID\", qq_id          buildConfigField \"String\",           \"WX_ID\", '\"wxxxxxxxxxxxxxxxxx\"' // 配置微信appid          manifestPlaceholders = [            qq_id: qq_id,            JPUSH_PKGNAME : applicationId,            JPUSH_APPKEY : \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", //JPush 上注册的包名对应的 Appkey.            JPUSH_CHANNEL : \"developer-default\",          ]      &#125;  &#125;  buildTypes &#123;    release &#123;      // 省略其他配置...        signingConfig null  // 置空    &#125;    debug &#123;      // 省略其他配置...        signingConfig null // 置空    &#125;  &#125;&#125;\n\n这样，如果我们打包userquhua这个渠道，看第2点中介绍选择userquhuaDebug。\n然后，最好clean一下项目、然后我们运行项目。\n该app的包名就是com.xxx.xx，版本号为1，版本名为1.0.0。\n通过BuildConfig调用QQ_ID静态常量，就是该渠道里配置的值，WX_ID同理。\nmanifestPlaceholders配置也可以这样配置。\n签名问题经过个人反复尝试（然后半天就过去了￣へ￣），最终签名如上配置。需要注意buildTypes中的签名配置signingConfig如果不设置为null，那么打包的是有还是以内置的签名打包。\n\n\n资源文件替换再看到第2点的介绍，我们选择运行渠道后，会默认匹配对应渠道下的资源。下面我将xemh渠道的资源目录全部展开一下。\n如上图这样，只需要资源名字和app目录对应的文件名字一样即可替换。\nstrings.xml里的应用名，只需要将对应app_name修改既可替换app下strings的app_name，其他不用替换的不用写就行。\n\n\n打正式包的时候选好渠道，就可以打包不同配置的apk，当然您也可以使用命令的方式。\n\n其他配置记录\n获取当前时间\n\n123static def releaseTime() &#123;    return new Date().format(\"yyyy-MM-dd-HH.mm\", TimeZone.getTimeZone(\"GMT+8\"))&#125;\n\n打包的时候，修改文件名，以方便区别渠道和版本打包时间\n\n123456applicationVariants.all &#123;    variant -&gt;        variant.outputs.all &#123;            outputFileName = \"$&#123;variant.productFlavors[0].name&#125;-v$&#123;variant.productFlavors[0].versionName&#125;-$&#123;releaseTime()&#125;.apk\"        &#125;&#125;\n\n${variant.productFlavors[0].name}当前渠道名\n${variant.productFlavors[0].versionName}当前版本名\n${releaseTime()}当前时间\n\n其他需要注意事项如果您在清单文件AndroidManifest.xml中，有那种以包名开头命名的那种。因为如果包名都改了，有些也需要动态的改变。可以用${applicationId}代替。在打包的时候，会自动替换成当前包名。\n\n比如，类似下配置：\n\n1234567891011121314151617181920212223&lt;permission    android:name=\"com.xxx.xx.permission.JPUSH_MESSAGE\"    android:protectionLevel=\"signature\" /&gt;&lt;uses-permission android:name=\"com.xxx.xx.permission.JPUSH_MESSAGE\" /&gt;&lt;receiver    android:name=\".push.MyJPushMessageReceiver\"    android:enabled=\"true\"    android:exported=\"false\" &gt;    &lt;intent-filter&gt;        &lt;action android:name=\"cn.jpush.android.intent.RECEIVE_MESSAGE\" /&gt;        &lt;category android:name=\"com.xxx.xx\" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;provider    android:name=\"android.support.v4.content.FileProvider\"    android:authorities=\"com.xxx.xx.provider\"    android:exported=\"false\"    tools:replace=\"android:authorities\"    android:grantUriPermissions=\"true\"&gt;    &lt;meta-data        android:name=\"android.support.FILE_PROVIDER_PATHS\"        android:resource=\"@xml/file_paths\" /&gt;&lt;/provider&gt;\n\n可改为：\n\n1234567891011121314151617181920212223&lt;permission    android:name=\"$&#123;applicationId&#125;.permission.JPUSH_MESSAGE\"    android:protectionLevel=\"signature\" /&gt;&lt;uses-permission android:name=\"$&#123;applicationId&#125;.permission.JPUSH_MESSAGE\" /&gt;&lt;receiver    android:name=\".push.MyJPushMessageReceiver\"    android:enabled=\"true\"    android:exported=\"false\" &gt;    &lt;intent-filter&gt;        &lt;action android:name=\"cn.jpush.android.intent.RECEIVE_MESSAGE\" /&gt;        &lt;category android:name=\"$&#123;applicationId&#125;\" /&gt;    &lt;/intent-filter&gt;&lt;/receiver&gt;&lt;provider    android:name=\"android.support.v4.content.FileProvider\"    android:authorities=\"$&#123;applicationId&#125;.provider\"    android:exported=\"false\"    tools:replace=\"android:authorities\"    android:grantUriPermissions=\"true\"&gt;    &lt;meta-data        android:name=\"android.support.FILE_PROVIDER_PATHS\"        android:resource=\"@xml/file_paths\" /&gt;&lt;/provider&gt;\n\n当然值得注意的是，在代码中我们也不能把包名写死了，可通过BuildConfig得到当前包名\n\n我的完整配置，供参考\n有关隐私信息的都用xxx替换了\n\n\n项目根目录的build.gradle\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123;    repositories &#123;        google()        jcenter()    &#125;    dependencies &#123;        classpath 'com.android.tools.build:gradle:3.0.0'        classpath \"io.github.prototypez:save-state:0.1.7\"        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    &#125;&#125;allprojects &#123;    repositories &#123;        google()        jcenter()        maven &#123; url \"https://jitpack.io\" &#125;        maven &#123; url 'http://oss.jfrog.org/artifactory/oss-snapshot-local/' &#125;        flatDir &#123;            dirs 'libs'        &#125;    &#125;&#125;task clean(type: Delete) &#123;    delete rootProject.buildDir&#125;ext&#123;    minSdkVersion               = 16    targetSdkVersion            = 27    compileSdkVersion           = 27    buildToolsVersion           = '27.1.1'    supportLibraryVersion       = '27.1.1'    xmvpVersion                 = '1.2.2'    retrofit2Version            = '2.3.0'    okhttp3Version              = '3.8.1'    butterknifeVersion          = '8.6.0'    rx2Version                  = '2.0.2'    CircleProgressDialogVersion = '1.0.2'    smarttabVersion             = '1.6.1@aar'    adapterHelperVersion        = '2.9.41'    glideVersion                = '4.7.1'    roundedimageviewVersion     = '2.3.0'    eventbusVersion             = '3.0.0'    dispatcherVersion           = '2.4.0'    picture_libraryVersion      = 'v2.2.3'    statusbarutilVersion        = '1.5.1'    okhttpUtilsVersion          = '3.8.0'    constraintVersion           = '1.1.3'    flexboxVersion              = '1.0.0'&#125;\n\napp目录下的build.gradle\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292apply plugin: 'com.android.application'apply plugin: 'save.state'static def releaseTime() &#123;    return new Date().format(\"yyyy-MM-dd-HH.mm\", TimeZone.getTimeZone(\"GMT+8\"))&#125;android &#123;    compileSdkVersion rootProject.compileSdkVersion//    buildToolsVersion rootProject.buildToolsVersion    defaultConfig &#123;        minSdkVersion rootProject.minSdkVersion        targetSdkVersion rootProject.targetSdkVersion        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"        multiDexEnabled true        // config the JSON processing library        javaCompileOptions &#123;            annotationProcessorOptions &#123;                arguments = [ serializer : \"gson\" ]            &#125;        &#125;        ndk &#123;            abiFilters \"armeabi-v7a\"        &#125;        renderscriptTargetApi 25        renderscriptSupportModeEnabled true    &#125;    signingConfigs &#123;        userquhuaRelease &#123;            storeFile file(\"../key/xxx.keystore\")            storePassword \"xxxxxx\"            keyAlias \"xxx\"            keyPassword \"xxxxxx\"        &#125;        quhuaRelease &#123;            storeFile file(\"../key/xxx.keystore\")            storePassword \"xxxxxxx\"            keyAlias \"xxx\"            keyPassword \"xxxxxxx\"        &#125;        cuntubaRelease &#123;            storeFile file(\"../key/xxx.keystore\")            storePassword \"xxxxxxx\"            keyAlias \"xxx\"            keyPassword \"xxxxxxx\"        &#125;        xemhRelease &#123;            storeFile file(\"../key/xxx.keystore\")            storePassword \"xxxxxxx\"            keyAlias \"xxx\"            keyPassword \"xxxxxxx\"        &#125;    &#125;    flavorDimensions \"default\"    productFlavors &#123;        userquhua &#123;            applicationId \"com.xxx.xx\"            versionCode 22            versionName \"1.7.5\"            signingConfig = signingConfigs.userquhuaRelease            String qq_id = '\"xxxxxx\"'            buildConfigField \"String\",           \"QQ_ID\", qq_id // qq appId            buildConfigField \"String\",         \"SINA_ID\", '\"xxxxxx\"' // 新浪appId            buildConfigField \"String\",           \"WX_ID\", '\"xxxxxx\"' // 微信 appId            buildConfigField \"String\",           \"UM_ID\", '\"xxxxxx\"' // 友盟            buildConfigField \"String\",       \"WX_SECRET\", '\"xxxxxx\"' // 微信 secret            buildConfigField \"String\",   \"SINA_REDIRECT\", '\"http://open.weibo.com/apps/xxxxxx/privilege/oauth\"' // 新浪            buildConfigField \"String\",   \"ADHUB_INIT_ID\", '\"xxxxxx\"' // 广告sdk初始化id            buildConfigField \"String\", \"ADHUB_SPLASH_ID\", '\"xxxxxx\"' // 开屏广告id            buildConfigField \"String\", \"ADHUB_BANNER_ID\", '\"xxxxxx\"' // banner广告id            buildConfigField \"String\",      \"SERVER_URL\", '\"http://xxx.xxx.com/\"'            buildConfigField \"String\",        \"LOGO_URL\", '\"http://file.xxx.com/img/xxx.png\"'            manifestPlaceholders = [                    qq_id: qq_id,                    JPUSH_PKGNAME : applicationId,                    JPUSH_APPKEY : \"xxxxxx\", //JPush 上注册的包名对应的 Appkey.                    JPUSH_CHANNEL : \"developer-default\", //暂时填写默认值即可.            ]        &#125;        quhua &#123;            applicationId \"com.xxx.xx\"            versionCode 1            versionName \"1.0.0\"            signingConfig = signingConfigs.quhuaRelease            String qq_id = '\"xxxxxx\"'            buildConfigField \"String\",           \"QQ_ID\", qq_id            buildConfigField \"String\",         \"SINA_ID\", '\"xxxxxx\"'            buildConfigField \"String\",           \"WX_ID\", '\"xxxxxx\"'            buildConfigField \"String\",           \"UM_ID\", '\"xxxxxx\"'            buildConfigField \"String\",       \"WX_SECRET\", '\"xxxxxx\"'            buildConfigField \"String\",   \"SINA_REDIRECT\", '\"http://open.weibo.com/apps/xxxxxx/privilege/oauth\"'            buildConfigField \"String\",   \"ADHUB_INIT_ID\", '\"xxxxxx\"' // 广告sdk初始化id            buildConfigField \"String\", \"ADHUB_SPLASH_ID\", '\"xxxxxx\"' // 开屏广告id            buildConfigField \"String\", \"ADHUB_BANNER_ID\", '\"xxxxxx\"' // banner广告id            buildConfigField \"String\",      \"SERVER_URL\", '\"http://xx.xxx.com/\"'            buildConfigField \"String\",        \"LOGO_URL\", '\"http://file.xxx.com/img/xxx.png\"'            manifestPlaceholders = [                    qq_id: qq_id,                    JPUSH_PKGNAME : applicationId,                    JPUSH_APPKEY : \"xxxxxx\", //JPush 上注册的包名对应的 Appkey.                    JPUSH_CHANNEL : \"developer-default\", //暂时填写默认值即可.            ]        &#125;        cuntuba &#123;            applicationId \"com.xxx.xx\"            versionCode 1            versionName \"1.0.0\"            signingConfig = signingConfigs.cuntubaRelease            String qq_id = '\"xxxxxx\"'            buildConfigField \"String\",           \"QQ_ID\", qq_id            buildConfigField \"String\",         \"SINA_ID\", '\"xxxxxx\"'            buildConfigField \"String\",           \"WX_ID\", '\"xxxxxx\"'            buildConfigField \"String\",           \"UM_ID\", '\"xxxxxx\"'            buildConfigField \"String\",       \"WX_SECRET\", '\"xxxxxx\"'            buildConfigField \"String\",   \"SINA_REDIRECT\", '\"http://open.weibo.com/apps/xxxxxx/privilege/oauth\"'            buildConfigField \"String\",   \"ADHUB_INIT_ID\", '\"xxxxxx\"' // 广告sdk初始化id            buildConfigField \"String\", \"ADHUB_SPLASH_ID\", '\"xxxxxx\"' // 开屏广告id            buildConfigField \"String\", \"ADHUB_BANNER_ID\", '\"xxxxxx\"' // banner广告id            buildConfigField \"String\",      \"SERVER_URL\", '\"http://xxx.xxxx.com/\"'            buildConfigField \"String\",        \"LOGO_URL\", '\"http://file.xxx.com/img/xxx.png\"'            manifestPlaceholders = [                    qq_id: qq_id,                    JPUSH_PKGNAME : applicationId,                    JPUSH_APPKEY : \"xxxxxx\", //JPush 上注册的包名对应的 Appkey.                    JPUSH_CHANNEL : \"developer-default\", //暂时填写默认值即可.            ]        &#125;        xemh &#123;            applicationId \"com.xxx.xx\"            versionCode 1            versionName \"1.0.0\"            signingConfig = signingConfigs.xemhRelease            String qq_id = '\"xxxxxx\"'            buildConfigField \"String\",           \"QQ_ID\", qq_id            buildConfigField \"String\",         \"SINA_ID\", '\"xxxxxx\"'            buildConfigField \"String\",           \"WX_ID\", '\"xxxxxx\"'            buildConfigField \"String\",           \"UM_ID\", '\"xxxxxx\"'            buildConfigField \"String\",       \"WX_SECRET\", '\"xxxxxx\"'            buildConfigField \"String\",   \"SINA_REDIRECT\", '\"xxxxxx\"'            buildConfigField \"String\",   \"ADHUB_INIT_ID\", '\"xxxxxx\"' // 广告sdk初始化id            buildConfigField \"String\", \"ADHUB_SPLASH_ID\", '\"xxxxxx\"' // 开屏广告id            buildConfigField \"String\", \"ADHUB_BANNER_ID\", '\"xxxxxx\"' // banner广告id            buildConfigField \"String\",      \"SERVER_URL\", '\"http://xx.xxx.com/\"'            buildConfigField \"String\",        \"LOGO_URL\", '\"http://file.xxxxxx.com/img/xxxxxx.png\"'            manifestPlaceholders = [                    qq_id: qq_id,                    JPUSH_PKGNAME : applicationId,                    JPUSH_APPKEY : \"xxxxxx\", //JPush 上注册的包名对应的 Appkey.                    JPUSH_CHANNEL : \"developer-default\", //暂时填写默认值即可.            ]        &#125;    &#125;    applicationVariants.all &#123;        variant -&gt;            variant.outputs.all &#123;                outputFileName = \"$&#123;variant.productFlavors[0].name&#125;-v$&#123;variant.productFlavors[0].versionName&#125;-$&#123;releaseTime()&#125;.apk\"            &#125;    &#125;    buildTypes &#123;        release &#123;            // 不显示Log            buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"            signingConfig null            minifyEnabled true            zipAlignEnabled true            // 移除无用的resource文件            shrinkResources true            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'        &#125;        debug &#123;            // 显示Log            buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"            signingConfig null            minifyEnabled false            zipAlignEnabled false            shrinkResources false        &#125;    &#125;    packagingOptions &#123;        exclude 'META-INF/DEPENDENCIES.txt'        exclude 'META-INF/NOTICE'        exclude 'META-INF/NOTICE.txt'        exclude 'META-INF/LICENSE'        exclude 'META-INF/LICENSE.txt'    &#125;    compileOptions &#123;        targetCompatibility JavaVersion.VERSION_1_8        sourceCompatibility JavaVersion.VERSION_1_8    &#125;    dexOptions &#123;        javaMaxHeapSize \"4g\" //此处可根据电脑本身配置 数值越大 当然越快        preDexLibraries = false    &#125;&#125;repositories &#123;    flatDir &#123;        dirs 'libs', '../adpoymer/libs'    &#125;&#125;dependencies &#123;    implementation fileTree(include: ['*.jar'], dir: 'libs')    implementation \"com.android.support:appcompat-v7:$supportLibraryVersion\"    implementation \"com.android.support:recyclerview-v7:$supportLibraryVersion\"    implementation \"com.android.support:support-v4:$supportLibraryVersion\"    implementation \"com.android.support:design:$supportLibraryVersion\"    implementation \"com.android.support.constraint:constraint-layout:$constraintVersion\"    //添加retrofit2 的依赖 添加这个依赖就默认添加了okhttp依赖    compile \"com.squareup.retrofit2:retrofit:$retrofit2Version\"    compile \"com.squareup.retrofit2:converter-gson:$retrofit2Version\"    compile \"com.squareup.retrofit2:adapter-rxjava2:$retrofit2Version\"    compile \"com.squareup.okhttp3:logging-interceptor:$okhttp3Version\"    compile \"com.jakewharton:butterknife:$butterknifeVersion\"    annotationProcessor \"com.jakewharton:butterknife-compiler:$butterknifeVersion\"    compile \"io.reactivex.rxjava2:rxandroid:$rx2Version\"    compile \"com.github.xujiaji:xmvp:$xmvpVersion\"    implementation \"com.github.autume:CircleProgressDialog:$CircleProgressDialogVersion\"    compile \"com.ogaclejapan.smarttablayout:library:$smarttabVersion\"    compile \"com.github.CymChad:BaseRecyclerViewAdapterHelper:$adapterHelperVersion\"    compile \"com.github.bumptech.glide:glide:$glideVersion\"    annotationProcessor \"com.github.bumptech.glide:compiler:$glideVersion\"    compile \"com.makeramen:roundedimageview:$roundedimageviewVersion\"    compile \"org.greenrobot:eventbus:$eventbusVersion\"    annotationProcessor \"com.github.hotchemi:permissionsdispatcher-processor:$dispatcherVersion\"    compile \"com.jaeger.statusbarutil:library:$statusbarutilVersion\"    compile(\"com.github.hotchemi:permissionsdispatcher:$dispatcherVersion\") &#123;        exclude module: \"support-v13\"    &#125;    implementation \"com.github.LuckSiege.PictureSelector:picture_library:$picture_libraryVersion\"    implementation 'me.drakeet.library:crashwoodpecker:2.1.1'    implementation 'com.github.chenupt.android:springindicator:1.0.2@aar'    debugImplementation 'com.amitshekhar.android:debug-db:1.0.4'    implementation 'com.umeng.sdk:common:1.5.3'    implementation 'com.umeng.sdk:analytics:7.5.3'    implementation 'com.liulishuo.filedownloader:library:1.7.5'    implementation project(':banner')    implementation project(':xdialog')    implementation project(':shareutil')    implementation project(':update')    implementation project(':pay')//    implementation project(':adhub')    implementation project(':imagewatcher')    implementation files('libs/lite-orm-1.9.2.jar')    implementation 'jp.wasabeef:blurry:2.1.1'    implementation \"com.google.android:flexbox:$flexboxVersion\"    implementation 'cn.jiguang.sdk:jpush:3.1.6'  // 此处以JPush 3.1.6 版本为例。    implementation 'cn.jiguang.sdk:jcore:1.2.5'  // 此处以JCore 1.2.5 版本为例。    compile(name: 'sdk-release', ext: 'aar')    compile(name: 'open_ad_sdk', ext: 'aar')    compile(name: 'adpoymer-3.4.35', ext: 'aar')    implementation 'pl.droidsonroids.gif:android-gif-drawable:1.0.+'&#125;\n\n\nDemo 地址https://github.com/xujiaji/OneForAllApk\n结束就这样就可以解放大量劳动力啦！每次项目打包各种软件，选一下就ojbk，哈哈哈~如果有些配置在其他渠道没有的，也可通过BuildConfig在java中判断如果是某某渠道那么屏蔽。over\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/one-for-more/banner.png","plink":"https://blog.xujiaji.com/post/android-project-one-for-more/"},{"title":"XMVP：一个通过泛型实现的MVP框架2年的演化路","date":"2018-09-21T10:22:15.000Z","author":"xujiaji","updated":"2019-04-08T06:57:05.292Z","content":"\nXMVP框架是我的第一个框架，刚从Android起步第一次了解MVP模式时决心写一个自己的东西框架，到现在已运用在我写的多个项目中。虽然两年了，但核心的思路没有改变，到现在变换也不是太多，精简了一些代码，添加了一些功能。\n\n\n起步2016这是个刚出社会找工作痛苦的时期，我个人不太喜欢生活中麻烦的事情。安静是我的本性，于是想写个属于自己的框架，为未来做些铺垫。于是，便有了XMVP，名字“X”是臭不要脸的加上了自己名字的开头字母。\n目标该框架的目标很简单，为了省掉View、Model、Presenter层之间的依赖实现过程，通过简单的配置，框架自动实现依赖关系\n实现的原理：获取配置的泛型类型，通过反射实例化P层和M层。\n代码1. 关键能让我开始做这个框架的核心代码如下：\n\n传入对象的Class和需要过滤泛型得的匹配的对象，然后遍历klass中配置的泛型判断是不是filterClass的子类，如果是则找到了配置的泛型类型。\n\n1234567891011121314public static &lt;T&gt; Class&lt;T&gt; getGenericClass(Class&lt;?&gt; klass, Class&lt;?&gt; filterClass) &#123;    Type type = klass.getGenericSuperclass(); // 获取父类Class类型，它包含了所配置的泛型类型    if (type == null || !(type instanceof ParameterizedType)) return null; // 判断是否是泛型类型    ParameterizedType parameterizedType = (ParameterizedType) type;    Type[] types = parameterizedType.getActualTypeArguments(); // 由于一个类可能不止配置了一个泛型，获取该对象所有泛型类型    for (Type t : types) &#123;        Class&lt;T&gt; tClass = (Class&lt;T&gt;) t;        if (filterClass.isAssignableFrom(tClass)) &#123; // 通过filterClass找到需要的目标类型            return tClass;        &#125;    &#125;    return null;&#125;\n2. 使用也非常简单，精简代码如下所示，4步配置就实现了MVP\n\n首先定义契约（Contract），定义View、Model、Presenter的接口，并且都需要继承自XContract\n创建Model实现类\n创建Presenter实现类继承XBasePresenter，泛型中关联View接口和Model实现类\n创建View实现类继承XBaseActivity或其子类，泛型中关联Presenter实现类\n\n12345678910111213141516171819// 契约public interface HomeContract &#123;    interface Presenter extends XContract.Presenter&#123;&#125;    interface View extends XContract.View&#123;&#125;    interface Model extends XContract.Model &#123;&#125;&#125;// M层实现public class HomeModel implements HomeContract.Model &#123;&#125;// P层实现public class HomePresenter  extends XBasePresenter&lt;HomeContract.View, HomeModel&gt;  implements HomeContract.Presenter &#123;&#125;// V层实现public class HomeActivity  extends XBaseActivity&lt;HomePresenter&gt;  implements HomeContract.View &#123;&#125;\n3. 最初XMVP框架做出时写的一篇文章 封了一个Android MVP框架，就叫XMVP吧！\n\n\n就这样，第一阶段宣告完毕，然后就是优化和修复一些bug，当然上面的getGenericClass这个方法也是后期优化过的结果。\n\n想偷懒了就开发了MVPManager插件，快速生成XMVP代码也就是XMVP框架开发出来也就1个月之内的事情吧！这时感觉写契约（Contract），写XMVP各个实现类，都是重复的劳动力，每一个新的界面就得去创建这么些文件太过辛苦。结果虽然变得有条理有模块，但是工作量有些重复和增加，有些时候配置泛型忘了还需要看之前是怎么配置的。\n当时其实也有创建MVP文件的插件之类的东西，但是不符合XMVP的实情，泛型还是得自己动手，于是决心自己写一个intellij插件，当然在AS中也能使用。\n创建MVP代码截图，这是最新的创建代码界面的截图\n在1.0的基础上，增加了可将同一个模块放一个包中或将MVP分在对应的包中的选项；增加了可以不是XMVP框架的情况下使用\n\n\n这是一张动态图，是一张旧版本的演示图。只需要和上面的截图结合来看一下哦\n最后还有个逆向增加或删除XMVP契约中定义方法的功能\n会同时更新实现类的方法，本人是写出这个功能，但几乎不用的啦\n\n\n刚刚开发出来MVPManager的时候，我也写了篇文章介绍 这个AS插件能帮你快速管理MVP\n\n就这样，第二阶段结束了。其主要目的就是为了解决MVP重复逻辑的代码量问题\n\n实践中的更新在不断的实践运用中也发现了很多没有考虑到或者忽略的问题，其中最映像深刻的不过于有次上线应用的时候，混淆居然会导致无法创建Presenter熬夜找了很久。\n还有就是忽略了Fragment有app包和v4包两个地方，框架中只写了一个，考虑的都比较片面。\n只有在实践中才能真正的考验，一直以来大概就我和少数的小伙伴在使用。虽然用的比较少，但是写出来后就要对它负责嘛！\n使用中的一些个人技巧1. 很多时候，Activity和Presenter，更或者Model都有共用的地方，此时我们需要作出提取抽象。于是我们就需要继承XBaseActivity、XBaseFragment、XBasePresenter再做一层抽象，这样如果以后不想用XMVP框架有更好的选择也更好替换哈。如下所示：\n\nBaseActivity.java\n\n1234567public abstract class BaseActivity&lt;T extends XBasePresenter&gt; extends XBaseActivity&lt;T&gt; &#123;  @Override  public void onInitCircle() &#123;    super.onInitCircle();    ButterKnife.bind(this);  &#125;&#125;\n\nBasePresenter.java\n\n123456789101112public class BasePresenter&lt;T extends XContract.View, E extends XContract.Model&gt; extends XBasePresenter&lt;T, E&gt; &#123;    protected CompositeDisposable mCompositeDisposable;    @Override    public void end() &#123;        super.end();        if (mCompositeDisposable != null) &#123;            mCompositeDisposable.clear();            mCompositeDisposable = null;        &#125;    &#125;&#125;\n向上面这样，我们通过一个中间层，处理一些我们需要统一调用的或处理的一些东西\n2. 对于Presenter回调Model处理后返回的数据监听，我们可以定义一个通用监听接口，如下：\n1234public interface GenericListener&lt;T&gt; &#123;    void success(T t);    void error(int code, String err);&#125;\n\n并且，我们可以对这个接口进行实现，我们可以统一对错误信息做些提示或处理\n\n1234567891011public abstract class GenericListenerImp&lt;T&gt; implements GenericListener&lt;T&gt; &#123;  public GenericListenerImp(/*可以传入进来base view或base presenter，如果有错误可以调用对应方法统一处理*/) &#123;  &#125;  @Override  public void error(int code, String err) &#123;    // 对错误做出统一处理  &#125;&#125;\n3. 我们最常用的就是刷新加载列表了，几乎所有app中都需要，并且在同一个应用中的加载逻辑都是一样的，于是我们可以将其抽象出来，使用的时候会非常方便。\n\n首先定义一个基础刷新契约，每一个有刷新的view的接口都直接从这里继承\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface BaseRefreshContract &#123;    interface Presenter extends XContract.Presenter &#123;        /**         * 请求数据         */        void requestLoadListData(int page);        /**         * 请求更新列表数据         */        void requestUpdateListData();    &#125;    interface View &lt;X&gt; extends XContract.View &#123;        /**         * 更新列表成功         */        void updateListSuccess(List&lt;X&gt; datas, boolean isEnd);        /**         * 更新失败         */        void updateListFail(String err);        /**         * 加载数据成功         */        void loadListDataSuccess(List&lt;X&gt; datas, int currentPage, boolean isEnd);        /**         * 加载数据失败         * @param err         */        void loadListDataFail(String err);        /**         * 数据已经被加载完         */        void loadListDateOver();    &#125;&#125;\n\n然后抽象View，这里以Activity为例，Fragment一致。我使用了SwipeRefreshLayout作为刷新，BaseRecyclerViewAdapterHelper处理填充数据和加载数据\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public abstract class BaseRefreshActivity&lt;E ,X extends BaseQuickAdapter&lt;E, BaseViewHolder&gt;, T extends XBasePresenter&gt; extends BaseActivity&lt;T&gt; implements        BaseRefreshContract.View&lt;E&gt;,        BaseQuickAdapter.RequestLoadMoreListener,        SwipeRefreshLayout.OnRefreshListener &#123;    protected int currentPage;//当前的页面    protected X mAdapter;    protected boolean isEnd;    protected SwipeRefreshLayout swipeLayout;    protected RecyclerView mRecyclerView;    @Override    public void onInitCircle() &#123;        super.onInitCircle();        mAdapter = getAdapter();        mRecyclerView = getRecyclerView();        swipeLayout = getSwipeLayout();        swipeLayout.setOnRefreshListener(this);        mAdapter.setOnLoadMoreListener(this, mRecyclerView);        mRecyclerView.setAdapter(mAdapter);    &#125;    protected abstract X getAdapter();    protected abstract SwipeRefreshLayout getSwipeLayout();    protected abstract RecyclerView getRecyclerView();    /**     * 更新列表成功     */    @Override    public void updateListSuccess(List&lt;E&gt; datas, boolean isEnd) &#123;        this.isEnd = isEnd;        currentPage = 1;        mAdapter.setNewData(datas);        swipeLayout.setRefreshing(false);        if (isEnd) &#123;            loadListDateOver();        &#125; else &#123;            mAdapter.setEnableLoadMore(true);            mAdapter.loadMoreComplete();        &#125;    &#125;    /**     * 更新失败     */    @Override    public void updateListFail(String err) &#123;        swipeLayout.setRefreshing(false);        mAdapter.setEnableLoadMore(true);        ToastUtil.getInstance().showLongT(err);    &#125;    /**     * 加载数据成功     */    @Override    public void loadListDataSuccess(List&lt;E&gt; datas, int currentPage, boolean isEnd) &#123;        this.currentPage = currentPage;        this.isEnd = isEnd;        mAdapter.addData(datas);        swipeLayout.setEnabled(true);        mAdapter.loadMoreComplete();    &#125;    /**     * 加载数据失败     *     * @param err     */    @Override    public void loadListDataFail(String err) &#123;        swipeLayout.setEnabled(true);        mAdapter.loadMoreFail();        ToastUtil.getInstance().showLongT(err);    &#125;    /**     * 数据已经被加载完     */    @Override    public void loadListDateOver() &#123;        mAdapter.loadMoreEnd();    &#125;    @Override    public void onRefresh() &#123;        if (!swipeLayout.isRefreshing())        &#123;            swipeLayout.setRefreshing(true);        &#125;        getPresenter().requestUpdateListData();        mAdapter.setEnableLoadMore(false);    &#125;    @Override    public void onLoadMoreRequested() &#123;        if (isEnd) &#123;            loadListDateOver();            return;        &#125;        swipeLayout.setEnabled(false);        getPresenter().requestLoadListData(++currentPage);    &#125;    protected BaseRefreshContract.Presenter getPresenter() &#123;        if (presenter instanceof BaseRefreshContract.Presenter) &#123;            return  (BaseRefreshContract.Presenter) presenter;        &#125; else &#123;            throw new RuntimeException(\"presenter please extends BaseRefreshContract.Presenter\");        &#125;    &#125;&#125;\n\n使用：定义一个列表页面的契约\n\n1234567891011public interface ArticleDetailContract &#123;    interface View extends BaseRefreshContract.View&lt;CircleMsgEntity.CommentBean&gt; &#123;    &#125;    interface Presenter extends BaseRefreshContract.Presenter &#123;    &#125;    interface Model extends XContract.Model &#123;      void catArticleDetails(int articleId, int page, CompositeDisposable cd, NetRequestListener&lt;Result&lt;CircleMsgEntity&gt;&gt; listener);    &#125;&#125;\n\n使用：View实现层，由于这是一个公司项目中的类，省略的所有的无关代码CircleMsgEntity.CommentBean 是一个Adapter(ArticleCommentAdapter)填充的实体类ArticleCommentAdapter 是一个继承BaseRecyclerViewAdapterHelper框架中的BaseQuickAdapter的类，并且该类是这样的：public class ArticleCommentAdapter extends BaseQuickAdapter&lt;CircleMsgEntity.CommentBean, BaseViewHolder&gt; 必须保证Activity第一个泛型和Adapter的第一个泛型类型一致\n\n1234567891011121314151617181920212223242526272829303132333435public class ArticleDetailActivity extends BaseRefreshActivity&lt;CircleMsgEntity.CommentBean, ArticleCommentAdapter, ArticleDetailPresenter&gt; implements ArticleDetailContract.View &#123;    @BindView(R.id.recycler)    RecyclerView recycler;    @BindView(R.id.refresh)    SwipeRefreshLayout refresh;    @Override    public void onInitCircle() &#123;        super.onInitCircle();        onRefresh();    &#125;    @Override    public int layoutId() &#123;        return R.layout.activity_article_detail;    &#125;    @Override    protected ArticleCommentAdapter getAdapter() &#123;        return new ArticleCommentAdapter(ArticleCommentAdapter.TYPE_NORMAL);    &#125;    @Override    protected SwipeRefreshLayout getSwipeLayout() &#123;        refresh.setColorSchemeResources(R.color.yellow);        return refresh;    &#125;    @Override    protected RecyclerView getRecyclerView() &#123;        recycler.setLayoutManager(new LinearLayoutManager(this));        return recycler;    &#125;&#125;\n\n使用： Presenter实现层\n\n123456789101112131415161718192021222324252627282930313233343536373839404142public class ArticleDetailPresenter extends BasePresenter&lt;ArticleDetailContract.View,ArticleDetailModel&gt; implements ArticleDetailContract.Presenter &#123;    @Override    public void start() &#123;        super.start();        mCompositeDisposable = new CompositeDisposable();    &#125;    @Override    public void requestLoadListData(int page) &#123;        model.catArticleDetails(view.getArticleId(), page, mCompositeDisposable, new NetRequestListener&lt;Result&lt;CircleMsgEntity&gt;&gt;() &#123;            @Override            public void success(Result&lt;CircleMsgEntity&gt; circleMsgEntityResult) &#123;                ResultListBean&lt;List&lt;CircleMsgEntity.CommentBean&gt;&gt; resultListBean = circleMsgEntityResult.getData().getCommentList();                view.loadListDataSuccess(resultListBean.getList(), resultListBean.getPage(), resultListBean.getPage() &gt;= resultListBean.getPagecount());            &#125;            @Override            public void error(String err) &#123;                view.loadListDataFail(err);            &#125;        &#125;);    &#125;    @Override    public void requestUpdateListData() &#123;        model.catArticleDetails(view.getArticleId(), 1, mCompositeDisposable, new NetRequestListener&lt;Result&lt;CircleMsgEntity&gt;&gt;() &#123;            @Override            public void success(Result&lt;CircleMsgEntity&gt; circleMsgEntityResult) &#123;                ResultListBean&lt;List&lt;CircleMsgEntity.CommentBean&gt;&gt; resultListBean = circleMsgEntityResult.getData().getCommentList();                view.updateListSuccess(resultListBean.getList(), resultListBean.getPage() &gt;= resultListBean.getPagecount());                view.displayArticleDetail(circleMsgEntityResult.getData());            &#125;            @Override            public void error(String err) &#123;                view.updateListFail(err);            &#125;        &#125;);    &#125;&#125;\n\nModel层，去请求列表数据\n\n1234567public class ArticleDetailModel implements ArticleDetailContract.Model &#123;    @Override    public void catArticleDetails(int articleId, int page, CompositeDisposable cd, NetRequestListener&lt;Result&lt;CircleMsgEntity&gt;&gt; listener) &#123;        Observer&lt;Result&lt;CircleMsgEntity&gt;&gt; observer = ModelHelper.getObserver(cd, listener, true); // 对rxjava返回的数据进行统一处理        Http.getInstance().getArticleDetails(articleId, page, observer);    &#125;&#125;\n这样，我们就可以不断的复用BaseRefreshActivity、ArticleDetailContract来让刷新加载统一，当然在您实际的使用过程中肯定还需要调整。这里只给我了我自己的一些思路和实现方式。\n\n如果我们需要其他的抽象时，只需要注意像刷新一样将泛型继承关系标准上就可以啦。如果Model也可以抽取出来，复用时只需要继承抽象出来的Model。\n\n目前目前XMVP框架已更新到1.2.2，废弃了一些以前的方法（当然现在还能用）。添加了更多View层的辅助方法，为了偷个懒，就直接展示新增的方法代码啦！\n\n基本周期\n\n1234567891011121314151617181920212223242526272829303132333435363738/** * author: xujiaji * created on: 2018/9/4 10:57 * description: 定义View相关周期 &lt;br /&gt; Define View related Cycle */public interface XViewCycle &#123;    /**     * 在 super &#123;@link android.app.Activity#onCreate(Bundle)&#125;之前被调用              &lt;br /&gt;  will be called before super class &#123;@link android.app.Activity#onCreate(Bundle)&#125; called     */    void onBeforeCreateCircle();    /**     * 在 super &#123;@link android.app.Activity#onCreate(Bundle)&#125;之前被调用，并且有Bundle &lt;br /&gt;  will be called before super class &#123;@link android.app.Activity#onCreate(Bundle)&#125; called     * @param savedInstanceState 该参数不可能为null                                  &lt;br /&gt; this parameter cannot be null     */    void onBundleHandle(@NonNull Bundle savedInstanceState);    /**     * 获取布局的id                                &lt;br /&gt; get layout id     * 在 &#123;@link #onBeforeCreateCircle &#125;之后被调用 &lt;br /&gt; will be called after &#123;@link #onBeforeCreateCircle &#125; called     * @return xml布局id                         &lt;br /&gt; xml layout id     */    int layoutId();    /**     *  在这里面进行初始化                    &lt;br /&gt; initialize here     *  在 &#123;@link #layoutId()&#125; 之后被调用   &lt;br /&gt; will be called after &#123;@link #layoutId()&#125; called     */    void onInitCircle();    /**     * 这里面写监听事件                       &lt;br /&gt; write listens event here     * 在 &#123;@link #onInitCircle()&#125; 之后被调用 &lt;br /&gt; will be called after &#123;@link #onInitCircle()&#125; called     */    void onListenerCircle();&#125;\n\nActiviy中\n\n1234567891011/** * author: xujiaji * created on: 2018/9/11 15:05 * description: 定义Activity View相关周期 &lt;br /&gt; Define Activity View related Cycle */public interface XActivityCycle extends XViewCycle &#123;    /**     * 处理上个页面传递过来的数据 &lt;br /&gt; Handle the data passed from the previous page     */    void onIntentHandle(@NonNull Intent intent);&#125;\n\nFragment中\n\n12345678910111213141516171819202122232425262728293031323334353637383940/** * author: xujiaji * created on: 2018/9/4 10:57 * description: 定义Fragment View相关周期 &lt;br /&gt; Define Fragment View related Cycle */public interface XFragViewCycle extends XViewCycle &#123;    /**     * 处理&#123;@link Fragment#getArguments()&#125; 的值，如果有才会调用  &lt;br /&gt; Handle the value of &#123;@link Fragment#getArguments()&#125; , if it is there, it will be called     * @param bundle     */    void onArgumentsHandle(@NonNull Bundle bundle);    void onVisible();    void onInvisible();    void onLazyLoad();    /**     * 忽略&#123;@link #isFirstLoad() &#125;的值，强制刷新数据，但仍要满足 &#123;@link #isFragmentVisible()&#125; &amp;&amp; &#123;@link #isPrepared()&#125; &lt;br /&gt;     * Ignore the value of &#123;@link #isFirstLoad() &#125; to force refresh data, but still satisfy &#123;@link #isFragmentVisible()&#125; &amp;&amp; &#123;@link #isPrepared()&#125;     */    void setForceLoad(boolean forceLoad);    boolean isForceLoad();    boolean isPrepared();    boolean isFirstLoad();    boolean isFragmentVisible();    /**     * 是否是在ViewPager中，默认为true     * whether in ViewPager, default is true     * @return     */    boolean isInViewPager();&#125;\n可以看到Fragment中定义的方法是比较多的，因为由于懒加载比较常用，新增了懒加载。我们如果需要加载数据，可直接在onLazyLoad()方法中进行。\n\n需要注意：如果Fragment不是和ViewPager结合，需要将isInViewPager返回false，默认返回的true。如果不这样，可能会导致通过FragmentManger提交的Fragment无法调用到onLazyLoad方法。\n\n最后通过写这个框架学到了思考很多东西，并且后期也会继续更新，我自己写项目中也在使用。可能有些地方考虑的不充足，谢谢大家也可以提建议。当然这只是MVP的一种实现思路，其他的还是有很多的，这里大家也许都有一定了解哈。\nXMVP地址：https://github.com/xujiaji/XMVP\n欢迎大家Star、Fork、PR (〃’▽’〃)\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/xmvp/banner.png","plink":"https://blog.xujiaji.com/post/xmvp-framework/"},{"title":"iOS Objective-C Learn Note","date":"2018-09-05T10:11:24.000Z","author":"xujiaji","updated":"2018-11-02T07:20:12.000Z","content":"源代码文件扩展名对比\n\n\n\n头文件\n实现文件\n\n\n\n\nc语言\n.h\n.c\n\n\nc++语言\n.h\n.cpp\n\n\noc语言\n.h\n.m\n\n\noc&amp;c++\n.h\n.mm\n\n\n\n类的定义\n定义一个SimpleClass类\n\n123@interface SimpleClass: NSObject@end\n类的属性申明\n通过@property\n\n123456789101112@property NSString *firstName;@property NSString *lastName;//指针类型，是一个对象@property NSNumber *yearOfBirth;//基础类型，是一个值类型@property int yearOfBirth;//一个只读的属性@property (readonly) NSString *firstName;\n减号方法和加号方法（本质就是一个函数）\n减号方法（普通方法又称对象方法）\n加号方法（类方法，又称静态方法）\n\n完整的例子\n接口XYZPerson.h\n\n123@interface XYZPerson: NSObject-(void)sayHello;@end\n\n实现XYZPerson.m\n\n1234567#import \"XYZPerson.h\"@implementation XYZPerson-(void)sayHello &#123;  // 加了@符号，表示是OC类型的字符串。不加表示是纯C语言的字符数组  NSLog(@\"Hello, World!\");&#125;@end\n简单的程序12345678#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        // insert code here...        NSLog(@\"Hello, World!\");    &#125;    return 0;&#125;\n基本数据类型\n\n\n类型\n进制位\n例子\n\n\n\n\nint\n32位\nint a = 0;\n\n\nfloat\n32位\nfloat f = 1.0;\n\n\ndouble\n64位\ndouble num;\n\n\nchar\n8位\nchar c = ‘A’;\n\n\n\n其他类型\n\n\n\nNSString\n@”hello world”\n\n\n“hello world”\nC语言字符串类型\n\n\n\n限定词\n\n\n限定词\n例子\n描述\n\n\n\n\nlong\nlong a;\n//完整写法为：long int a;其实现在int已经32位了就相当于int a;\n\n\nlong long\nlong long int a;\n\n\n\nshort\nshort int a; short a;\n// 16位整型\n\n\nunsigned\nunsigned int a;\n// 无符号\n\n\nsigned\nsigned int a;\n// 有符号\n\n\n\n算术表达式与运算符\n\n\n名称\n表示\n\n\n\n\n赋值\n=\n\n\n一元运算符\n++ --\n\n\n二元运算符\n+ - * / %\n\n\n三目运算符\n2 &gt; 3 ? YES : NO\n\n\n\nif语句（非0就是真）\n\n\n\n值\n\n\n\n\n真\nYES 所有非0的值\n\n\n假\nNO 0\n\n\n\n\n简单例子\n\n1234567891011121314#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        int a = 1;        int b = 2;        if (a &gt; b) &#123;            NSLog(@\"这句话是真的\");        &#125; else &#123;            NSLog(@\"这句话是假的 %hhd\", NO);        &#125;    &#125;    return 0;&#125;\ngoto 跳转语句，跳转的前面定义的标签处123456789101112131415161718192021222324252627282930#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        int i = 0;    // 定义标签a    a:        i ++;        NSLog(@\"i的值为%d\", i);//        if(i &lt; 5) goto a;        if (i &lt; 5) &#123;            goto a; // 跳转到标签a        &#125; else &#123;            goto b; // 跳转到标签b        &#125;        NSLog(@\"============\"); // 由于上面直接跳转到了b标签，因此该语句得不到执行    b:&#123;        NSLog(@\"跳到b了\");    &#125;    &#125;    return 0;&#125;// 输出：// 2018-09-05 22:23:53.800654+0800 les1[971:104767] i的值为1// 2018-09-05 22:23:53.800827+0800 les1[971:104767] i的值为2// 2018-09-05 22:23:53.800858+0800 les1[971:104767] i的值为3// 2018-09-05 22:23:53.800876+0800 les1[971:104767] i的值为4// 2018-09-05 22:23:53.800889+0800 les1[971:104767] i的值为5// 2018-09-05 22:23:53.800902+0800 les1[971:104767] 跳到b了\nwhile 循环语句1234567891011        int i = 0;        while (i &lt; 5) &#123;            i++;            NSLog(@\"Hello world! i = %d\", i);        &#125;// 输出// Hello world! i = 1// Hello world! i = 2// Hello world! i = 3// Hello world! i = 4// Hello world! i = 5\ndo while 循环，至少执行一次123456do &#123;    NSLog(@\"hello!\");&#125; while (0)// 输出：// hello!\nfor 循环12345678910for (int i = 0; i &lt; 5; i++) &#123;    NSLog(@\"i = %d\", i);&#125;// 输出// i = 1// i = 2// i = 3// i = 4// i = 5\n循环控制break、continue\nbreak： 终止循环\ncontinue: 跳过当前循环\n\nswitch分支语句123456789101112131415161718int i = 2;switch (i) &#123;    case 0:        NSLog(@\"i = 0\");        break;    case 1:        NSLog(@\"i = 1\");        break;    case 2:        NSLog(@\"i = 2\");        break;    case 3:        NSLog(@\"i = 3\");        break;    default:        NSLog(@\"NO\");        break;&#125;\n函数的基本写法12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;/* * 求面积的函数 * 传入值，计算并返回面积值 */double area(double a, double b) &#123;    return a * b;&#125;// 无参无返回的函数void show() &#123;    NSLog(@\"this is a test!\");&#125;int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        NSLog(@\"value = %f\", area(5.0, 3.0));        show();    &#125;    return 0;&#125;\nmain函数中的默认参数123456789int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        NSLog(@\"argc = %d\", argc);        for (int i = 0; i &lt; argc; i++) &#123;            NSLog(@\"%s\", argv[i]);        &#125;    &#125;    return 0;&#125;\n\n终端运行\n\n1234567891011121314$ ls -ltotal 56-rwxr-xr-x@ 1 username  staff  27984  9  5 23:21 les1$ ./les12018-09-05 23:28:27.313 les1[1369:176584] argc = 12018-09-05 23:28:27.313 les1[1369:176584] ./les1$ ./les1 -a -b -c2018-09-05 23:28:39.782 les1[1370:176617] argc = 42018-09-05 23:28:39.782 les1[1370:176617] ./les12018-09-05 23:28:39.782 les1[1370:176617] -a2018-09-05 23:28:39.782 les1[1370:176617] -b2018-09-05 23:28:39.782 les1[1370:176617] -c\n创建类\n头文件People.h\n\n12345#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject@end\n\n实现文件People.m\n\n12345#import \"People.h\"@implementation People@end\n实例化对象\n导入类的头文件\n[]中写函数的调用\nalloc 函数为对象分配内存空间\ninit 函数进行初始化操作\n\n12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import \"People.h\" // 导入类头文件int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        // 实例化对象        // [] 函数的调用        // [类名 方法名]        // [对象名 方法名]        // alloc - 为对象分配内存空间        // init - 进行初始化操作        People * p1 = [[People alloc] init];        People * p2 = [[People alloc] init];      &#125;    return 0;&#125;\n属性和成员变量\n类内使用成员变量、类外使用属性\n定义成员变量，此时外部无法访问。如果要让外部可访问需要加上（不建议）：@public\n属性是为了让类外可以访问成员变量\n属性就是成员变量的外部接口\n可将属性拆开，写成get和set两部分\n\n\nPeople.h\n\n123456789101112131415161718// 类内使用成员变量、类外使用属性#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject&#123;    // 定义成员变量，此时外部无法访问。如果要让外部可访问需要加上：@public    // @public    // NSString * _peopleName; // 如果定义了该成员变量的属性，那么可以不写。编译器会为我们自动生成一个叫_peopleName的成员变量    int _peopleAge;&#125;// 属性是为了让类外可以访问成员变量// 属性就是成员变量的外部接口@property(nonatomic, strong)NSString * peopleName;// 将属性拆开- (void) setAge:(int) age;- (int) getAge;@end\n\nPeople.m\n\n123456789101112131415161718192021222324#import \"People.h\"&#123;   int _peopleSex; // 也可以将成员变量定义在m文件中，没什么区别&#125;@implementation People- (instancetype)init&#123;    self = [super init];    if (self) &#123;        _peopleName = @\"张三\";    &#125;    return self;&#125;- (void) setAge:(int) age&#123;    _peopleAge = age;&#125;- (int) getAge&#123;    return _peopleAge;&#125;@end\n\nmain.m\n\n123456789101112#import &lt;Foundation/Foundation.h&gt;#import \"People.h\"int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        People * p1 = [[People alloc] init];        p1.peopleName = @\"李四\"; // 通过属性设置名字        NSLog(@\"p1 name %@\", [p1 peopleName]); // 通过属性获取名字        [p1 setAge:23]; // 通过函数设置年龄        NSLog(@\"p1 age %d\", [p1 getAge]); // 通过函数获取年龄    &#125;    return 0;&#125;\n函数\n调用方法是用中括号\n-、+ 方法的类型（减号代表对象方法，加号代表类方法）\n加号方法和减号方法之间的相互调用逻辑和java一样\n方法名：去掉方法类型和参数类型就是方法名\n(int) 返回值类型int\n:(int) x     代表方法有参数，参数类型int，参数名x\n\n\nPeople.h\n\n12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject/* 申明方法 -、+ 方法的类型（减号代表对象方法，加号代表类方法） 加号方法和减号方法之间的相互调用逻辑和java一样(int) 返回值类型 :(int) x     代表方法有参数，参数类型int，参数名x 方法名：去掉方法类型和参数类型就是方法名 */- (int) report;+ (void) report1;- (int) showWithA:(int) a;- (int) showWithA:(int) a andB:(int) b;@end\n\nPeople.m\n\n1234567891011121314151617181920212223242526272829#import \"People.h\"@implementation People&#123;    NSString *_name;&#125;static NSString *_name1;- (int)report&#123;    _name = @\"abc\";    NSLog(@\"-号方法:report\");    return 22;&#125;+ (void)report1&#123;//     _name = @\"abc\"; 编译错误，+号方法相当于java中的静态方法    _name1 = @\"abc\";//静态方法可调用静态变量    NSLog(@\"+号方法：report1\");&#125;- (int) showWithA:(int) a&#123;    return a;&#125;- (int) showWithA:(int) a andB:(int) b&#123;    return a + b;&#125;@end\n\nmain.m\n\n12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import \"People.h\"int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        // [] 调用方法        People *p1 = [[People alloc] init];//        NSLog(@\"return value %d\", [p1 report]);//        [People report1];        int a1 = [p1 showWithA:10];        NSLog(@\"a1 = %d\", a1);        int a2 = [p1 showWithA:10 andB:20];        NSLog(@\"a2 = %d\", a2);    &#125;    return 0;&#125;\n初始化函数\nPeople.h\n\n1234567891011#import &lt;Foundation/Foundation.h&gt;@interface People : NSObject// 初始化方法//- (id) init;//任意类型//虽然上面的也可以但是推荐下面- (instancetype) init; // 当前类型，当前是People类型// 自定义初始化方法- (instancetype) initPeople:(NSString *) name age:(int) age;@end\n\nPeople.m\n\n1234567891011121314151617181920212223242526272829#import \"People.h\"@implementation People&#123;    int _age;    int _name;&#125;// 重写初始化方法- (instancetype)init&#123;    self = [super init];    if (self) &#123;        _age = 23;        NSLog(@\"age = %d\", _age);    &#125;    return self;&#125;- (instancetype)initPeople:(NSString *)name age:(int)age&#123;    self = [super init];    if (self) &#123;        _age = age;        _name = name;        NSLog(@\"age = %d, name = %@\", _age, name);    &#125;    return self;&#125;@end\n\nmain.m\n\n12345678910#import &lt;Foundation/Foundation.h&gt;#import \"People.h\"int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        People *p1 = [[People alloc] init];        People * p2 = [[People alloc] initPeople:@\"xu\" age:24];    &#125;    return 0;&#125;\n\n输出\n\n12age = 23age = 24, name = xu\n封装\n访问修饰符\n\n\n\n\n声明\n作用\n\n\n\n\n@public\n公有的， 在类中和类外都可以使用并且可以被继承\n\n\n@private\n私有的，在类中可以使用，类外无法调用，不可以被继承\n\n\n@protected\n受保护的（默认），在类中可以使用，类外无法调用，但是可以被继承\n\n\n@package\n框架权限，在框架内相当于受保护，在框架外相当于私有\n\n\n\n\n方法是没有访问修饰符的同c语言一样，如果不想让外部访问，去掉.h中的方法定义就可以了。\n\n\nMyClass.h\n\n12345678910#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject&#123;    @public    int _classInt;&#125;@property(nonatomic, strong) NSString * className;-(void) report;@end\n\nMyClass.m\n\n123456789#import \"MyClass.h\"@implementation MyClass- (void)report&#123;    NSLog(@\"class name = %@\", _className);    NSLog(@\"class name = %d\", _classInt);&#125;@end\n\nmain.m\n\n12345678910111213#import &lt;Foundation/Foundation.h&gt;#import \"MyClass.h\"int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        MyClass *c = [[MyClass alloc] init];        c.className = @\"My Class\";        // 使用指向来调用类中的公有成员变量        c-&gt;_classInt = 22;        [c report];    &#125;ß    return 0;&#125;\n继承\ninterface 时候 冒号 代表继承\n\n\n父类\n\n123456789101112131415161718#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject&#123;    int _claseInt;&#125;@property(nonatomic, strong) NSString * name;- (void) report;@end#import \"MyClass.h\"@implementation MyClass- (void)report&#123;    _claseInt = 23;    NSLog(@\"name = %@, value = %d\", _name, _claseInt);&#125;@end\n\n子类\n\n123456789101112131415#import \"MyClass.h\"// interface 时候 冒号 代表继承@interface MySubClass : MyClass-(void) show;@end#import \"MySubClass.h\"@implementation MySubClass- (void)show&#123;    _claseInt = 100;    [self report];&#125;@end\n\nmain.m\n\n12345678910111213141516#import &lt;Foundation/Foundation.h&gt;#import \"MyClass.h\"#import \"MySubClass.h\"int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        MyClass *c = [[MyClass alloc] init];        c.name = @\"xu\";        [c report];        MySubClass *sc = [[MySubClass alloc] init];        sc.name = @\"xu\";//        [sc report];        [sc show];    &#125;    return 0;&#125;\n\n输出\n\n12name = xu, value = 23name = xu, value = 23\n多态\n父类Printer.h  Printer.m\n\n12345678910111213#import &lt;Foundation/Foundation.h&gt;@interface Printer : NSObject- (void) print;@end#import \"Printer.h\"@implementation Printer- (void)print&#123;    NSLog(@\"我是一个打印机\");&#125;@end\n\n子类ColorPrinter.h  ColorPrinter.m\n\n12345678910111213#import \"Printer.h\"@interface ColorPrinter : Printer@end#import \"ColorPrinter.h\"@implementation ColorPrinter- (void)print&#123;    [super print]; // 子类中调用父类的方法    NSLog(@\"我是一个彩色打印机\");&#125;@end\n\nmain.m\n\n1234567891011121314#import &lt;Foundation/Foundation.h&gt;#import \"ColorPrinter.h\"int main(int argc, const char * argv[]) &#123;    @autoreleasepool &#123;        ColorPrinter *cp = [[ColorPrinter alloc] init];        [cp print];        // 父类可以引用子类型        Printer * p = [[ColorPrinter alloc] init];        [p print];    &#125;    return 0;&#125;\n\n输出\n\n1234我是一个打印机我是一个彩色打印机我是一个打印机我是一个彩色打印机\n","plink":"https://blog.xujiaji.com/post/iOS-Objective-C-Learn/"},{"title":"Git Commit Standard","date":"2018-09-05T02:21:44.000Z","author":"xujiaji","updated":"2019-04-08T06:55:24.990Z","content":"记录一下Git的提交规范，方便以后查阅\n\n提交命令\ngit commit -m &quot;提交修改信息&quot;，这样这只能有一行信息\ngit commit，会进入vi文本编辑器，可写多行。\n\n提交信息的格式\n每次提交信息都包括三个部分：Header、Body和Footer。其中，Header 是必需的，Body 和 Footer 可以省略。\n\n12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt;\n\n文字描述\n\n123456789# 标题行：50个字符以内，描述主要变更内容## 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:## * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等# * 他如何解决这个问题? 具体描述解决问题的步骤# * 是否存在副作用、风险?## 尾部：如果需要的化可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。\n&lt;type&gt;\n\n\nValue\nDescription\n\n\n\n\nfeat\nfeature新功能\n\n\nfix\n修复bug\n\n\ndoc\n仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等\n\n\nstyle\n代码格式改变，不改变代码逻辑\n\n\nrefactor\n代码重构，没有加新功能或者修复bug\n\n\nperf\n优化相关，比如提升性能、体验\n\n\ntest\n测试用例，包括单元测试、集成测试等\n\n\nchore\n改变构建流程、或者增加依赖库、工具等\n\n\nrevert\n回滚到上一个版本\n\n\n\n&lt;scope&gt;\n\n\nValue\nDescription\n\n\n\n\nall\n表示影响面大 ，如修改了网络框架  会对真个程序产生影响\n\n\nloation\n表示影响小，某个小小的功能\n\n\nmodule\n表示会影响某个模块 如登录模块、首页模块 、用户管理模块等等\n\n\n\n&lt;subject&gt;\nsubject是 commit 目的的简短描述，不超过50个字符。\n以动词开头，第一个字母小写，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写\n结尾不加句号”.”\n\n&lt;body&gt;对本次 commit 的详细描述，可以分成多行。\n&lt;footer&gt;\n并联Issue，本次提交如果和摸个issue有关系则需要写上这个，格式如下：\n1Issue #1, #2, #3\n\n关闭 Issue，如果当前提交信息解决了某个issue，那么可以在 Footer 部分关闭这个 issue，关闭的格式如下：\n1Close #1, #2, #3\n\n\n完整例子12345678910feat(all): add loginadd login in project- qq login- weixin login- sina loginIssue #1, #2Close #1, #2\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/git/git_commit.jpg","plink":"https://blog.xujiaji.com/post/Git-Commit-Standard/"},{"title":"iOS用UISegmentedControl设计一个顶部分页导航-Swift（翻译文）","date":"2018-07-23T06:36:32.000Z","author":"xujiaji","updated":"2019-04-08T06:55:47.295Z","content":"\n原文：《Designing a Button Bar-Style UISegmentedControl in Swift》\n\n\n我正在做一个项目，项目里面我想用UISegmentedControl做一个简洁的“底部条形样式”的设计。它没有边框，所选下方有一个小长条，当你选择一个元素后他会相应的移动过去。我找到几个非常好的第三方库来处理这个问题，但是我在这些类库上遇到了一些麻烦，于是我尝试自己做。我以自动布局约束，以swift代码方式构建视图，并为了简单起见，将所有主题内联完成。\n准备开始我们在Swift playground中做这些事情，因此让我们从基本的东西开始，创建一个新的UIView并且添加一个带有3个片段的UISegmentedControl，另外需要注意，我构建约束的方式是假设所有片段长度想等的情况。如果不是的话，会导致底部长条在相应的位置上变得太宽或不够宽。\n1234567891011121314151617181920212223242526272829import UIKitimport PlaygroundSupport// 容器Viewlet view = UIView(frame: CGRect(x: 0, y: 0, width: 400, height: 100))view.backgroundColor = .whitelet segmentedControl = UISegmentedControl()// 添加片段segmentedControl.insertSegment(withTitle: \"One\", at: 0, animated: true)segmentedControl.insertSegment(withTitle: \"Two\", at: 1, animated: true)segmentedControl.insertSegment(withTitle: \"Three\", at: 2, animated: true)// 让第一个片段默认选中segmentedControl.selectedSegmentIndex = 0// 设置为false，我们才能使用自动布局约束segmentedControl.translatesAutoresizingMaskIntoConstraints = false// 添加UISegmentedControl到容器Viewview.addSubview(segmentedControl)// 约束到容器的顶部segmentedControl.topAnchor.constraint(equalTo: view.topAnchor).isActive = true// 限制为容器view的宽度segmentedControl.widthAnchor.constraint(equalTo: view.widthAnchor).isActive = true// 设置高度segmentedControl.heightAnchor.constraint(equalToConstant: 40).isActive = truePlaygroundPage.current.liveView = view\n此时实时窗口已经为我们展示了基本的UISegmentedControl。不要忘记将isActive属性附加到每个自动布局约束，其值为true，否则他们将不起作用。\n颜色、字体和边框Oh My！接下来，让我们删除掉backgroundColor和tintColor，删除后边框和已选择的片段背景颜色将会消失。123// 将下面的代码添加到 selectedSegmentIndex下面segmentedControl.backgroundColor = .clearsegmentedControl.tintColor = .clear\n如果你看实时窗口，我们删除了tintColor后，UISegmentedControl已经消失，现在没有颜色了。要恢复标签，让我们更改所选片段和未选片段的字体、文本颜色和大小。12345678910// 添加这些代码到 segmentedControl.tintColor = .clear 后segmentedControl.setTitleTextAttributes([    NSAttributedStringKey.font: UIFont(name: \"DINCondensed-Bold\", size: 18)!,    NSAttributedStringKey.foregroundColor: UIColor.lightGray    ], for: .normal)segmentedControl.setTitleTextAttributes([    NSAttributedStringKey.font : UIFont(name: \"DINCondensed-Bold\", size: 18)!,    NSAttributedStringKey.foregroundColor: UIColor.orange    ], for: .selected)\n到这儿差不多了！现在我们必须在所选段下方添加一个长条栏。\n为选定片段底部添加长条这个长条只是一个简单的UIView，然后将其backgroundColor与其所选片段字体的颜色相匹配。我们将选择的片段字体颜色和长条都设置为橙色。并且我们要为长条设置translatesAutoresizingMaskIntoConstraints为false。1234let buttonBar = UIView()// 设置为false，我们才能使用自动布局约束buttonBar.translatesAutoresizingMaskIntoConstraints = falsebuttonBar.backgroundColor = UIColor.orange\n接下来，将buttonBar作为子View添加到容器view中12// 添加到 view.addSubview(segmentedControl)之后view.addSubview(buttonBar)\n最终，我们需要给它个宽度、高度和位置，在segmentedControl之后添加这些约束12345678// 约束它的顶部位置在片段的底部位置buttonBar.topAnchor.constraint(equalTo: segmentedControl.bottomAnchor).isActive = true// 设置长条的高度buttonBar.heightAnchor.constraint(equalToConstant: 5).isActive = true// 约束它的左侧和片段的左侧重合buttonBar.leftAnchor.constraint(equalTo: segmentedControl.leftAnchor).isActive = true// 约束它的宽度 = 片段容器宽度 / 片段个数buttonBar.widthAnchor.constraint(equalTo: segmentedControl.widthAnchor, multiplier: 1 / CGFloat(segmentedControl.numberOfSegments)).isActive = true\n正如最后那条注释所说，我们需要长条的宽度为segmentedControl的宽度除以片段个个数。这保证了长条宽度将与单个片段的宽度完全匹配，同样这里是假设所有的段都是想等的宽度。初始视图现在已完成！最后一步，我们需要让长条随所选的片段移动。\n长条栏动画当所选片段发生改变时，segmentedControl需要调用一个函数来处理长条栏在x轴上的位置转换，使其跑到选择的片段下方。定义个Responder类，并添加方法，然后在segmentedControl变量上添加回调，segmentedControl的值改变时会触发。1234567891011// 在import声明下方class Responder: NSObject &#123;    @objc func segmentedControlValueChanged(_ sender: UISegmentedControl) &#123;    &#125;&#125;let responder = Responder()...// 在PlaygroundPage.current.liveView = view声明的上方segmentedControl.addTarget(responder, action: #selector(responder.segmentedControlValueChanged(_:)), for: UIControlEvents.valueChanged)\n一定要确保sender作为方法参数类型，因为我们需要在调用函数时访问它。最后让我们来完成最后一块拼图，buttonBar在x轴的移动，它将移动到被选中的片段下12345@objc func segmentedControlValueChanged(_ sender: UISegmentedControl) &#123;  UIView.animate(withDuration: 0.3) &#123;      buttonBar.frame.origin.x = (segmentedControl.frame.width / CGFloat(segmentedControl.numberOfSegments)) * CGFloat(segmentedControl.selectedSegmentIndex)  &#125;&#125;\n长条因该去的x轴位置 = (segmentedControl的宽度 / 片段个数) * 当前片段的下标\n瞧瞧！我们的动画按钮栏出来了\n结论我希望这篇文章所提供的信息，能作为你在看了许多类库或iOS应用后的一个DIY解决方案。你可以将这里的UISegmentedControl连接到UIPageViewController或UIScrollView作为分段内容直接移动的方式。你这可以在这里找到playgroud代码在Github Gist，祝您iOS开发顺利！\n\n\n补充说明：下面链接到的是我在练习的时候写的代码，供参考！\n\nhttps://github.com/xujiaji/Learn-iOS/blob/master/TabSegmentedControl.playground/Contents.swift\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/ios-uisegmented-design/display.gif","plink":"https://blog.xujiaji.com/post/ios-uisegmented-design/"},{"title":"iOS开发-零碎笔记","date":"2018-07-16T00:08:16.000Z","author":"xujiaji","updated":"2019-04-29T02:01:51.605Z","content":"记录一些iOS学习过程中的笔记\niOS开发-零碎笔记创建项目目录结构\nAppDelegate.swift:生命周期及变量的定义\nViewController.swift: MVC的C\nAssets.xcasset:放资源文件，如图片等\ninfo.plist：配置文件\nxxxTest: 单元测试\nProducts:生成的文件\nMain.storyboard: 视图\n\n快捷添加注释1option + command + /\n关闭软键盘\n关闭代码\n\n1textField.resignFirstResponder()\n\n关闭方式1：在Controller中重写touchesEnded()方法，然后在这里面关闭软件盘，意思是点击空白处关闭\n\n123override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;    name.resignFirstResponder()&#125;\n\n关闭方式2：点击下一步时，关闭软键盘；Controller实现UITextFieldDelegate协议；实现UITextFieldDelegate协议中的textFieldShouldReturn方法；\n\n1234func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123;    textField.resignFirstResponder()    return true&#125;\nUIDatePicker选择时间后计算年龄123456func calAge(by datePicker: UIDatePicker) -&gt; Int? &#123;    let gregorian = NSCalendar(calendarIdentifier: .gregorian)    let now = Date()    let components = gregorian?.components(NSCalendar.Unit.year, from: datePicker.date, to: now, options: NSCalendar.Options.init(rawValue: 0))    return components?.year&#125;\n页面跳转，传递数据有两个Controller：ViewController和GalleryViewController。从ViewController跳转到GalleryViewController。ViewController重写方法：prepare，该方法在页面跳转时会被调用，我们需要在里面判断是跳转到哪个页面。\n12345678910111213141516171819202122232425override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123;    // 需要给Segue取名    if segue.identifier == \"GoToGallery\" &#123;        let index = beautyPicker.selectedRow(inComponent: 0)        var imageName: String?        switch index &#123;        case 0:            imageName = \"fangbingbing\"        case 1:            imageName = \"libingbing\"        case 2:            imageName = \"wangfei\"        case 3:            imageName = \"yangmi\"        case 4:            imageName = \"zhouxu\"        default:            imageName = nil        &#125;        // 得到下一个页面的Controller        let vc = segue.destination as! GalleryViewController        vc.imageName = imageName    &#125;&#125;\n通过图片文件名设置图片1beautyImage.image = UIImage(named: imageName)\nunwind segue关闭页面关闭页面后，Controller可以获得上个页面传回来的值该方法写在前一个页面123@IBAction func closedPrePage(segue: UIStoryboardSegue) &#123;    print(\"closed\")&#125;\nTableView下移一个状态栏的高度解决\n方法一\n123if #available(iOS 11.0, *) &#123;    tableView.contentInsetAdjustmentBehavior = .never&#125;\n\n方法二，内容上部分区域向上偏移一个状态栏的高度\n1collectionView?.contentInset.top = -UIApplication.shared.statusBarFrame.height\n\n\nTableView 添加刷新1234567891011let refreshControl = UIRefreshControl()// 初始化刷新refreshControl.backgroundColor = UIColor.blue //设置刷新的背景颜色refreshControl.attributedTitle = NSAttributedString(string: \"刷新一下：\\(Data())\", attributes: [NSAttributedStringKey.foregroundColor: UIColor.white]) // 设置字体颜色refreshControl.tintColor = UIColor.green // 加载菊花颜色refreshControl.tintAdjustmentMode = .dimmed // 色彩调整模式refreshControl.addTarget(self, action: #selector(addcount), for: .valueChanged) //添加方法目标// 添加该刷新tableView.refreshControl = refreshControl\n刷新方法\n12345@objc func addcount() &#123;    dataArrary.append(contentsOf: dataArrary)    tableView.reloadData()    refreshControl.endRefreshing()&#125;\n向项目添加字体https://developer.apple.com/documentation/uikit/text_display_and_fonts/adding_a_custom_font_to_your_app\n由于iOS的用的字体名称并不是文件名称，而是字体本身名称。下面代码搜索所有字体，然后我们在控制台，找到多出来的名称。\n12345678for family: String in UIFont.familyNames&#123;    print(\"\\(family)\")    for names: String in UIFont.fontNames(forFamilyName: family)    &#123;        print(\"== \\(names)\")    &#125;&#125;\n设置tabbar 字体和字体大小12345override func viewDidLoad() &#123;    super.viewDidLoad()    let appearance = UITabBarItem.appearance()    appearance.setTitleTextAttributes([NSAttributedStringKey.font: UIFont(name: \"Ubuntu-Light\", size: 9)!], for: .normal)&#125;\nUIButton 相关UIButton.isEnabled = false后图片按钮的背景图片被改变1UIButton.adjustsImageWhenDisabled = false\n扩展添加圆角、边框、边框颜色12345678910111213141516171819202122232425262728293031@IBDesignable extension UIButton &#123;    @IBInspectable var borderWidth: CGFloat &#123;        set &#123;            layer.borderWidth = newValue        &#125;        get &#123;            return layer.borderWidth        &#125;    &#125;    @IBInspectable var cornerRadius: CGFloat &#123;        set &#123;            layer.cornerRadius = newValue        &#125;        get &#123;            return layer.cornerRadius        &#125;    &#125;    @IBInspectable var borderColor: UIColor? &#123;        set &#123;            guard let uiColor = newValue else &#123; return &#125;            layer.borderColor = uiColor.cgColor        &#125;        get &#123;            guard let color = layer.borderColor else &#123; return nil &#125;            return UIColor(cgColor: color)        &#125;    &#125;&#125;\n扩展图片在上，文字在下1234567891011121314extension UIButton &#123;    func alignVertical(spacing: CGFloat = 6.0, imageBottom: CGFloat = 0.0) &#123;        guard let imageSize = self.imageView?.image?.size,            let text = self.titleLabel?.text,            let font = self.titleLabel?.font            else &#123; return &#125;        self.titleEdgeInsets = UIEdgeInsets(top: 0.0, left: -imageSize.width, bottom: -(imageSize.height + spacing), right: 0.0)        let labelString = NSString(string: text)        let titleSize = labelString.size(withAttributes: [NSAttributedStringKey.font: font])        self.imageEdgeInsets = UIEdgeInsets(top: -(titleSize.height + spacing), left: 0.0, bottom: imageBottom, right: -titleSize.width)        let edgeOffset = abs(titleSize.height - imageSize.height) / 2.0;        self.contentEdgeInsets = UIEdgeInsets(top: edgeOffset, left: 0.0, bottom: edgeOffset, right: 0.0)    &#125;&#125;\nUITableView或UICollectionView被TabBar遮盖\nUITableView调用reloadData导致移动到列表顶部失效12345UIView.animate(withDuration: 0, animations: &#123;    self.tableView.contentOffset = CGPoint.zero&#125;, completion: &#123; _ in    self.tableView.reloadData()&#125;)\nNavigationBar导致CollectionViewCell或TableViewCell偏移1self.collectionView?.contentInsetAdjustmentBehavior = .automatic\n获取app版本12345/// 获取版本名let appVersion = Bundle.main.infoDictionary![\"CFBundleShortVersionString\"] as? String/// 获取版本号let versionNumber = Bundle.main.infoDictionary![\"CFBundleVersion\"] as? String\n清理缓存12345678910111213141516171819202122func clearCache() &#123;    // 取出cache文件夹目录 缓存文件都在这个目录下    let cachePath = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.cachesDirectory, FileManager.SearchPathDomainMask.userDomainMask, true).first    // 取出文件夹下所有文件数组    let fileArr = FileManager.default.subpaths(atPath: cachePath!)    // 遍历删除    for file in fileArr! &#123;        let path = cachePath?.appendingFormat(\"/\\(file)\")        if FileManager.default.fileExists(atPath: path!) &#123;            do &#123;                try FileManager.default.removeItem(atPath: path!)            &#125; catch &#123;            &#125;        &#125;    &#125;&#125;\n打开网页本软件的appstore123456789101112// App Store URL.let appStoreLink = \"https://itunes.apple.com/cn/app/id1144351773?mt=8\"/* First create a URL, then check whether there is an installed app that can open it on the device. */if let url = URL(string: appStoreLink), UIApplication.shared.canOpenURL(url) &#123;    // Attempt to open the URL.    UIApplication.shared.open(url, options: [:], completionHandler: &#123;(success: Bool) in        if success &#123;            print(\"Launching \\(url) was successful\")        &#125;&#125;)&#125;\n设置圆形展示图像\n设置UIImageView宽度和高度，假如设置为60*60\n设置运行时属性，设置圆弧为30（正方形边长度一半）\n勾选Clip to Bounds，\n\nUIScrollView填充到顶部（去掉状态栏到空白间距）\nContent Insets 选择Never\n去掉选中的Safe Area Relative Margins\n\nUIImage 高斯模糊扩展12345678910111213extension UIImage &#123;    func blurred(radius: CGFloat) -&gt; UIImage &#123;        let ciContext = CIContext(options: nil)        guard let cgImage = cgImage else &#123; return self &#125;        let inputImage = CIImage(cgImage: cgImage)        guard let ciFilter = CIFilter(name: \"CIGaussianBlur\") else &#123; return self &#125;        ciFilter.setValue(inputImage, forKey: kCIInputImageKey)        ciFilter.setValue(radius, forKey: \"inputRadius\")        guard let resultImage = ciFilter.value(forKey: kCIOutputImageKey) as? CIImage else &#123; return self &#125;        guard let cgImage2 = ciContext.createCGImage(resultImage, from: inputImage.extent) else &#123; return self &#125;        return UIImage(cgImage: cgImage2)    &#125;&#125;\n两个UIImage 合并扩展1234567891011121314151617extension UIImage &#123;  func overlayWith(image: UIImage, posX: CGFloat, posY: CGFloat) -&gt; UIImage &#123;    let newWidth = size.width &lt; posX + image.size.width ? posX + image.size.width : size.width    let newHeight = size.height &lt; posY + image.size.height ? posY + image.size.height : size.height    let newSize = CGSize(width: newWidth, height: newHeight)    UIGraphicsBeginImageContextWithOptions(newSize, false, 0.0)    draw(in: CGRect(origin: CGPoint.zero, size: size))    image.draw(in: CGRect(origin: CGPoint(x: posX, y: posY), size: image.size))    let newImage = UIGraphicsGetImageFromCurrentImageContext()!    UIGraphicsEndImageContext()    return newImage  &#125;&#125;\nSDWebImageView 下载图片\n方式一\n1234img.sd_setImage(with: URL(string: \"http://url\"),  placeholderImage: #imageLiteral(resourceName: \"default_square\")) &#123; image, error, cacheType, url in&#125;\n\n方式二\n12345678910SDWebImageDownloader  .shared()  .downloadImage(with: URL(string: \"http://url\"),    options: SDWebImageDownloaderOptions.init(rawValue: 0),    progress: nil,    completed: &#123; image, data, error, finished in    if finished &#123;    &#125;&#125;)\n\n\nAVPlayerViewController 视频播放12345678910import AVKitfunc playVideoByUrl(string: String) &#123;    let videoURL = URL(string: string)    let player = AVPlayer(url: videoURL!)    let playerViewController = AVPlayerViewController()    playerViewController.player = player    self.present(playerViewController, animated: true) &#123;        playerViewController.player!.play()    &#125;&#125;\n为UIImageView添加的点击手势无效\n勾选上User Interaction Enabled\n代码中设置uiimageview.userInteractionEnabled = true\n\nPHAsset获取文件路径12345678910111213141516171819202122232425extension PHAsset &#123;    func getURL(completionHandler : @escaping ((_ responseURL : URL?) -&gt; Void))&#123;        if self.mediaType == .image &#123;            let options: PHContentEditingInputRequestOptions = PHContentEditingInputRequestOptions()            options.canHandleAdjustmentData = &#123;(adjustmeta: PHAdjustmentData) -&gt; Bool in                return true            &#125;            self.requestContentEditingInput(with: options, completionHandler: &#123;(contentEditingInput: PHContentEditingInput?, info: [AnyHashable : Any]) -&gt; Void in                completionHandler(contentEditingInput!.fullSizeImageURL as URL?)            &#125;)        &#125; else if self.mediaType == .video &#123;            let options: PHVideoRequestOptions = PHVideoRequestOptions()            options.version = .original            PHImageManager.default().requestAVAsset(forVideo: self, options: options, resultHandler: &#123;(asset: AVAsset?, audioMix: AVAudioMix?, info: [AnyHashable : Any]?) -&gt; Void in                if let urlAsset = asset as? AVURLAsset &#123;                    let localVideoUrl: URL = urlAsset.url as URL                    completionHandler(localVideoUrl)                &#125; else &#123;                    completionHandler(nil)                &#125;            &#125;)        &#125;    &#125;&#125;\nUIView 相关通过UIView获取父UIViewController123456789101112extension UIView &#123;    var parentViewController: UIViewController? &#123;        var parentResponder: UIResponder? = self        while parentResponder != nil &#123;            parentResponder = parentResponder!.next            if let viewController = parentResponder as? UIViewController &#123;                return viewController            &#125;        &#125;        return nil    &#125;&#125;\nString 相关html的字符串，将代码转成对应效果12345678910111213extension String &#123;    var htmlToAttributedString: NSAttributedString? &#123;        guard let data = data(using: .utf8) else &#123; return NSAttributedString() &#125;        do &#123;            return try NSAttributedString(data: data, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding:String.Encoding.utf8.rawValue], documentAttributes: nil)        &#125; catch &#123;            return NSAttributedString()        &#125;    &#125;    var htmlToString: String &#123;        return htmlToAttributedString?.string ?? \"\"    &#125;&#125;\n正则表达式匹配12345678910111213141516/// 正则表达式匹配extension String &#123;    func matchingStrings(regex: String) -&gt; [String] &#123;        do &#123;            let regex = try NSRegularExpression(pattern: regex)            let results = regex.matches(in: self,                                        range: NSRange(self.startIndex..., in: self))            return results.map &#123;                String(self[Range($0.range, in: self)!])            &#125;        &#125; catch let error &#123;            print(\"invalid regex: \\(error.localizedDescription)\")            return []        &#125;    &#125;&#125;\nData拼接数据1234567extension Data &#123;    mutating func append(_ string: String, using encoding: String.Encoding = .utf8) &#123;        if let data = string.data(using: encoding) &#123;            append(data)        &#125;    &#125;&#125;\n打乱数组顺序123456789101112extension Array&#123;    mutating func randamArray() &#123;        var list = self        for index in 0..&lt;list.count &#123;            let newIndex = Int(arc4random_uniform(UInt32(list.count-index))) + index            if index != newIndex &#123;                list.swapAt(index, newIndex)            &#125;        &#125;        self = list    &#125;&#125;\nUIImage相关高斯模糊图片12345678910111213extension UIImage &#123;    func blurred(radius: CGFloat) -&gt; UIImage &#123;        let ciContext = CIContext(options: nil)        guard let cgImage = cgImage else &#123; return self &#125;        let inputImage = CIImage(cgImage: cgImage)        guard let ciFilter = CIFilter(name: \"CIGaussianBlur\") else &#123; return self &#125;        ciFilter.setValue(inputImage, forKey: kCIInputImageKey)        ciFilter.setValue(radius, forKey: \"inputRadius\")        guard let resultImage = ciFilter.value(forKey: kCIOutputImageKey) as? CIImage else &#123; return self &#125;        guard let cgImage2 = ciContext.createCGImage(resultImage, from: inputImage.extent) else &#123; return self &#125;        return UIImage(cgImage: cgImage2)    &#125;&#125;\n两张图片叠加成一张图片1234567891011121314151617extension UIImage &#123;    func overlayWith(image: UIImage, posX: CGFloat, posY: CGFloat) -&gt; UIImage &#123;        let newWidth = size.width &lt; posX + image.size.width ? posX + image.size.width : size.width        let newHeight = size.height &lt; posY + image.size.height ? posY + image.size.height : size.height        let newSize = CGSize(width: newWidth, height: newHeight)        UIGraphicsBeginImageContextWithOptions(newSize, false, 0.0)        draw(in: CGRect(origin: CGPoint.zero, size: size))        image.draw(in: CGRect(origin: CGPoint(x: posX, y: posY), size: image.size))        let newImage = UIGraphicsGetImageFromCurrentImageContext()!        UIGraphicsEndImageContext()        return newImage    &#125;&#125;\n缩放图片12345678910extension UIImage &#123;    func scaled(withSize size: CGSize) -&gt; UIImage &#123;        UIGraphicsBeginImageContextWithOptions(size, false, 0.0)        defer &#123; UIGraphicsEndImageContext() &#125;        draw(in: CGRect(x: 0.0, y: 0.0, width: size.width, height: size.height))        return UIGraphicsGetImageFromCurrentImageContext()!    &#125;&#125;\nJson相关Json编码12345678910extension JSONEncoder &#123;    /// 将实体类转换成Json数据    func toJson&lt;T: Encodable&gt;(_ entity: T) -&gt; String? &#123;        guard let encodedData = try? encode(entity) else &#123;            return nil        &#125;        return String(data: encodedData, encoding: .utf8)    &#125;&#125;\nJson解码12345678910extension JSONDecoder &#123;    func from&lt;T: Decodable&gt;(_ type: T.Type, json: String) -&gt; T? &#123;        do &#123;            return try decode(type, from: json.data(using: .utf8)!)        &#125;        catch &#123;            return nil        &#125;    &#125;&#125;\n请求字段编码为字符串，形式如：key=value&amp;key=value&amp;key=value123456789101112131415161718192021extension Dictionary &#123;    func percentEscaped() -&gt; String &#123;        return map &#123; (key, value) in            let escapedKey = \"\\(key)\".addingPercentEncoding(withAllowedCharacters: .urlQueryValueAllowed) ?? \"\"            let escapedValue = \"\\(value)\".addingPercentEncoding(withAllowedCharacters: .urlQueryValueAllowed) ?? \"\"            return escapedKey + \"=\" + escapedValue            &#125;            .joined(separator: \"&amp;\")    &#125;&#125;extension CharacterSet &#123;    static let urlQueryValueAllowed: CharacterSet = &#123;        let generalDelimitersToEncode = \":#[]@\" // does not include \"?\" or \"/\" due to RFC 3986 - Section 3.4        let subDelimitersToEncode = \"!$&amp;'()*+,;=\"        var allowed = CharacterSet.urlQueryAllowed        allowed.remove(charactersIn: \"\\(generalDelimitersToEncode)\\(subDelimitersToEncode)\")        return allowed    &#125;()&#125;\nUIViewController 相关添加子UIViewController12345678910111213141516extension UIViewController &#123;    /// 添加子ViewController    func addSubController(child: UIViewController, to: UIView? = nil) &#123;        addChildViewController(child)        if let to = to &#123;            child.view.frame = to.frame            to.addSubview(child.view)        &#125;        else &#123;            child.view.frame = view.frame            view.addSubview(child.view)        &#125;        child.didMove(toParentViewController: self)    &#125;&#125;\n移除子UIViewController12345678extension UIViewController &#123;    /// 移除子ViewController    func removeSubController(child: UIViewController) &#123;        child.willMove(toParentViewController: nil)        child.removeFromParentViewController()        child.view.removeFromSuperview()    &#125;&#125;\n关闭页面关闭当前页面123456extension UIViewController &#123;    /// 关闭当前页面    func closePage() &#123;        self.dismiss(animated: true, completion: nil)    &#125;&#125;\n关闭所有页面，除开最下级的那个页面1234567891011extension UIViewController &#123;    func closeAllPage() &#123;        //获取根VC        var rootVC = self.presentingViewController        while let parent = rootVC?.presentingViewController &#123;            rootVC = parent        &#125;        //释放所有下级视图        rootVC?.dismiss(animated: true, completion: nil)    &#125;&#125;\n显示和关闭菊花等待加载12345678910111213141516171819202122extension UIViewController &#123;    class func displaySpinner(onView : UIView) -&gt; UIView &#123;        let spinnerView = UIView.init(frame: onView.bounds)        spinnerView.backgroundColor = UIColor.init(red: 0.5, green: 0.5, blue: 0.5, alpha: 0.5)        let ai = UIActivityIndicatorView.init(activityIndicatorStyle: .whiteLarge)        ai.startAnimating()        ai.center = spinnerView.center        DispatchQueue.main.async &#123;            spinnerView.addSubview(ai)            onView.addSubview(spinnerView)        &#125;        return spinnerView    &#125;    class func removeSpinner(spinner :UIView) &#123;        DispatchQueue.main.async &#123;            spinner.removeFromSuperview()        &#125;    &#125;&#125;\n\n显示\n\n1let sp = UIViewController.displaySpinner(onView: self.view)\n\n关闭\n\n1UIViewController.removeSpinner(spinner: sp)\nIAP 内购\n使用\n\n\n除代码外的内购准备工序已OK\n获取产品数据：通过IAPHelper.shared.fetchAvailableProducts从苹果服务器获取所有传入的产品id的产品信息，传入的参数是产品的id字符串数组\n支付：IAPHelper.shared.purchase(id: id)，id是产品id\n1234567891011121314151617IAPHelper.shared.purchase(id: selectItem!.product_id) &#123;alert, product, transaction in  if alert == .purchased &#123; //购买成功      if let receiptUrl = Bundle.main.appStoreReceiptURL, let receiptData = NSData(contentsOf: receiptUrl) &#123;          let receiptString = receiptData.base64EncodedString(options: NSData.Base64EncodingOptions(rawValue: 0))          // 对receiptString加密字符串进行验证      &#125;  &#125;  else if alert == .restored &#123;  &#125;  else if alert == .purchasing &#123;  &#125;  else &#123;  &#125;&#125;\n\n\n\nIAPHelper 代码\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import StoreKitenum IAPHelperAlertType&#123;    case disabled    case restored    case purchased    case purchasing    case setProductIds    func message() -&gt; String&#123;        switch self &#123;        case .setProductIds: return \"未设置产品id，请调用 fetchAvailableProducts()\"        case .disabled: return \"购买已取消\"        case .restored: return \"您已成功恢复购买\"        case .purchased: return \"您已成功购买此商品\"        case .purchasing: return \"正在购买...\"        &#125;    &#125;&#125;class IAPHelper: NSObject &#123;    static let shared = IAPHelper()    private override init() &#123; &#125;    fileprivate var productID = \"\"    fileprivate var productsRequest = SKProductsRequest()    fileprivate var productDict = [String:SKProduct]()    fileprivate var fetchProductCompletion: (([SKProduct])-&gt;Void)?    fileprivate var productToPurchase: SKProduct?    var purchaseProductCompletion: ((IAPHelperAlertType, SKProduct?, SKPaymentTransaction?) -&gt; Void)?    // MARK: - 购买产品    func canMakePurchases() -&gt; Bool &#123;  return SKPaymentQueue.canMakePayments()  &#125;    func purchase(id: String, completion: @escaping ((IAPHelperAlertType, SKProduct?, SKPaymentTransaction?)-&gt;Void)) &#123;        self.purchaseProductCompletion = completion        self.productToPurchase = productDict[id]        guard let product = self.productToPurchase else &#123;            print(IAPHelperAlertType.setProductIds.message())            fatalError(IAPHelperAlertType.setProductIds.message())        &#125;        if self.canMakePurchases() &#123;            let payment = SKPayment(product: product)            SKPaymentQueue.default().add(self)            SKPaymentQueue.default().add(payment)            print(\"采购产品: \\(product.productIdentifier)\")            productID = product.productIdentifier        &#125;        else &#123;            completion(.disabled, nil, nil)        &#125;    &#125;    // MARK: - 恢复购买    func restorePurchase()&#123;        SKPaymentQueue.default().add(self)        SKPaymentQueue.default().restoreCompletedTransactions()    &#125;    // MARK: - 获取可用的iap产品    func fetchAvailableProducts(by ids: [String], completion: @escaping (([SKProduct])-&gt;Void))&#123;        self.fetchProductCompletion = completion        // 把您的IAP产品id放到这里面        guard !ids.isEmpty else &#123;            print(\"没有设置产品id\")            fatalError(IAPHelperAlertType.setProductIds.message())        &#125;        productsRequest = SKProductsRequest(productIdentifiers: Set(ids))        productsRequest.delegate = self        productsRequest.start()    &#125;&#125;extension IAPHelper: SKProductsRequestDelegate, SKPaymentTransactionObserver&#123;    // MARK: - 请求IAP产品    func productsRequest (_ request:SKProductsRequest, didReceive response:SKProductsResponse) &#123;        if (response.products.count &gt; 0) &#123;            for product in response.products &#123;                print(\"product.productIdentifier = \\(product.productIdentifier)\")                self.productDict[product.productIdentifier] = product            &#125;            self.fetchProductCompletion?(response.products)        &#125;    &#125;    func paymentQueueRestoreCompletedTransactionsFinished(_ queue: SKPaymentQueue) &#123;        self.purchaseProductCompletion?(.restored, nil, nil)    &#125;    // MARK:- IAP付款队列    func paymentQueue(_ queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction]) &#123;        print(\"调用了几次啊！！！\")        for transaction:AnyObject in transactions &#123;            if let trans = transaction as? SKPaymentTransaction &#123;                switch trans.transactionState &#123;                case .purchased:                    print(\"产品已购买\")                    SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction)                    self.purchaseProductCompletion?(.purchased, self.productToPurchase, trans)                    break                case .failed:                    print(\"产品购买失败\\(trans.error.debugDescription)\")                    SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction)                    self.purchaseProductCompletion?(.disabled, self.productToPurchase, trans)                    break                case .purchasing:                    print(\"正在购买...\")                    self.purchaseProductCompletion?(.purchasing, self.productToPurchase, trans)                    break                case .restored:                    print(\"产品已恢复购买\")                    SKPaymentQueue.default().finishTransaction(transaction as! SKPaymentTransaction)                    self.purchaseProductCompletion?(.restored, self.productToPurchase, trans)                    break                default: break                &#125;            &#125;        &#125;    &#125;&#125;\n判断退格符”\\b”https://stackoverflow.com/a/29505548/9724892\n123456789func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -&gt; Bool &#123;    if let char = string.cString(using: String.Encoding.utf8) &#123;        let isBackSpace = strcmp(char, \"\\\\b\")        if (isBackSpace == -92) &#123;            print(\"Backspace was pressed\")        &#125;    &#125;    return true&#125;\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/ios-note/20190319220203.jpg","plink":"https://blog.xujiaji.com/post/ios-study-note/"},{"title":"Swift学习笔记","date":"2018-07-09T13:21:34.000Z","author":"xujiaji","updated":"2018-12-25T15:23:05.699Z","content":"记录一些swift的基本特性，以便使用的时候方便查阅。\n学习地址：https://www.imooc.com/t/108955\n元组\n定义：可放入各种类型数据，元组长度自由\n\n12var point = (5, 2)var httpResponse = (404, \"Not Found\")\n\n可先预定类型来定义\n\n123var point2: (Int, Int, Int) = (10, 5, 2)var httpResponse2: (Int, String) = (200, \"OK\")let point4: (x: Int, y: Int) = (10, 5)\n\n取值\n\n12345678910111213141516// 第一种方式var point = (5, 2)var(xx, yy) = point// 第二种方式point.0point.1// 第三种方式let point3 = (x: 3, y: 2)point3.xpoint3.y// 第四种方式（只取相关数据 是否登录）let loginResult = (true, \"xujiaji\")let (isLoginSuccess, _ ) = loginResult\nprint打印\n正常情况下\n\n1print(\"a message\")\n\n拼接，（结果：1 2 3 4）\n\n1print(1, 2, 3, 4)\n\n插值：在拼接的中间插入值，默认是空格\n\n12// 结果：1-2-3-4print(1, 2, 3, 4, separator:\"-\")\n\n结尾：默认是回车“\\n”\n\n12// 结果：1 -- 2 -- 3 -- 4:)helloprint(1, 2, 3, 4, separator:\" -- \", terminator:\":)\")\n\n另一种拼接方式：\\()\n\n123let y = 2, z = 4// 结果：2 * 4 = 8print(\"\\(y) * \\(z) = \\(y*z)\")\nif条件判断\n基本用法，条件必须是Bool类型，可写表达式，但结果必须是Bool\n\n123456789let imTrue:Bool = truelet imFalse = falseif imFalse &#123;    print(\"I'm True\")&#125;else &#123;    print(\"I'm False\")&#125;\n\n支持三目运算符\n\nfor循环\n基本用法\n\n1234// 从2打印到10for index in 2...10 &#123;    print(index)&#125;\n\n前闭后开，经常用于循环数组\n\n1234// 从0打印到9for index in 0..&lt;10 &#123;    print(index)&#125;\n\n下划线忽略值\n\n123for _ in 1...10 &#123;&#125;\n\n反向遍历\n\n1234// 结果：从10打印到1for i in (1...10).reversed() &#123;    print(i)&#125;\n\nstride，from开始数，to结尾数（不包括结尾数），through结尾数（包括结尾数），by每次循环的跨度(可以是浮点数)\n\n1234567891011121314// 结果： 0 2 4 6 8for i in stride(from: 0, to: 10, by: 2) &#123;    print(i)&#125;// 结果：0 2 4 6 8 10for i in stride(from: 0, through: 10, by: 2) &#123;    print(i)&#125;// 结果：从10遍历到1for i in stride(from: 10, to: 0, by: -1) &#123;    print(i)&#125;\nwhile循环\n和java没什么区别，只是没有小括号\n\n\n至少执行一次循环，相当于java中的do while\n\n123repeat &#123;  语句&#125; while 条件\nswitch1. 注意switch case中不用写break， case后可以匹配多个值逗号隔开2. 不可以穷举（是否知道所有可能性），必须加上default:如果没有语句可以用break显示跳出或()表示空语句3. 可以用字符串，浮点数，布尔等swift基础数据结构4. case后面可以跟区间，如 1 ..&lt; 605. case还可以对元组进行判断，并且元组可以通过_进行忽略；元组中还可以用区间，如case (-2...2, -2...2):；还可以和元组解包一起用，如case (let x, let y):6. 语句结束后加上fallthrough关键字，可让条件向下判断7. case中用where可以加上条件判断进行限制12345678910let point = (3, 3)switch point &#123;case let(x, y) where x == y:    print(\"It's on the line x == y!\")case let(x, y) where x == -y:    print(\"It's on the line x == -y\")case let(x, y):    print(\"It's just an ordinary point.\")    print(\"The point is (\\(x), \\(y)\")&#125;\n8. switch case还可以用if case 来简化代码1234567891011121314151617let age = 19switch age &#123;case 10...19:    print(\"You're a teenage.\")default:    print(\"You're not a teenage.\")&#125;// 用 if case 简化后if case 10...19 = age &#123;    print(\"You're a teenage.\")&#125;// 还可以加上where条件判断，where可直接省略通过逗号隔开if case 10...19 = age, age &gt;= 18 &#123;    print(\"You're a teenage and in a college\")&#125;\n9. case关键字还可以用于for12345678910for i in 1...100 &#123;    if i % 3 == 0 &#123;        print(i)    &#125;&#125;// 用case来写for case let i in 1...100 where i%3 == 0 &#123;    print(i)&#125;\n控制转移\n给循环起名字\n\n123456789// 表示如果得到结果，不仅break内部循环，也结束外部循环findAnswer: for m in 1...300 &#123;    for n in 1...300 &#123;        if m*m*m*m - n*n == 15*m*n &#123;            print(m, n)            break findAnswer        &#125;    &#125;&#125;\nguard\n守卫，如果条件不成立，那么将会执行else\n\n1234567891011func fun(money:Int, price: Int, capacity:Int, volume: Int) &#123;    guard money &gt;= price else &#123;        print(\"Not enough money\")        return    &#125;    guard capacity &gt;= volume else &#123;        print(\"Not enough capacity\")        return    &#125;    print(\"I can buy it\")&#125;\n字符串1var str = \"Hello, playground\"\n1. 判断是否为空12var emptyString = \"\"emptyString.isEmpty\n2. 插值1234let name = \"xujiaji\"let age = 24let height = 1.7let s = \"My name is \\(name). I'm \\(age) years old. I'm \\(height) meters tall.\"\n3. 循环字符串123for c in str &#123;    print(c)&#125;\n4. 声明字符1let mark: Character = \"!\"\n5. 拼接字符1str.append(mark)\n6. 字符串长度1str.count\n7. 得到字符串开头下标： str.startIndex ；得到末尾下标：str.endIndex8. 得到字符串前5个字符（offsetBy表示偏移量）1str[str.index(str.startIndex, offsetBy: 5)]\n9. 得到字符串某下标的前一个字符或后一个字符123let spaceIndex = str.index(str.startIndex, offsetBy: 6)str[str.index(before: spaceIndex)]str[str.index(after: spaceIndex)]\n10. 得到开始到spaceIndex下标之间的字符串1str[str.startIndex..&lt;spaceIndex]\n11. 得到一个下标范围1let  range = startIndex..&lt;str.index(before: spaceIndex)\n12. 将上面范围替换成Hi1str.replaceSubrange(range, with: \"Hi\")\n13. 末尾插入问号1str.insert(\"?\", at: str.endIndex)\n14. 移除对应下标的字符1str.remove(at: str.index(before: str.endIndex))\n15. 移除某个下标范围字符1str.removeSubrange(str.index(str.endIndex, offsetBy:-2)..&lt;str.endIndex)\n16. 大小写转换123456// 转大写str.uppercased()// 转小写str.lowercased()// 首字大写str.capitalized\n17. 是否包含123456// 是否包含Histr.contains(\"Hi\")// 前缀是否是Histr.hasPrefix(\"Hi\")// 后缀是否是!!str.hasSuffix(\"!!\")\n18. 格式化字符串123456// 结果： 0.33333...let ss0 = \"one third is \\(1.0/3.0)\"// 结果： 0.33let ss1 = String(format: \"one third is %.2f\", 1.0/3.0)// 结果： 0.33let ss2 = NSString(format: \"one third is %.2f\", 1.0/3.0) as String\n19. 字符串截取1234567var ss3:NSString = \"one third is 0.33\"// 从下标4开始截取到最后ss3.substring(from: 4)// 从开始截取到下标3ss3.substring(to: 3)// 截取下标从4开始，截取5个长度ss3.substring(with: NSMakeRange(4, 5))\n20. String 和 NSString的区别\n\n有一个表情的时候String长度为1， NSString长度为2\n\n21. 去除前后多余无效字符123let s6 = \"   --- Hello -----    \" as NSString// 去除前后空格和下划线s6.trimmingCharacters(in: CharacterSet(charactersIn: \" -\"))\nOptional1. 定义可选型123var errorCode: Int? = 404errorCode = nilvar imOptional: String? = nil\n2. 具体类型可以赋值给可选项型，但反过来可选型是不能赋值给具体类型的。3. 强制解包，但不能为nil否则会抛出异常1234var errorCode: Int? = nilerrorCode = 404// errorCode! 强制解包print(\"code\", errorCode!)\n4. 加上nil判断1234567891011// 第一种写法var errorCode: String? = nilif errorCode != nil &#123;    \"The errorCode is \" + errorCode!&#125;else &#123;    \"No error\"&#125;// 第二种写法（简化），用两个问号\"The errorCode is \\(errorCode ?? \"no error\")\"\n5. 可选型解包123456789101112131415161718var errorCode: String? = \"404\"if let errorCode = errorCode &#123;    \"The errorCode is \" + errorCode&#125;else &#123;    \"No error\"&#125;var errorMessage: String? = \"Not found\"// errorCode有值，并且errorMessage有值if let errorCode = errorCode, let errorMessage = errorMessage &#123;    \"The errorCode is \" + errorCode + \"\\nThe errorMessage is \" + errorMessage&#125;// errorCode有值，并且errorMessage有值，并且errorCode等于404if let errorCode = errorCode, let _ = errorMessage, errorCode == \"404\" &#123;    print(\"Page not found\")&#125;\n6. 可选型调用12345678910111213141516var errorMessage: String? = \"Not Found\"// 普通判断调用if let errorMessage = errorMessage &#123;    errorMessage.uppercased()&#125;// ?. 方式调用，和上面效果是一样的errorMessage?.uppercased()// 定义不用写“? =”方式，可选型的调用的结果也是可选型的var uppercaseErrorMessage = errorMessage?.uppercased()// 也可以调用后，如果存在使用该对象if let errorMessage = errorMessage?.uppercased() &#123;    errorMessage&#125;\n6. 实际运用12345var ageInput: String = \"16\"var age = Int(ageInput) // 返回的是：Int?if let age = Int(ageInput), age &lt; 20 &#123;    print(\"You're a teenage\")&#125;\n7. 隐式可选类型，运用在能肯定的表示有值的情况下12345678// 后面跟！表示是隐式可选类型var errorMessage: String! = nilerrorMessage = \"Not Found\"\"The message is \" + errorMessageerrorMessage = nil// 会抛出异常，所以隐式可选类型危险的//\"The message is \" + errorMessage\nArray1. 空数组的定义123456789101112131415// 有数据时的定义， 注意类型必须统一var numbers = [1, 2, 3, 4, 5]var vowels = [\"A\", \"B\", \"C\"]// 定义的时确定好类型//var numbers: [Int] = [0,1,2,3,4,5]// 定义空数组var emptyArr1:[Int] = []var emptyArr2:Array&lt;Int&gt; = []var emptyArr3 = [Int]()var emptyArr4 = Array&lt;Int&gt;()// 定义时统一赋值var allZeros = Array&lt;Int&gt;(repeating: 0, count: 5) // [0, 0, 0, 0, 0]var allZeros2 = [Int](repeating: 0, count: 5) // [0, 0, 0, 0, 0]\n2. 数组查询基本使用方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var numbers = [1, 2, 3, 4, 5]var vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"]var emptyArr = [Int]()// 获取数组长度vowels.count// 判断是否为空numbers.isEmpty // falseemptyArr.isEmpty // true// 获取首元素或末元素vowels.first // \"A\"vowels.last // \"U\"emptyArr.first // nil// 可选型解包if let firstVomel = vowels.first &#123;    print(\"The first vowel is \" + firstVomel)&#125;// 强制解包，由自己保证安全vowels.first!// 获取数组的最大值或最小值numbers.min()numbers.max()// 从原数组中取出子数组numbers[2..&lt;4] // [3, 4]numbers[2..&lt;numbers.count] // [3, 4, 5]// 包含vowels.contains(\"A\") // truevowels.contains(\"B\") // false// 获取下标vowels.index(of: \"E\") // 1if let index = vowels.index(of: \"E\") &#123;    print(\"E is vowel in position \\(index+1).\")&#125;else &#123;    print(\"E is not a vowel.\")&#125;// 通过下标遍历for i in 0..&lt;numbers.count &#123;    numbers[i]&#125;// 直接遍历元素for number in numbers &#123;    print(number)&#125;// 同时遍历下标和元素for (i, vowel) in vowels.enumerated() &#123;    print(\"\\(i + 1): \\(vowel)\")&#125;// 比较，与java不同，swift比较的是元素var oneToFive = [1, 2, 3, 4, 5]numbers == oneToFive // true// 由于比较数组时与元素的顺序有关，所以下方结果为falsevar oneToFive2 = [1, 2, 4, 3, 5]numbers == oneToFive2 // false\n3. 数组插入值的基本操作123456789var courses = [\"A course\", \"B course\", \"C course\"]// 添加元素courses.append(\"D course\") //[\"A course\", \"B course\", \"C course\", \"D course\"]courses += [\"E course\"] //[\"A course\", \"B course\", \"C course\", \"D course\", \"E course\"]// 根据位置插入元素courses.insert(\"a course\", at: 1) //[\"A course\", \"a course\", \"B course\", \"C course\", \"D course\", \"E course\"]\n4. 数组删除元素的基本操作12345678910var courses = [\"A course\", \"B course\", \"C course\", \"D course\"]// 删除最后一个元素courses.removeLast() //\"D course\"// 删除第一个元素courses.removeFirst() //\"A course\"courses // [\"B course\", \"C course\"]// 从下标0开始删除1个courses.removeSubrange(0..&lt;1) //[\"C course\"]// 删除所有元素courses.removeAll()\n5. 修改元素的基本操作123456789101112var courses = [\"A course\", \"B course\", \"C course\", \"D course\"]// 修改下标为0的元素courses[0] = \"1 course\"courses // [\"1 course\", \"B course\", \"C course\", \"D course\"]// 修改下标1到2的元素courses[1...2] = [\"2 course\", \"3 course\"]courses // [\"1 course\", \"2 course\", \"3 course\", \"D course\"]// 合并并修改0到2的元素courses[0...2] = [\"A course\"]courses // [\"A course\", \"D course\"]\nNSArray1. NSArray是一个类，Array是一个结构2. NSArray里可以放不同类型的元素，如：var arr: NSArray = [1, &quot;Hello&quot;, 3.0]\nDict1. 字典的初始化和查询的基本使用方式12345678910111213141516171819202122232425262728293031323334353637383940414243// 创建一个有数据的字典var dict = [\"swift\": \"雨燕；快速\", \"python\": \"大蟒\", \"java\":\"爪哇岛\", \"groovy\": \"绝妙的；时髦的\"]// 创建空字典var emptyDict1: [String:Int] = [:]var emptyDict2: Dictionary&lt;Int, String&gt; = [:]var emptyDict3 = [String:String]()var emptyDict4 = Dictionary&lt;Int, Int&gt;()// 通过key获取字典数据dict[\"swift\"] // \"雨燕；快速\"dict[\"C++\"] // nil// 可选型解包if let value = dict[\"swift\"] &#123;    print(\"swift 的意思是：\\(value)\")&#125;//字典数据的数量dict.count // 4dict.isEmpty // falseemptyDict1.isEmpty // true//遍历所有keyfor key in dict.keys &#123;    print(key)&#125;// 遍历所有valuefor value in dict.values &#123;    print(value)&#125;// 遍历key和valuefor (key, value) in dict &#123;    print(\"\\(key): \\(value)\")&#125;// 两个字典对比：比较的key和对应的value，由于字典是无序的，因此下方等式也成立let dict1 = [1: \"A\", 2: \"B\", 3: \"C\"]let dict2 = [1: \"A\", 3: \"C\", 2: \"B\"]dict1 == dict2 // true\n2. 字典的修改和删除1234567891011121314151617181920212223242526272829303132// let的字典不可修改var user = [\"name\": \"xujiaji\", \"password\": \"123456\", \"occupation\": \"programmer\"]// 修改值user[\"occupation\"] = \"freelancer\"// 调用方法修改值会返回之前的值user.updateValue(\"abcdefg\", forKey: \"password\") // \"123456\"user //[\"name\": \"xujiaji\", \"password\": \"abcdefg\", \"occupation\": \"freelancer\"]let oldPassword = user.updateValue(\"abcdefg\", forKey: \"password\")if let oldPassword = oldPassword, let newPassword = user[\"password\"], oldPassword == newPassword &#123;    print(\"注意：修改后的密码和之前的一样，可能导致安全问题\")&#125;// 直接添加新的key和valueuser[\"email\"] = \"jiajixu@qq.com\"user // [\"name\": \"xujiaji\", \"occupation\": \"freelancer\", \"email\": \"jiajixu@qq.com\", \"password\": \"abcdefg\"]// 通过方法添加新的key和valueuser.updateValue(\"https://blog.xujiaji.com\", forKey: \"website\") // niluser // [\"name\": \"xujiaji\", \"occupation\": \"freelancer\", \"email\": \"jiajixu@qq.com\", \"password\": \"abcdefg\", \"website\": \"https://blog.xujiaji.com\"]// 删除key和valueuser[\"website\"] = nil// 通过调用方法删除key和valueif let email = user.removeValue(forKey: \"email\") &#123;    print(\"电子邮箱\\(email)删除成功\")&#125;// 删除所有数据user.removeAll()\nSet1. 初始化和基本使用12345678910111213141516171819202122232425262728293031323334353637// 创建一个有数据的Set集合，和数组定义方式差不多，但是加上了类型申明var skillsOfA: Set&lt;String&gt; = [\"swift\", \"OC\"]// 创建空Set集合var emptySet1: Set&lt;String&gt; = []var emptySet2 = Set&lt;String&gt;()//集合是无序的，并且没有重复var vowels = Set([\"A\", \"E\", \"I\", \"O\", \"U\", \"U\"]) //&#123;\"O\", \"A\", \"I\", \"U\", \"E\"&#125;var skillsOfB: Set = [\"HTML\", \"CSS\", \"JavaScript\"]// 集合元素个数skillsOfA.count // 2var set: Set = [2, 2, 2, 2]set.count // 1// 集合是否为空skillsOfB.isEmpty // falseemptySet1.isEmpty // true// 快速获取集合中的第一个元素skillsOfA.first // \"swift\"// 包含skillsOfA.contains(\"swift\") // true// 遍历for skill in skillsOfB &#123;    print(skill)&#125;// 比较的值，和顺序无关let setA: Set = [1, 2, 3]let setB: Set = [3, 2, 1, 1, 1, 1]setA == setB // true\n2. 元素的插入和删除1234567891011121314151617181920212223var skillsOfA: Set&lt;String&gt; = [\"swift\", \"OC\"]var skillsOfB: Set&lt;String&gt; = [\"HTML\", \"CSS\", \"Javacript\"]var skillsOfC: Set&lt;String&gt; = []// 添加元素skillsOfC.insert(\"swift\")skillsOfC.insert(\"HTML\")skillsOfC.insert(\"CSS\")skillsOfC //&#123;\"swift\", \"CSS\", \"HTML\"&#125;// 重复添加skillsOfC.insert(\"CSS\")skillsOfC //&#123;\"swift\", \"CSS\", \"HTML\"&#125;// 删除元素skillsOfC.remove(\"CSS\")skillsOfC //&#123;\"swift\", \"HTML\"&#125;// 删除没有的元素skillsOfC.remove(\"Javascript\") //nilif let _ = skillsOfC.remove(\"HTML\") &#123;    print(\"HTML is removed\")&#125;\n3. 集合之间的操作：并集、交集、减集、异或12345678910111213141516171819202122232425262728293031var skillsOfA: Set&lt;String&gt; = [\"swift\", \"OC\"]var skillsOfB: Set&lt;String&gt; = [\"HTML\", \"CSS\", \"Javacript\", \"Java\"]var skillsOfC: Set&lt;String&gt; = [\"swift\", \"Java\"]// 并集skillsOfA.union(skillsOfC) //&#123;\"swift\", \"OC\", \"Java\"&#125;skillsOfA //&#123;\"swift\", \"OC\"&#125;// 并集操作后改变skillsOfA的值skillsOfA.formUnion(skillsOfC) //&#123;\"swift\", \"OC\", \"Java\"&#125;skillsOfA //&#123;\"swift\", \"OC\", \"Java\"&#125;// 交集skillsOfB.intersection(skillsOfC) // &#123;\"Java\"&#125;skillsOfB // &#123;\"Java\", \"HTML\", \"CSS\", \"Javacript\"&#125;skillsOfB.formIntersection(skillsOfC) // &#123;\"Java\"&#125;skillsOfB // &#123;\"Java\"&#125;// 减集skillsOfA.subtracting(skillsOfC)skillsOfA // &#123;\"swift\", \"OC\", \"Java\"&#125;skillsOfA.subtract(skillsOfC)skillsOfA // &#123;\"OC\"&#125;// 异或skillsOfA.symmetricDifference(skillsOfC)skillsOfA // &#123;\"OC\"&#125;skillsOfA.formSymmetricDifference(skillsOfC)skillsOfA // &#123;\"OC\", \"swift\", \"Java\"&#125;// 可操作数组skillsOfA.union([\"Java\", \"Android\"])\n4. 集合中的子集，超集合相离的判断123456789101112131415161718var skillsOfA: Set&lt;String&gt; = [\"swift\", \"OC\"]var skillsOfB: Set&lt;String&gt; = [\"HTML\", \"CSS\", \"Javacript\", \"Java\"]var skillsOfC: Set&lt;String&gt; = [\"swift\", \"Java\"]var skillsOfD: Set = [\"swift\"]// 是否是子集（D是否包含A）skillsOfD.isSubset(of: skillsOfA) // true// 是否是真子集 （D是否包含A，并且D != A）skillsOfD.isStrictSubset(of: skillsOfA) // true// 是否是超集（与子集相反）skillsOfA.isSuperset(of: skillsOfD) // true// 是否是真超集skillsOfA.isStrictSuperset(of: skillsOfD) // true// 判断相离(两集合没有共有元素)skillsOfA.isDisjoint(with: skillsOfB) // trueskillsOfA.isDisjoint(with: skillsOfC) // false\nFunction参数部分1. 方法的基本定义123456789101112131415161718192021222324252627282930313233//  函数的基本构建func sayHelloTo(name: String) -&gt; String &#123;    return \"Hello \" + name&#125;// 调用sayHelloTo(name: \"xujiaji\")// 通过添加下划线，调用的时候可以省略参数名func sayHelloTo(_ name: String) -&gt; String &#123;    return \"Hello \" + name&#125;sayHelloTo(\"xujiaji\")// 函数参数中包含可选型func sayHelloTo(name: String?) -&gt; String &#123;    return \"Hello \" + (name ?? \"Guest\")&#125;var nickname: String? = nilsayHelloTo(name: nickname)// 没有参数与没有返回值的参数func printHello() &#123;    print(\"Hello\")&#125;// 显示的说明没有返回值//func printHello() -&gt; () &#123;//&#125;// Void = ()//func printHello() -&gt; Void &#123;//&#125;\n2. 写一个得到数组中最大和最小值的方法123456789101112131415161718192021func findMaxAndMin(numbers: [Int]) -&gt; (max: Int, min: Int)? &#123;    guard !numbers.isEmpty else &#123;        return nil    &#125;    var minValue = numbers[0]    var maxValue = numbers[0]    for number in numbers &#123;        minValue = min(minValue, number)        maxValue = max(maxValue, number)    &#125;    return (maxValue, minValue)&#125;var scores: [Int]? = [202, 1234, 5678, 334, 982, 555]scores = scores ?? []if let result = findMaxAndMin(numbers: scores!) &#123;    print(\"The max value is \\(result.max)\")    print(\"The min value is \\(result.min)\")&#125;\n3. 方法的外部参数名和内部参数名1234567891011121314151617181920212223// 一般写法，内部参数名同时也是外部参数名func sayHelloTo(name: String, greeting: String) -&gt; String &#123;    return \"\\(greeting), \\(name)\"&#125;sayHelloTo(name: \"Playground\", greeting: \"Hello\")// 为参数提供外部参数名，让语义更加的明确func sayHello(to name: String, withGreetingWord greeting: String) -&gt; String &#123;    return \"\\(greeting), \\(name)\"&#125;sayHello(to: \"Playground\", withGreetingWord: \"Hello\")// 一个计算乘法的方法func mutiply(num1: Int, x num2: Int) -&gt; Int &#123;    return num1 * num2&#125;mutiply(num1: 4, x: 2)// 下方乘法虽语义明确但是，确显得复杂，直接传入两个值会更加得当。于是我们可以通过下划线忽略参数名func mutiply(_ num1: Int, _ num2: Int) -&gt; Int &#123;    return num1 * num2&#125;mutiply(4, 2)\n4. 默认参数和可变参数1234567891011121314151617181920212223// 默认参数的使用func sayHello(to name: String = \"Playground\", withGreetingWord greeting: String = \"Hello\", punctuation: String = \"!\") -&gt; String &#123;    return \"\\(greeting), \\(name)\\(punctuation)\"&#125;sayHello() // \"Hello, Playground!\"sayHello(to: \"Bob\") // \"Hello, Bob!\"sayHello(to: \"Bob\", withGreetingWord: \"Bye\") //\"Bye, Bob!\"// 可变参数的使用// 计算平局值func mean(_ numbers: Double ... ) -&gt; Double &#123;    var sum: Double = 0    for number in numbers &#123;        sum += number    &#125;    return sum / Double(numbers.count)&#125;mean(1, 2, 3.4, 7.5)// print是一个非常好的有默认参数和可变参数的函数，可变参数不一定放在最后print(\"Hello\", 1, 2, 3, separator: \",\", terminator: \".\") // \"Hello,1,2,3.\"\n5. 常量参数、变量参数12345678910111213// 函数的参数默认都是不可变的func toBinary(_ num: Int) -&gt; String &#123;    // 让传入的参数num称为可变参数    var num = num    var res = \"\"    repeat &#123;        res = String(num%2) + res        num /= 2    &#125; while num != 0    return res&#125;toBinary(12) // \"1100\"\n6. inout123456789101112131415161718192021222324252627// var 参数是值传递，不能延续到函数体外面var x = 100toBinary(x)x// 如果需要延续到外面func swapTwoInt(a: inout Int, b: inout Int) &#123;//    let t: Int = a//    a = b//    b = t// 通过元组可直接交换值    (a, b) = (b, a)&#125;var a: Int = 1var b: Int = 2// 传入a和b的引用swapTwoInt(a: &amp;a, b: &amp;b)ab// swift提供的交换方法swap(&amp;a, &amp;b)ab\n类型部分1. 函数类型的基本概念12345678910111213141516171819// 函数类型func add(_ a: Int, _ b: Int) -&gt; Int &#123;    return a + b&#125;// 方法也可以赋值let anotherAdd = add// 也可以声明类型// let anotherAdd: (Int,Int)-&gt;Int = addanotherAdd(3, 4)func sayHello(to name: String) &#123;    print(\"Hello, \\(name)!\")&#125;let anotherSayHello1 = sayHellolet anotherSayHello2: (String) -&gt; () = sayHellolet anotherSayHello3: (String) -&gt; Void = sayHello\n2. 如何使用函数类型？1234567891011121314151617181920212223242526272829var arr: [Int] = []for _ in 0..&lt;100 &#123;    arr.append(Int(arc4random() % 1000))&#125;arr// 默认排序arr.sort()arr// 在排序中使用函数参数func biggerNumberFirst(_ a: Int, _ b: Int) -&gt; Bool &#123;    return a &gt; b&#125;// 排序使用我们自己定义的规则arr.sort(by: biggerNumberFirst)arrfunc cmpByNumberString(_ a: Int, _ b: Int) -&gt; Bool &#123;    return String(a) &lt; String(b)&#125;arr.sort(by: cmpByNumberString)func near500(_ a: Int, _ b: Int) -&gt; Bool &#123;    return abs(a - 500) &lt; abs(b - 500)&#125;// 返回排序结果，排序不会影响arr的顺序arr.sorted(by: near500)arr\n3. 定义函数类型参数1234567891011121314151617181920func changeScores(_ scores: inout [Int], by changeScore: (Int)-&gt;Int) &#123;    for (i, score) in scores.enumerated() &#123;        // 不需要知道方法的具体定义        scores[i] = changeScore(score)    &#125;&#125;func change1(score: Int) -&gt; Int &#123;    return Int(sqrt(Double(score)) * 10)&#125;func change2(score: Int) -&gt; Int &#123;    return score + 3&#125;var scores1 = [36, 61, 78, 89, 99]changeScores(&amp;scores1, by: change1) // [60, 78, 88, 94, 99]var scores2 = [88, 101, 124, 137, 150]changeScores(&amp;scores2, by: change2) // [91, 104, 127, 140, 153]\n4. 高阶函数map、filter、reduce12345678910111213141516171819202122232425262728293031func change(num: Int) -&gt; Int &#123;    return num + 2&#125;var numbers = [65, 91, 45, 89, 99]// mapnumbers.map(change) //[67, 93, 47, 91, 101]func isPassOrFail(num: Int) -&gt; String &#123;    return num &lt; 60 ? \"Fail\" : \"Pass\"&#125;numbers.map(isPassOrFail) //[\"Pass\", \"Pass\", \"Fail\", \"Pass\", \"Pass\"]// filterfunc fail(num: Int) -&gt; Bool &#123;    return num &lt; 60&#125;numbers.filter(fail) //[45]// reducefunc add(num1: Int, num2: Int) -&gt; Int &#123;    return num1 + num2&#125;numbers.reduce(0, add) //389numbers.reduce(0, +) //389func concatenate(str: String, num: Int) -&gt; String &#123;    return str + String(num) + \" \"&#125;numbers.reduce(\"\", concatenate) //\"65 91 45 89 99 \"\n5. 函数作为函数的返回类型12345678910111213141516171819func tier1MailFee(weight: Int) -&gt; Int &#123;    return 1 * weight&#125;func tier2MailFee(weight: Int) -&gt; Int &#123;    return 3 * weight&#125;func feeByUnitPrice(price: Int, weight: Int) -&gt; Int &#123;    // 函数作为函数的返回类型    func chooseMailFee(by weight: Int) -&gt; (Int) -&gt; Int &#123;        return weight &lt;= 10 ? tier1MailFee : tier2MailFee    &#125;    let mailFeeByWeight = chooseMailFee(by: weight)    return mailFeeByWeight(weight) + price * weight&#125;feeByUnitPrice(price: 50, weight: 8)\n闭包1. 基本使用方式123456789101112var arr = [3, 2, 4, 5, 8]// 之前的写法func bigger(a: Int, b: Int) -&gt; Bool &#123;    return a &gt; b&#125;arr.sort(by: bigger) // [8, 5, 4, 3, 2]// 闭包的写法arr.sort(by: &#123; (a: Int, b: Int) -&gt; Bool in    return a &gt;  b&#125;) // [8, 5, 4, 3, 2]\n2. 上面的代码可简写1234567891011121314// 如果闭包只有一行代码，可放在同一行arr.sort(by: &#123; (a: Int, b: Int) -&gt; Bool in return a &gt; b &#125;)// 由于自动会得到参数和返回值类型， 可这样写arr.sort(by: &#123; a, b in return a &gt; b&#125;)// 由于知道需要return，可简写为arr.sort(by: &#123; a, b in a &gt; b&#125;)// 由于参数是一个元组，元组有标识，可简写为arr.sort(by: &#123; $0 &gt; $1 &#125;)// 由于“&gt;”本身就是一个函数arr.sort(by: &gt;)\n3. 结尾闭包的使用12345678910111213141516171819202122232425var arr = [3, 2, 4, 5, 8]arr.sort(by: &#123; a, b in return a &gt; b &#125;)// 如果函数参数在最后，我们可以是使用结尾闭包arr.sort() &#123; a, b in    return a &gt; b&#125;// 如果没有其他参数，可将小括号夜省略了arr.sort &#123; a, b in    return a &gt; b&#125;// 将数组中的十进制数字全部改为二进制arr.map&#123; number -&gt; String in    // 将number的不可变改为可变    var number = number    var res = \"\"    repeat &#123;        res = String(number % 2) + res        number /= 2    &#125; while number != 0    return res&#125;\n4. 尾闭包在IOS动画中的运用12345678910111213let showView = UIView(frame: CGRect(x: 0, y: 0, width: 300, height: 300))let rectangle = UIView(frame: CGRect(x: 0, y: 0, width: 50, height: 50))rectangle.center = showView.centerrectangle.backgroundColor = UIColor.redshowView.addSubview(rectangle)UIView.animate(withDuration: 2.0) &#123;    rectangle.backgroundColor = UIColor.blue    rectangle.frame = showView.frame&#125;import PlaygroundSupportPlaygroundPage.current.liveView = showView\n5. 闭包，内容捕获123456// 数值捕获// 申明变量var num = 300arr.sort&#123; a , b in    abs(a-num) &lt; abs(b-num)&#125;\n6. 闭包和函数是引用类型12345678910111213func runningMetersWithMetersPerDay(_ metersPerDay: Int) -&gt; () -&gt; Int &#123;    var totalMeters = 0    return &#123;        totalMeters += metersPerDay        return totalMeters    &#125;&#125;var planA = runningMetersWithMetersPerDay(2000)// 注意每次都不是从0开始相加，因为返回的是闭包的引用planA() //2000planA() //4000planA() //6000\nenum1. 枚举的基本使用123456789101112131415161718192021222324252627282930313233343536// 定义枚举类型enum Month &#123;    case January    case February    case March    case April    case May    case June    case July    case August    case September    case October    case November    case December&#125;// 定义枚举也可以写成一行enum Season &#123;    case Spring, Summer, Autumn, Winter&#125;// 如果确定了枚举类型，则可以省略枚举名字，如：Month.March 写成 .Marchfunc season(month: Month) -&gt; Season &#123;    switch month &#123;    case .March, .April, .May:        return .Spring    case .June, .July, .August:        return .Summer    case .September, .October, .November:        return .Autumn    case .December, .January, .February:        return .Spring    &#125;&#125;season(month: Month.April) //Spring\n2. 枚举的原始值1234567891011121314151617181920212223242526272829303132333435363738394041// enum Month: Int 表名Month的原始值是int类型的，并且原始值会自动递增enum Month: Int&#123;    case January = 1, Febuary, March, April, May, June, July, August, September, October, November, December&#125;// 返回距离新的一年还有多少个月，rawValue得到原始值func monthBeforeNewYear(month: Month) -&gt; Int &#123;    return 12 - month.rawValue&#125; // 4// 可以通过原始值获取到对应的枚举值if let theMonth = Month(rawValue: 8) &#123;    print(\"\\(monthBeforeNewYear(month: theMonth)) months before New Year!\") //4 months before New Year!&#125;// raw value为整型的枚举类型，如果不显示给出整型值，则从0开始enum Grade: Int&#123;    case F,E,D,C,B,A&#125;// 枚举类型的raw value值不一定是顺序的enum Coin: Int&#123;    case Penny = 1    case Nickel = 5    case Dime = 10    case Quarter = 25&#125;let coin: Coin = .Quarterprint(\"It's \\(coin.rawValue) cents\") //It's 25 cents// 使用String作为raw value，如果我们没有确定原始值，那么swift会自动以枚举值的名字作为原始值enum ProgrammingLanguage2: String&#123;    case Swift    case ObjectiveC = \"Objective-C\"    case C    case Java&#125;let myFavoriteLanguage2: ProgrammingLanguage2 = .Swiftprint( \"\\(myFavoriteLanguage2.rawValue) is my favorite language.\") //Swift is my favorite language.\n3. 并联值12345678910111213141516171819202122232425262728293031// Associate Value 和 Raw value 只能存在一个enum ATMStatus &#123;    case Success(Int)    case Error(String)    case Waiting // 也可以没有Associate Value&#125;// 余额var balance = 1000// 获取ATMStatusfunc withdraw(amount: Int) -&gt; ATMStatus &#123;    if balance &gt;= amount &#123;        balance -= amount        return .Success(balance)    &#125;    else &#123;        return .Error(\"Not enough money\")    &#125;&#125;// 解包相应的 Associate Value，也可忽略，就像.Waiting那样就行了switch withdraw(amount: 100) &#123;case let .Success(newBlance):    print(\"\\(newBlance) Yuan left in your account\")case let .Error(errorMesssage):    print(\"Error:\\(errorMesssage)\")case .Waiting:    print(\"Waiting for processing\")&#125;\n4. 有多个并联值的情况1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Associate value其实只有一个，其实下面表示的是一个元组，并且为元组类型取了个名字enum Shape &#123;    case Square(side: Double)    case Rectangle(width: Double, height: Double)    case Circle(centerx: Double, centery: Double, radius: Double)    case Point&#125;// 初始化一些图形let square = Shape.Square(side: 10)let rectangle = Shape.Rectangle(width: 20, height: 30)let circle = Shape.Circle(centerx: 0, centery: 0, radius: 15)let point = Shape.Point// 计算表面积func area(shape: Shape) -&gt; Double &#123;    switch shape &#123;    case let .Square(side):        return side * side    case let .Rectangle(width, height):        return width * height    case let .Circle(_, _, r): // 通过下划线忽略不用的参数        return .pi * r * r    case .Point:        return 0    &#125;&#125;// 得出表面积的结果area(shape: square)area(shape: rectangle)area(shape: circle)area(shape: point)// ====================================================================// enum可以有方法enum Shape&#123;    case Square(side: Double)    case Rectangle(width: Double, height: Double)    case Circle(centerx: Double, centery: Double, radius: Double)    case Point    func area() -&gt; Double&#123;        switch self &#123;        case let .Square(side):            return side*side        case let .Rectangle( width , height ):            return width * height        case let .Circle( _ , _ , r ):            //swift 2: return M_PI*r*r            //swift3中PI放在了Double类下。这样是不是更方便记忆？            return .pi*r*r      //swift 3        case .Point:            return 0        &#125;    &#125;&#125;// 使用let square = Shape.Square(side: 10)square.area()\n5. 可选型实际上是枚举类型123456789101112131415161718192021222324var age: Int? = 17print(age!)age = nil// 可以看到可选类型可以通过枚举的方式赋值age = .some(2) // 2var website: Optional&lt;String&gt; = Optional.some(\"blog.xujiaji.com\")website = .none // nil// 以enum的角度来进行解包switch website &#123;case .none:    print(\"No website\")case let .some(website):    print(\"The website is \\(website)\")&#125;// 以Optional的方式解包if let website = website &#123;    print(\"The website is \\(website)\")&#125;else &#123;    print(\"No website\")&#125;\n6. 枚举的递归调用123456789101112131415161718192021222324252627// 枚举递归，使用indirect关键字。也可以直接加在enum关键字后面（如：enum indirect ArithmeticExpression），此时case关键字前面就不必加了enum ArithmeticExpression &#123;    case Number(Int)    indirect case Addition(ArithmeticExpression, ArithmeticExpression)    indirect case Multiplication(ArithmeticExpression, ArithmeticExpression)&#125;// 计算 (5 + 4) * 2let five = ArithmeticExpression.Number(5)let four = ArithmeticExpression.Number(4)let sum = ArithmeticExpression.Addition(five, four)let two = ArithmeticExpression.Number(2)let prouct = ArithmeticExpression.Multiplication(sum, two)func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123;    switch expression &#123;    case let .Number(value):        return value    case let .Addition(left, right):        return evaluate(left) + evaluate(right)    case let .Multiplication(left, right):        return evaluate(left) * evaluate(right)    &#125;&#125;// 计算结果evaluate(prouct)\n7. 枚举是值类型\nstruct1. 结构体的基本使用123456789101112131415161718192021222324// 声明一个结构体struct Location &#123;    let latitude: Double    let longitude: Double&#125;// 初始化结构体let appleHeadQuarterLocation = Location(latitude: 37.3230, longitude: -122.0322)let googleHeadQuarterLocation: Location = Location(latitude: 37.4220, longitude: -122.0841)// 获取属性值appleHeadQuarterLocation.latitudegoogleHeadQuarterLocation.longitude// 结构体中有结构体struct Place &#123;    let location: Location    var name: String&#125;var googleHeadQuarter = Place(location: googleHeadQuarterLocation, name: \"Google\")// 因为声明的是var，所以可修改googleHeadQuarter.name = \"G\"\n2. 结构体的初始化结构体重定义的常量或变量都必须初始化。可选型可以不用初始化，因为默认初始值为nil，试了下可选型需要是var，如果是let，则必须直接赋值。123456789101112131415161718192021222324252627282930313233343536struct Location &#123;    let latitude: Double    let longitude: Double    // 自定义构造， 当自己写了构造函数后就没有了默认的构造函数    init(coordinateString: String) &#123;        let commaIndex = coordinateString.range(of: \",\")!.lowerBound //得到逗号的下标        let firstElement = coordinateString[..&lt;commaIndex]        let secondElement = coordinateString[coordinateString.index(after: commaIndex)...]        latitude = Double(firstElement)!        longitude = Double(secondElement)!    &#125;    // 当没有默认的构造的时候，我们可以自己添加这个构造    init(latitude: Double, longitude: Double) &#123;        self.latitude = latitude        self.longitude = longitude    &#125;    init() &#123;        latitude = 0.0        longitude = 0.0    &#125;    // 默认初始值为nil    var placeName: String?    init(latitude: Double, longitude: Double, placeName: String) &#123;        self.latitude = latitude        self.longitude = longitude        self.placeName = placeName    &#125;&#125;let location = Location(coordinateString: \"111.1234,222.3333\")location.latitude // 111.1234location.placeName // nil\n3. 失败的构造函数\n\n就是说构造函数可以是失败的，当我们return nil时候。也就是说我们初始化结构体的时候得到的是可选型\n用guard可以轻松简化if else嵌套的判断代码\n\n12345678910111213141516171819struct Location &#123;    let latitude: Double    let longitude: Double    init?(coordinateString: String) &#123;        guard let commaIndex = coordinateString.range(of: \",\")?.lowerBound else &#123;            return nil        &#125;        guard let firstElement = Double(coordinateString[..&lt;commaIndex]) else &#123;            return nil        &#125;        guard let secondElement = Double(coordinateString[coordinateString.index(after: commaIndex)...]) else &#123;            return nil        &#125;        latitude = firstElement        longitude = secondElement    &#125;&#125;\n\nguard还可以将上面的代码优化\n\n12345678910111213141516struct Location &#123;    let latitude: Double    let longitude: Double    init?(coordinateString: String) &#123;        guard            let commaIndex = coordinateString.range(of: \",\")?.lowerBound,            let firstElement = Double(coordinateString[..&lt;commaIndex]),            let secondElement = Double(coordinateString[coordinateString.index(after: commaIndex)...])        else &#123;            return nil        &#125;        latitude = firstElement        longitude = secondElement    &#125;&#125;\n4. 结构体中可定义方法， 这里直接在上面代码中添加方法123456789101112131415161718struct Location &#123;    ...    func printLocation() &#123;        print(\"The Location is \\(self.latitude), \\(self.longitude)\")    &#125;    func isNorth() -&gt; Bool &#123;        return self.latitude &gt; 0    &#125;    func isSouth() -&gt; Bool &#123;        return !self.isNorth()    &#125;    func distanceTo(location: Location) -&gt; Double &#123;        return sqrt(pow(self.latitude - location.latitude, 2) + pow(self.longitude - location.longitude, 2))    &#125;&#125;\n5. 结构体是值类型的，就是当做值来出来，赋值即是拷贝6. Int, Float, Double, Bool, String, Array, Dictionary, Set 等都是结构体\nclass1. 类的基本使用方式类不像结构体一样，类不能自动初始化，因此我们需要自己为变量赋值12345678910111213141516171819202122232425262728class Person &#123;    var firstName: String    var lastName: String    init(firstName: String, lastName: String) &#123;        self.firstName = firstName        self.lastName = lastName    &#125;    // 类和结构体一样，也可以定义可以失败的构造    init?(fullName: String) &#123;        guard let spaceIndex = fullName.range(of: \" \")?.lowerBound else &#123;            return nil        &#125;        firstName = String(fullName[..&lt;spaceIndex])        lastName = String(fullName[fullName.index(after: spaceIndex)...])    &#125;    func fullName() -&gt; String &#123;        return \"\\(self.firstName) \\(self.lastName)\"    &#125;&#125;let person1 = Person(firstName: \"Alexander\", lastName: \"Hamilton\")person1.fullName() // \"Alexander Hamilton\"let person2 = Person(fullName: \"Jiaji Xu\")person2?.firstName //\"Jiaji\"\n2. 类是引用类型1234567891011121314class Person &#123;    var name: String    init(name: String) &#123;        self.name = name    &#125;&#125;let person1 = Person(name: \"Tom\")person1.name // Tomlet person2 = person1person2.name = \"Bob\"person2.name // Bobperson1.name // Bob\n3. 方法的可变和不可变\n\n类的方法中可改变变量的值\n\n123456789101112131415class Person &#123;    var name: String    var career: String    init(name: String, career: String) &#123;        self.name = name        self.career = career    &#125;    func change(career: String) &#123;        self.career = career    &#125;&#125;let person = Person(name: \"Bob\", career: \"Developer\")person.change(career: \"Teacher\")\n\n结构体由于是值传递，所以不可改变变量的值，像上面写会报错，提示immutable（不可变）。但是可以为方法加上关键字mutating，每次改变都会创建一个新的副本覆盖旧的值\n\n1234567891011121314151617181920enum Switch&#123;    case On    case Off    mutating func click()&#123;        switch self&#123;        case .On:            self = .Off        case .Off:            self = .On        &#125;    &#125;&#125;var button = Switch.Offbutton.click()var button2 = Switch.Onbutton == button2\n4. 类与类之间的等价，比较两个变量是否指向的同一个东西1234567891011121314151617class Person &#123;    var name: String    init(name: String) &#123;        self.name = name    &#125;&#125;let person1 = Person(name: \"Bob\")let person2 = person1// 不能使用“==”判断：// person1 == person2person1 === person2 // truelet person3 = Person(name: \"Bob\")person1 === person3 // falseperson1 !== person3 // true\n5. 什么时候用类什么时候用结构体\n\n把结构体看作是值\n位置 （经纬度）\n坐标 （二维，三维坐标）\n温度\n…\n\n\n把类看作是物体\n人\n车\n动物\n…\n\n\n如果不希望每次传递都创建一个新的副本，那么就用类，否则用结构体\n类可以被继承\n结构体比类更加“轻量级”\n\n属性和方法1. 计算型属性：自动更具其他信息计算出值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859struct Point &#123;    var x = 0.0    var y = 0.0&#125;struct Size &#123;    var width = 0.0    var height = 0.0&#125;class Rectangle &#123;    var origin: Point    var size: Size    init(origin: Point, size: Size) &#123;        self.origin = origin        self.size = size    &#125;    // 写法一//    var center: Point &#123;//        let centerX = origin.x + size.width / 2//        let centerY = origin.y + size.height / 2//        return Point(x: centerX, y: centerY)//    &#125;    // 写法二//    var center: Point &#123;//        get &#123;//            let centerX = origin.x + size.width / 2//            let centerY = origin.y + size.height / 2//            return Point(x: centerX, y: centerY)//        &#125;//    &#125;    // 写法三：上面的写法是只读的，无法为center赋值。如果要赋值，则需要些setter    var center: Point&#123;        get&#123;            let centerX = origin.x + size.width/2            let centerY = origin.y + size.height/2            return Point(x: centerX, y: centerY)        &#125;        // (newCenter)可以被省略        // 在setter的&#123;&#125;中用默认名称newValue代替传入值        set(newCenter)&#123;            origin.x = newCenter.x - size.width/2            origin.y = newCenter.y - size.height/2        &#125;    &#125;&#125;var rect = Rectangle(origin: Point(), size: Size(width: 10, height: 5))rect.center// 写法三可为center赋值，并且会自动改变坐标rect.center = Point(x: 10, y: 10)rect\n2. 类型属性（Type Property），静态变量就和java中的静态变量差不多，写法也一样，不过必须通过类型名获取12345class Player &#123;    // 定义类型属性，不能通过self.来引用，类中也不可直接引用    // 不论创建多少个实例，都只存在一个该变量    static var highestScore = 0&#125;\n3. 类型方法（Type Method），静态方法，这里举了一个创建单位矩阵的类型方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263struct Matrix &#123;    var m: [[Int]]    var row: Int    var col: Int    init?(_ arr2d: [[Int]]) &#123;        guard arr2d.count &gt; 0 else &#123;            return nil        &#125;        let row = arr2d.count        let col = arr2d[0].count        for i in 1..&lt;row &#123;            if arr2d[i].count != row &#123;                return nil            &#125;        &#125;        self.m = arr2d        self.row = row        self.col = col    &#125;    static func identityMatrix(n: Int) -&gt; Matrix? &#123;        if n &lt; 0 &#123;            return nil        &#125;        var arr2d: [[Int]] = []        for i in 0..&lt;n &#123;            var row = [Int](repeating: 0, count: n)            row[i] = 1            arr2d.append(row)        &#125;        return Matrix(arr2d)    &#125;    func printMatrix() &#123;        for i in 0..&lt;row &#123;            for j in 0..&lt;col &#123;                print(m[i][j], terminator: \"\\t\")            &#125;            print()        &#125;    &#125;&#125;let m = Matrix([[1, 2], [3, 4]])m?.printMatrix()// 直接通过类型名直接调用let e = Matrix.identityMatrix(n: 6)e?.printMatrix()//输出//1    2//3    4//1    0    0    0    0    0//0    1    0    0    0    0//0    0    1    0    0    0//0    0    0    1    0    0//0    0    0    0    1    0//0    0    0    0    0    1\n4. 属性观察器\n\n注意willSet和didSet不会在变量直接初始化和构造方法中被调用\n一个电灯的案例\n\n1234567891011121314151617181920212223242526272829303132333435363738394041class LightBulb &#123;    static let maxCurrent = 30    var current = 0 &#123;        // 可以不声明变量名newCurrent，可直接使用newValue        // 如其名，此时是在设置新值之前被调用        willSet(newCurrent) &#123;            // 此时， current还是以前的值            print(&quot;|\\(current)-\\(newCurrent)| = \\(abs(current - newCurrent))&quot;)        &#125;        // Property observer 可以用来限制值或格式        // 也可以用来并联逻辑        // 可以不声明变量oldCurrent，可直接使用oldValue获取原来的值        // 如其名，此时是已经设置好新的值后被调用        didSet(oldCurrent) &#123;            if current == LightBulb.maxCurrent &#123;                print(&quot;Pay attention, the current value get to the maxinum point.&quot;)            &#125;            else if current &gt; LightBulb.maxCurrent&#123;                print(&quot;Current too high, falling back to previous setting.&quot;)                current = oldCurrent            &#125;            print(&quot;The current is \\(current)&quot;)        &#125;    &#125;&#125;let bulb = LightBulb()bulb.current = 20bulb.current = 30bulb.current = 40//结果//|0-20| = 20//The current is 20//|20-30| = 10//Pay attention, the current value get to the maxinum point.//The current is 30//|30-40| = 10//Current too high, falling back to previous setting.//The current is 30\n\n一个主题切换的案例\n\n1234567891011121314151617181920212223242526272829303132333435363738394041enum Theme &#123;    case DayMode    case NightMode&#125;class UI &#123;    var fontColor: UIColor!    var backgroundColor: UIColor!    var themeMode: Theme = .DayMode &#123;        // 每当改变了主题的时候，就去改变对应的配色        didSet &#123;            self.changeMode(themeMode)        &#125;    &#125;    init() &#123;        self.themeMode = .DayMode        self.changeMode(themeMode)    &#125;    // 由于多处用到于是提取出来    func changeMode(_ newMode: Theme) &#123;        switch newMode &#123;        case .DayMode:            fontColor = UIColor.black            backgroundColor = UIColor.white        case .NightMode:            fontColor = UIColor.white            backgroundColor = UIColor.black        &#125;    &#125;&#125;let ui = UI()ui.themeModeui.fontColor //  黑ui.backgroundColor // 白ui.themeMode = .NightModeui.fontColor // 白ui.backgroundColor // 黑\n5. 延迟属性（Lazy Property）123456789101112131415161718192021222324252627282930313233class ClosedRange &#123;    let start: Int    let end: Int    // 每次调用都会重新计算    var width: Int &#123;        return end - start + 1    &#125;    // 使用懒加载，只有第一次调用是才会计算，解决资源重复计算或读取等问题    lazy var sum: Int = &#123;        var res = 0        for i in self.start...self.end &#123;            res += i        &#125;        return res    &#125;()    init?(start: Int, end: Int) &#123;        if start &gt; end &#123;            return nil        &#125;        self.start = start        self.end = end    &#125;&#125;if let range = ClosedRange(start: 0, end: 10_000) &#123;    range.width    range.sum    range.sum    range.sum&#125;\n6. 访问控制\n\nprivate 私有访问控制，标识了的变量和方法只能在同一个文件中才能访问\ninternal 默认访问控制，同一个目录下可访问\npublic 公有访问控制，标识后任何地方都可访问\n\n7. 单例模式123456789101112131415161718192021222324// Sources文件夹中 GameManager.swiftpublic class GameManager &#123;    public static let defaultManager = GameManager()    public var score = 0    public var level = 0    private init() &#123;    &#125;    public func addScore() &#123;        score += 10    &#125;&#125;// 主文件中let gameManager = GameManager.defaultManagergameManager.addScore()gameManager.score // 10let gm = GameManager.defaultManagergm.addScore()gm.score // 20\n继承和构造函数1. 继承基本使用方式继承某个类使用冒号”:”跟上继承的类继承可以使用父类中非私有的属性（不在一个文件的情况下）final关键字可以让该类不再有子类123456789101112131415161718192021222324252627282930313233class Avatar &#123;    var name: String    var life = 100 // 血条    var isAlive: Bool = true // 是否存活    init(name: String) &#123;        self.name = name    &#125;    // 被攻击时调用    func beAttacked(attack: Int) &#123;        life -= attack        if life &lt;= 0 &#123;            isAlive = false        &#125;    &#125;&#125;// 继承class User: Avatar &#123;    var leve = 0&#125;let player = User(name: \"Jiaji\")player.nameplayer.lifeplayer.beAttacked(attack: 20)player.life// 使用final，表示最终的类，阻止进一步的继承final class Magician: User &#123;    var magic = 100&#125;\n2. 多态123456789101112131415161718192021222324252627282930313233// 简化大量代码class Avatar &#123;    var name: String    init(name: String) &#123;        self.name = name    &#125;&#125;class User: Avatar &#123;&#125;final class Magician: User &#123;&#125;class Monster: Avatar &#123;&#125;// 多态func printName(avatar: Avatar) &#123;    print(\"name is \\(avatar.name)\")&#125;let user = User(name: \"Bob\")let user2 = Magician(name: \"Tom\")let mons = Monster(name: \"no1\")// 只要都是继承Avatar那么就可以传入这个方法， 不在乎具体的类printName(avatar: user)printName(avatar: user2)printName(avatar: mons)//结果//name is Bob//name is Tom//name is no1\n3. 重载， 通过关键字override即可复写父类中的成员私有成员无法覆写；final成员无法覆写；123456789101112131415161718192021222324252627282930313233343536373839404142class SuperClass &#123;    var description: String &#123;        return \"This is SuperClass\"    &#125;    func fun1() &#123;        print(\"SuperClass fun1()\")    &#125;    // 标记了final后，无法被子类覆写    final func fun2() &#123;        print(\"SuperClass fun2()\")    &#125;&#125;class SubClass: SuperClass &#123;    override var description: String &#123;        return \"This is SubClass\"    &#125;    override func fun1() &#123;        print(\"SubClass fun1()\")    &#125;&#125;let claz = SuperClass()let claz2 = SubClass()let arr: [SuperClass] = [claz, claz2]for c in arr &#123;    print(c.description)    c.fun1()    c.fun2()&#125;//结果//This is SuperClass//SuperClass fun1()//SuperClass fun2()//This is SubClass//SubClass fun1()//SuperClass fun2()\n4. 子类构造中调用父类构造\n\n必须将子类初始化完成，才能调用父类构造初始化父类\n通过super.init调用父类构造\n\n5. 两段式构造\n\n第一段：构造初值\n在所有变量没有初始化完成之前，不能调用其他方法\n父类的成员变量，即使有初始值，也不能使用\n可以涉及逻辑，但逻辑不能涉及到self\n静态的可以使用\n\n\n调用super构造(如果需要的话)\n第二段：所有成员变量初始化完成以后，进行成员变量相关的逻辑调整\n\n6. 方便的构造函数和指定的构造函数一般的构造就是指定的构造函数；加了convenience的构造就是方便的构造函数，方便的构造函数只能self调用该类的指定构造函数；123456789101112131415161718192021class Avatar &#123;    var name: String    // 这种叫做指定构造函数    init(name: String) &#123;        self.name = name    &#125;&#125;class User: Avatar &#123;    // 这种叫做指定构造函数    override init(name: String) &#123;        super.init(name: name)    &#125;    // 这种叫做方便的构造函数，convenience直接翻译过来就是：方便    // 方便的构造函数只能调用该类自身的构造函数，不能调用super的    // 要调用该类自身的构造，必须加上convenience    convenience init(firstName: String, lastName: String) &#123;        self.init(name: \"\\(firstName) \\(lastName)\")    &#125;&#125;\n7. 子类构造函数的继承如果子类没有实现任何父类的指定构造函数，则自动继承父类的所有指定构造函数；如果子类实现了父类所有的指定构造函数，则自动继承父类的所有便利构造函数；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Avatar &#123;    var name: String    init(name: String) &#123;        self.name = name    &#125;//    init(num: Int) &#123;//        self.name = String(num)//    &#125;    convenience init(firstName: String, lastName: String) &#123;        self.init(name: \"\\(firstName) \\(lastName)\")    &#125;&#125;//实现了父类所有指定构造的情况下，如果想看没有实现完的情况，将Avatar注释的代码放开class User: Avatar &#123;    var group: String    init(name: String, group: String) &#123;        self.group = group        super.init(name: name)    &#125;    convenience init(group: String) &#123;        let name = User.generateUserName()        self.init(name: name, group: group)    &#125;    convenience override init(name: String) &#123;        self.init(name: name, group: \"\")    &#125;    static func generateUserName() -&gt; String&#123;        return \"Player\" + String(Int(arc4random()%1_000_000))    &#125;&#125;// 没有实现任何指定构造的情况class Monster: Avatar &#123;    // 子类没有实现任何父类构造的情况,自动继承父类的所有指定构造函数    // 可直接用self调用，相当于Monster已经有了init(name: type)    convenience init(type: String)&#123;        self.init(name: type)    &#125;&#125;//如果将Avatar中的init(num: Int)的构造的注释解开该句实例化将会报错，因为放开后，子类User并没有实现父类的init(num: Int)let user = User(firstName: \"John\", lastName: \"Snow\")// 可以通过三种方式实例化，其中第二种继承自父类，第三种父类的方便构造能直接使用let zombie = Monster(type: \"Zombie\")let zombie2 = Monster(name: \"Zombie\")let zombie3 = Monster(firstName: \"Mr.\", lastName: \"Zombie\")\n8. required构造123456789101112131415161718192021222324252627class Avatar &#123;    var name: String    // 表示子类必须实现该构造方法    required init(name: String) &#123;        self.name = name    &#125;    init(num: Int) &#123;        self.name = String(num)    &#125;&#125;// 如果没有实现任何父类指定构造，那么默认会实现所有父类指定构造class NPC:Avatar &#123;&#125;class User: Avatar &#123;    override init(num: Int) &#123;        super.init(num: num)    &#125;    // 如果重写了一个父类构造（如上面的构造），那么必须实现父类强制要实现的构造    required init(name: String) &#123;        super.init(name: name)    &#125;&#125;\n9. 结构体中的构造由于结构体中没有继承的关系，所以不用申明是方便的构造表示要调用自己的构造。123456struct TestInit &#123;    init(a: Int) &#123;&#125;    init(b: Int, c: Int) &#123;        self.init(a: b + c) // 直接self调用就行了    &#125;&#125;\n文档注释1. 多行文档注释1234/**多行文档注释多行文档注释*/\n2. 单行文档注释，多个单行合在一起和多行效果一样1/// 单行文档注释\n3. 使用的是Markdown格式书写4. 参数注释1123/// - Parameter item1: This is item1/// - Parameter item2: This is item2func show2(item1: String, item2: String) &#123;&#125;\n5. 参数注释21234/// - Parameters:///   - item1: This is item1///   - item2: This is item2func show2(item1: String, item2: String) &#123;&#125;\n6. 返回信息、异常信息注释12345/// - Returns: the result String./// - Throws: nil errorfunc show1() throws -&gt; String &#123;    return &quot;&quot;&#125;\n7. 一些对于算法或其他用途的一些关键字123456789101112131415161718192021/// 对于算法或其他用途的一些关键字 `Precondition`, `Postcondition`, `Requires`, `Invariant`, `Complexity`, `Important` and `Warning`.////// 假设这是一个算法////// - Precondition: 前置条件/// - Postcondition: 后置条件/// - Requires: 算法所需要的内容/// - Invariant: 循环不变量/// - Complexity: 复杂度/// - Important: 一些重要的信息/// - Warning: 一些警告信息/// - Attention: 一些警告信息/// - Note: 一些相应的记录/// - Remark: 一些评论////// - Parameter object: The algorithm will use this single object to change the world./// - Throws: `MyError.JustImpossible` if the algorithm&apos;s precondition can not be satisfied./// - Returns: the object contains all the information in the universe.func mysteriousAlgorithm(object: AnyObject) &#123;    return&#125;\n8. 一些元信息123456789/// - Author: 作者/// - Author: 几个人一起完成.../// - Copyright: 版权信息/// - Date: 时间/// - Since: 项目起始日期/// - Version: 对应的版本号func show() &#123;&#125;\n9. MARK\n\n分割类视图\n\n1// MARK: -\n\n添加分割类视图并添加该区域标题\n\n1// MARK: - Methods\n10. TODO在类视图中建立任务提醒1// TODO: 以后在这里要干嘛干嘛\n11. FIXME需要修复，但占时无关紧要，在类视图中会有提醒1// FIXME: Support Swift 2.2\n下标1. 基本使用方式可以自己定义下标的类型，如同数组和字典一样访问方式；需要关键字subscript；12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct Vector3 &#123;    var x: Double = 0.0    var y: Double = 0.0    var z: Double = 0.0    // 参数类型可以随意指定    // 需要有个返回值    // 如果需要通过下标来设置值，则需要添加set    subscript(index: Int) -&gt; Double? &#123;        get &#123;            switch index &#123;            case 0: return x            case 1: return y            case 2: return z            default: return nil            &#125;        &#125;        set &#123;            guard let newValue = newValue else &#123; return &#125;            switch index &#123;            case 0: x = newValue            case 1: y = newValue            case 2: z = newValue            default: return            &#125;        &#125;    &#125;    subscript(axis: String) -&gt; Double? &#123;        switch axis &#123;        case \"x\", \"X\": return x        case \"y\", \"Y\": return y        case \"z\", \"Z\": return z        default: return nil        &#125;    &#125;&#125;var v = Vector3(x: 1.0, y: 2.0, z: 3.0)v[0] // 1// 添加了set才能设置值v[0] = 100.0 // 100v[\"x\"] // 100\n2. 多维下标可定义多个下标；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Matrix &#123;    var data: [[Double]]    let r: Int    let c: Int    init(row: Int, col: Int) &#123;        self.r = row        self.c = col        self.data = [[Double]]()        for _ in 0..&lt;r &#123;            let aRow = Array(repeating: 0.0, count: col)            data.append(aRow)        &#125;    &#125;    // 返回确切有值    subscript(x: Int, y: Int) -&gt; Double &#123;        get&#123;            assert( x &gt;= 0 &amp;&amp; x &lt; r &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; c , \"Index Out of Range\")            return data[x][y]        &#125;        set&#123;            assert( x &gt;= 0 &amp;&amp; x &lt; r &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; c , \"Index Out of Range\")            data[x][y] = newValue        &#125;    &#125;    // 如果想使用 m[1][1]    subscript(row: Int) -&gt; [Double]&#123;        get&#123;            assert( row &gt;= 0 &amp;&amp; row &lt; r , \"Index Out of Range\")            return data[row]        &#125;        set(vector)&#123;            assert( vector.count == c , \"Column Number does NOT match\")            data[row] = vector        &#125;    &#125;&#125;var m = Matrix(row: 2, col: 2)//m[2,2]m[1,1] = 1// 如果想使用 m[1][1]m[1][1]m[1]m[0] = [1.5,4.5]\n运算符重载运算符本身就是一个函数1. 重载运算符基本操作1234567891011121314151617181920// 重载运算符func + (left: Vector3, right: Vector3) -&gt; Vector3 &#123;    return Vector3(x: left.x + right.x, y: left.y + right.y, z: left.z + right.z)&#125;// 重载单目运算符，prefix表示 - 是一个前置运算符，相对应的是postfixprefix func - (v: Vector3) -&gt; Vector3 &#123;    return Vector3(x: -v.x, y: -v.y, z: -v.z)&#125;// 重载 += 这种运算static func += (left: inout Vector3, right: Vector3) &#123;    left = left + right&#125;let va = Vector3(x: 1.0, y: 2.0, z: 3.0)let vb = Vector3(x: 3.0, y: 4.0, z: 5.0)let vc = vb + vavc.x\n2. 重载比较运算符1234567891011121314// 重载比较运算符func == (left: Vector3, right: Vector3) -&gt; Bool &#123;    return left.x == right.x &amp;&amp; left.y == right.y &amp;&amp; left.z == right.z&#125;func != (left: Vector3, right: Vector3) -&gt; Bool &#123;    return !(left == right)&#125;let va = Vector3(x: 1.0, y: 2.0, z: 3.0)let vb = Vector3(x: 3.0, y: 4.0, z: 5.0)va == vbva != vb\n3. 自定义运算符如果是ASCII字符，只能是：/ = - + ! * % &lt; &gt; &amp; | ^ ~之开头 。或者是Unicode的字符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct Vector3 &#123;    var x: Double = 0.0    var y: Double = 0.0    var z: Double = 0.0    func length() -&gt; Double &#123;        return sqrt(x*x + y*y + z*z)    &#125;&#125;func + (left: Vector3, right: Vector3) -&gt; Vector3&#123;    return Vector3(x: left.x + right.x, y: left.y + right.y, z: left.z + right.z)&#125;func * (left: Vector3, right: Vector3) -&gt; Double&#123;    return left.x * right.x + left.y * right.y + left.z * right.z&#125;func += (left: inout Vector3, right: inout Vector3)&#123;    left = left + right&#125;// 单目运算符的定义postfix operator +++postfix func +++ (vector: inout Vector3) -&gt; Vector3 &#123;    var addOn = Vector3(x: 1.0, y: 1.0, z: 1.0)    vector += addOn    return vector&#125;prefix operator +++prefix func +++ (vector: inout Vector3) -&gt; Vector3 &#123;    let res = vector    var addOn = Vector3(x: 1.0, y: 1.0, z: 1.0)    vector += addOn    return res&#125;// 双目运算符的定义// 计算两个向量的夹角infix operator ^func ^ (left: Vector3, right: Vector3) -&gt; Double &#123;    return acos((left * right) / (left.length() * right.length()))&#125;//计算阶层，定义优先组precedencegroup ExponentPrecedence&#123;    // 是从左向右计算还是从右向左计算    associativity: left    // 定义优先级，用lowerThan或higherThan来定义    higherThan: MultiplicationPrecedence&#125;infix operator **: ExponentPrecedencefunc **(x: Double, p: Double) -&gt; Double &#123;    return pow(x, p)&#125;1+2**3**2 // 65var va = Vector3(x: 1.0, y: 2.0, z: 3.0)var vb = Vector3(x: 3.0, y: 4.0, z: 5.0)va++++++vbva ^ vb\nExtension1. 基本使用方式扩展；扩展属性时，只能扩展计算型属性；只能创建方便的构造函数convenience；12345678910111213141516171819202122232425262728293031323334class Test &#123;    var value: String    init(value: String) &#123;        self.value = value    &#125;&#125;// 扩展用方法上时extension Test &#123;    func beautifulValue() -&gt; String &#123;        return \"beautiful \" + self.value    &#125;&#125;let test = Test(value: \"girl\")test.beautifulValue() //\"beautiful girl\"// 扩展用变量上时，必须是计算型变量extension Test &#123;    var len: Int &#123;        return self.value.count    &#125;&#125;test.len // 4// 扩展用构造时，必须是方便构造extension Test &#123;    convenience init (firstName: String, lastName: String) &#123;        self.init(value: \"\\(firstName) \\(lastName)\")    &#125;&#125;let test2 = Test(firstName: \"Jiaji\", lastName: \"Xu\")\n2. 嵌套类型如果某类型只有在一个类型里面起作用，那么可以将该类型放到里面，如String的Index类型；扩展，可扩展嵌套类型；扩展可扩展下标；1234567891011121314151617181920212223242526272829303132333435class Rectangle &#123;    var origin: (x: Double, y: Double)    var width: Double    var height: Double    init(origin: (Double, Double), width: Double, height: Double) &#123;        self.origin = origin        self.width = width        self.height = height    &#125;&#125;extension Rectangle &#123;    enum Vertex: Int &#123;        case LeftTop, RightTop, RightBottom, LeftBottom    &#125;    subscript(index: Int) -&gt; (Double, Double) &#123;        assert(index &gt;= 0 &amp;&amp; index &lt; 4, \"Index in Rectange Out of Range.\")        switch Vertex(rawValue: index)! &#123;        case .LeftTop:            return origin        case .RightTop:            return (x: origin.x + width, y: origin.y)        case .RightBottom:            return (x: origin.x + width, y: origin.y + height )        case .LeftBottom:            return (x: origin.x, y: origin.y + height )        &#125;    &#125;&#125;let rect = Rectangle(origin: (0.0, 0.0), width: 4, height: 3)rect[0]rect[1]\n3. 扩展标准库// Int还有很多可以做enxtension的地方// 如 12345[2]// 如 toBinary, toHex// 如 isPrime// extension在App开发中被经常使用// 如 String, UIColor等基础类的使用// 在App开发中, 一个界面可能需要处理多个事件: 表格显示, 用户输入, 导航, 动画, 数据存储…// 此时可以使用extension分隔开;123456789101112131415161718192021222324252627282930313233343536373839extension Int &#123;    var square: Int &#123;        return self * self    &#125;    var cube: Int &#123;        return self * self * self    &#125;    func inRange(start: Int, to: Int) -&gt; Bool &#123;        return self &gt;= start &amp;&amp; self &lt; to    &#125;    func repetitions(task: (Int) -&gt; Void) &#123;        for _ in 0..&lt;self &#123;            task(self)        &#125;    &#125;&#125;let num = 8num.squarenum.cubenum.inRange(start: 0, to: 10)num.repetitions &#123; index in    print(\"hello \\(index)\")&#125;// 输出//hello 8//hello 8//hello 8//hello 8//hello 8//hello 8//hello 8//hello 8\nGeneric泛型： 只关心具体操作，不关心具体类型1. 用在方法上123456789func swapTwoThings&lt;T&gt;(a: inout T, b: inout T) &#123;    (a, b) = (b, a)&#125;var hello = \"Hello\"var bye = \"Bye\"swapTwoThings(a: &amp;hello, b: &amp;bye)hello // \"Bye\"bye // \"Hello\"\n2. 用在类型上123456789101112131415161718192021222324252627282930313233struct Stack&lt;T&gt; &#123;    var items = [T]()    func  isEmpty() -&gt; Bool &#123;        return items.count == 0    &#125;    mutating func push(_ item: T) &#123;        items.append(item)    &#125;    mutating func pop() -&gt; T? &#123;        guard !self.isEmpty() else &#123;            return nil        &#125;        return items.removeLast()    &#125;&#125;extension Stack &#123;    func top() -&gt; T? &#123;        return items.last    &#125;    func count() -&gt; Int &#123;        return items.count    &#125;&#125;var s = Stack&lt;Int&gt;()s.push(1)s.push(2)s.pop()\nprotocol1. 协议的基本使用协议；只定义，不实现；不能为协议设置默认的参数值，变量也不能有默认值；变量只能用var123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// protocol Pet: class &#123;&#125; 表示如果协议继承class，则该协议不能应用于结构体protocol Pet &#123;    // 不能右初始值    var name: String &#123; get set &#125;    // 统一使用var关键字    var birthPlace: String &#123; get &#125;    // 对于方法，不能有实现    func playWith()    //对于方法，不能有默认参数（默认参数就是一种实现）    // func fed(food: String = \"leftover\")    func fed()    func fed(food: String)    // 可以使用mutating关键字，强调在结构体重应该修改其中内容    mutating func changeName(newName: String)&#125;// 协议可继承protocol PetBird: Pet &#123;    var flySpeed: Double&#123; get &#125;    var flyHeight: Double&#123; get &#125;&#125;struct Dog: Pet &#123;    // 可以使用计算型属性    //    private var myDoggyName = \"Puppy\"    //    var name: String&#123;    //        get&#123;    //            return myDoggyName    //        &#125;    //        set&#123;    //            myDoggyName = newValue    //        &#125;    //    &#125;    var name: String    // 协议中定义的只读，对于一个具体类的实现，不一定是只读，但是作为Pet时是只读的！    // let birthPlace: String    var birthPlace: String    func playWith() &#123;        print(\"Wong!\")    &#125;    func fed() &#123;        print(\"I want a bone.\")    &#125;    // 在具体实现上可以加默认参数    func fed(food: String = \"Bone\") &#123;    &#125;    mutating func changeName(newName: String) &#123;        name = newName    &#125;&#125;var myDog: Dog = Dog(name: \"summer\", birthPlace: \"beijing\")myDog.birthPlace = \"beijing\"var aPet: Pet = myDog// 当作为Pet来操作的时候，是无法为birthPlace赋值的// aPet.birthPlace = \"shanghai\"\n2. 协议和构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243protocol Pet &#123;    var name: String &#123; get set &#125;    init(name: String)&#125;class Animal &#123;    var type: String = \"mammal\"&#125;// 如果一个类有继承的类，则类必须放在前面// 父类只能有一个， 协议可以有多个class Dog: Animal, Pet &#123;    var name: String = \"Pup\"    // 如果protocol有init， 则在class中必须声明required，强制让子类实现    required init(name: String) &#123;        self.name = name    &#125;&#125;final class Cat: Animal, Pet &#123;    var name: String    // 如果是final class，init可以没有required，因为它不再会被继承    init(name: String) &#123;        self.name = name    &#125;&#125;class Bird: Animal &#123;    var name: String = \"bird ...\"    init(name: String) &#123;        // 省略...    &#125;&#125;class Parrot: Bird &#123;    // 如果只继承Bird，则只需要加override或Bird init是required，那么只需要required    // 因为有Pet， 则required也不能省略    required override init(name: String) &#123;        super.init(name: name + \" \" + name)    &#125;&#125;\n3. 为什么使用协议协议描述的是某种特性；如下面的例子，通过协议，我们可以将继承自不同父类不同类型的东西，由于某种一样的特性，我们可以依这特性把它们归为一类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869protocol Pet &#123;    var name: String &#123; get set &#125;&#125;protocol Flyable &#123;    var flySpeed: Double &#123; get &#125;    var flyHeight: Double &#123; get &#125;&#125;class Animal &#123;&#125;class Dog: Animal, Pet &#123;    var name: String = \"Puppy\"&#125;class Cat: Animal, Pet &#123;    var name: String = \"Kitten\"&#125;class Bird: Animal, Flyable &#123;    var flySpeed: Double    var flyHeight: Double    init(flySpeed: Double, flyHeight: Double) &#123;        self.flySpeed = flySpeed        self.flyHeight = flyHeight    &#125;&#125;class Parrot: Bird, Pet &#123;    var name: String    init(name: String, flySpeed: Double, flyHeight: Double) &#123;        self.name = name + \" \" + name        super.init(flySpeed: flySpeed, flyHeight: flyHeight)    &#125;&#125;class Sparrow: Bird &#123;    var color = UIColor.gray&#125;class Vehicle &#123;&#125;class Plane: Vehicle, Flyable &#123;    var model: String    var flySpeed: Double    var flyHeight: Double    init(model: String, flySpeed: Double, flyHeight: Double) &#123;        self.model = model        self.flyHeight = flyHeight        self.flySpeed = flySpeed    &#125;&#125;var dog = Dog()var cat = Cat()var parrot = Parrot(name: \"hi\", flySpeed: 10.0, flyHeight: 100.0)let pets: [Pet] = [dog, cat, parrot]var sparrow = Sparrow(flySpeed: 15.0, flyHeight: 80.0)var plane = Plane(model: \"Boeing 747\", flySpeed: 200.0, flyHeight: 10_000)let flyers: [Flyable] = [parrot, sparrow, plane]for flyer in flyers &#123;    print(\"Fly speed: \\(flyer.flySpeed), Fly Height: \\(flyer.flyHeight)\")&#125;\n3. 类型别名(typealias)1234567891011121314typealias Length = Doubleextension Double &#123;    var m: Length &#123; return self &#125;    var cm: Length &#123; return self * 100.0 &#125;    var km: Length &#123; return self / 1000.0 &#125;    var ft: Length &#123; return self / 3.28084 &#125;&#125;let runningDistance: Length = 3.54.kmrunningDistance// 使用的时候直接使用AudioSample，如果需要改为UInt32或其它时直接改这里，而不必每个地方都去改typealias AudioSample = UInt64\n4. 并联类型(associatedtype)，在协议中使用别名12345678910111213141516171819202122232425262728protocol WeightCalculable &#123;    // 协议中声明实现类需要使用别名，用associatedtype    associatedtype WeightType    var weight: WeightType &#123; get &#125;&#125;// 在具体实现类中，用typealiasclass iPhone7: WeightCalculable &#123;    typealias WeightType = Double    var weight: WeightType &#123;        return 0.114    &#125;&#125;class Ship: WeightCalculable &#123;    typealias WeightType = Int    var weight: WeightType    init(weight: WeightType) &#123;        self.weight = weight    &#125;&#125;extension Int &#123;    typealias Weight = Int    var t: Weight &#123; return 1_000 * self &#125;&#125;let titanic = Ship(weight: 46_328_000)\n5. Swfit标准库中的常用协议12345678910111213141516171819202122232425262728293031323334struct Record: Equatable, Comparable, CustomStringConvertible &#123;    var wins: Int    var losses: Int    // 协议CustomStringConvertible中的定义，可直接被print打印    var description: String &#123;        return \"WINS: \\(wins), LOSSES: \\(losses)\"    &#125;    var boolValue: Bool &#123;        return wins &gt; losses    &#125;&#125;// 协议Equatable的作用，我们只需要实现==，我们就可以用!=func ==(left: Record, right: Record) -&gt; Bool &#123;    return left.wins == right.wins &amp;&amp; left.losses == right.losses&#125;// 协议Comparable的作用，当我们定义了&lt;，上面右定义了==，此时我们可以使用&lt;=,&gt;,&gt;=func &lt;(left: Record, right: Record) -&gt; Bool &#123;    if left.wins != right.wins &#123;        return left.wins &lt; right.wins    &#125;    return left.losses &gt; right.losses&#125;let record = Record(wins: 10, losses: 5)let record2 = Record(wins: 11, losses: 5)record &gt;= record2print(record) //WINS: 10, LOSSES: 5var records = [Record(wins: 10, losses: 3), Record(wins: 8, losses: 5), Record(wins: 8, losses: 8)]// 当我们实现了Comparable，可直接排序records.sort()\n面向协议编程1. 扩展协议和默认实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051protocol Record: CustomStringConvertible &#123;    var wins: Int &#123; get &#125;    var losses: Int &#123; get &#125;    func winningPercent() -&gt; Double&#125;// 扩展一个协议的时候，可以对协议进行实现extension Record &#123;    // 实现CustomStringConvertible协议中的description，实现Record的就可以不用实现这个    var description: String &#123;        return \"WINS: \\(wins), LOSSES: \\(losses)\"    &#125;    // 扩展协议中还可以写其他方法的实现    func shoutWins() &#123;        print(\"WE WIN\", wins, \"TIMES!!!\")    &#125;    // 扩展中还可以对定义的变量进行计算，计算的是对应实现类中值    var gamePlayed: Int &#123;        return wins + losses    &#125;&#125;struct BaseballRecord: Record &#123;    var wins: Int    var losses: Int    func winningPercent() -&gt; Double &#123;        return Double(wins) / Double(gamePlayed)    &#125;&#125;let teamRecord = BaseballRecord(wins: 2, losses: 10)print(teamRecord)teamRecord.shoutWins()// 扩展标准库中的协议extension CustomStringConvertible &#123;    var descriptionWithDate: String &#123;        return NSData().description + \" \" + description    &#125;&#125;print(teamRecord.descriptionWithDate)// 输出// WINS: 2, LOSSES: 10// WE WIN 2 TIMES!!!// &lt;&gt; WINS: 2, LOSSES: 10\n2. 根据条件扩展协议123456789101112131415161718192021222324252627282930313233343536protocol Record &#123;    var wins: Int &#123;get&#125;    var losses: Int &#123;get&#125;&#125;extension Record &#123;    var gamePlayed: Int &#123;        return wins + losses    &#125;    func winningPercent() -&gt; Double &#123;        return Double(wins) / Double(gamePlayed)    &#125;&#125;protocol Tieable &#123;    var ties: Int &#123;get set&#125;&#125;// 该扩展表示：实现该协议的实例又实现了Tieable协议会进入这个扩展// 由于实现了Tieable扩展后的实体需要改变一些计算方式extension Record where Self: Tieable &#123;    var gamePlayed: Int &#123;        return wins + losses + ties    &#125;    // 如果不写覆写这个方法，实例会调用上面扩展中的方法，并调用上面扩展中的gamePlayed，会导致计算结果不对    func winningPercent() -&gt; Double &#123;        return Double(wins) / Double(gamePlayed) // gamePlayed = wins + losses + ties    &#125;&#125;struct FootballRecord: Record, Tieable &#123;    var wins: Int    var losses: Int    var ties: Int&#125;let footballTeam = FootballRecord(wins: 1, losses: 1, ties: 1)footballTeam.gamePlayedfootballTeam.winningPercent()\n3. 协议聚合在方法的参数中聚合多个协议为传入条件12345678910111213141516171819202122232425262728293031323334protocol Prizable &#123;    func isPrizable() -&gt; Bool&#125;// 该方法表示实例必须同时实现了CustomStringConvertible和Prizable两个协议才能传入func award(one: CustomStringConvertible &amp; Prizable)&#123;    if one.isPrizable()&#123;        print(one)        print(\"Congratulation! You won a prize!\")    &#125;    else&#123;        print(one)        print(\"You can not have the prize!\")    &#125;&#125;struct Student: CustomStringConvertible, Prizable &#123;    var score: Int    init(score: Int) &#123;        self.score = score    &#125;    var description: String &#123;        return \"score = \\(score)\"    &#125;    func isPrizable() -&gt; Bool &#123;        return score &gt; 60    &#125;&#125;award(one: Student(score: 80))\n4. 泛型约束1234567// 传入数组，找出最大值func topOne&lt;T: Comparable&gt;(seq:[T]) -&gt; T &#123;    assert(seq.count &gt; 0)    return seq.reduce(seq[0]) &#123; max($0, $1) &#125;&#125;topOne(seq: [1, 4, 7, 2, 3])\n5. 创建自己的委托模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162protocol TurnBaseGameDelegate &#123;    func gameStart()    func playMove()    func gameEnd()    func gameOver() -&gt; Bool&#125;// 回合制游戏protocol TurnBasedGame &#123;    var turn: Int &#123; get set &#125;    func play()&#125;// 实现了游戏的逻辑，但是具体是什么游戏不知道，委托出去别人实现class SinglePlayerTurnBasedGame: TurnBasedGame &#123;    var delegate: TurnBaseGameDelegate!    var turn = 0    func play() &#123;        delegate.gameStart()        while !delegate.gameOver() &#123;            print(\"ROUND\", turn, \":\")            delegate.playMove()            turn += 1        &#125;        delegate.gameEnd()    &#125;&#125;// 实现了委托的协议// 掷骰子游戏class RollNumberGame: SinglePlayerTurnBasedGame, TurnBaseGameDelegate &#123;    var score = 0    override init() &#123;        super.init()        delegate = self    &#125;    func gameStart() &#123;        score = 0        turn = 0        print(\"Welcome to Roll Number Game.\")        print(\"Try to use least turn to make total 100 scores!\")    &#125;    func playMove() &#123;        let rollNumber = Int(arc4random() % 6) + 1        score += rollNumber        print(\"You rolled a\", rollNumber, \"! The score is\", score, \"now!\")    &#125;    func gameEnd() &#123;        print(\"Congratulation! You win the game in\", turn, \"ROUND!\")    &#125;    func gameOver() -&gt; Bool &#123;        return score &gt;= 30    &#125;&#125;let rollingNumber = RollNumberGame()rollingNumber.play()\n6. 可选的协议方法可选方法需要用@objc标记，实现的实体可实现，可不实现，用的时候当做可选类型来用123456789@objc protocol TurnBaseGameDelegate &#123;    func gameStart()    func playMove()    func gameEnd()    func gameOver() -&gt; Bool    @objc optional func turnStart()    @objc optional func turnEnd()&#125;\n错误处理1. 强制退出程序12345678910111213141516171819assert(1&lt;0, \"Error msg\") // 只在测试阶段才有效// 输出：// Assertion failed: Error msg: file LearnError.playground, line 5//===========================================assertionFailure()//输出：//Fatal error: file LearnError.playground, line 7//===========================================assertionFailure(\"Error msg\")//输出：//Fatal error: Error msg: file LearnError.playground, line 7//===========================================precondition(1&gt;0) // 满足条件也会退出precondition(1&gt;0, \"Error\")fatalError(\"Error\") // 严重的错误\n2. 错误处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class VendingMachine &#123;    struct Item &#123;        enum ItemType: String &#123;            case Water            case Cola            case Juice        &#125;        let type: ItemType        let price: Int        var count: Int    &#125;    enum ItemError: Error, CustomStringConvertible &#123;        case NoSuchItem        case NotEnoughMoney(Int)        case OutOfStock        var description: String &#123;            switch self &#123;            case .NoSuchItem:                 return \"Not Such Item\"            case .NotEnoughMoney(let price) : return \"Not Enough Money. \\(price) Yuan needed.\"            case .OutOfStock:                 return \"Out of Stock\"            &#125;        &#125;    &#125;    private var items = [\"MIneral Water\": Item(type: .Water, price: 2, count: 10),                         \"Coca Cola\": Item(type: .Cola, price: 3, count: 5),                         \"Orange Juice\": Item(type: .Juice, price: 5, count: 3)]    func vend(itemName: String, money: Int) throws -&gt; Int &#123;        guard let item = items[itemName] else &#123;            throw ItemError.NoSuchItem        &#125;        guard money &gt;= item.price else &#123;            throw ItemError.NotEnoughMoney(item.price)        &#125;        guard item.count &gt; 0 else &#123;            throw ItemError.OutOfStock        &#125;        items[itemName]!.count -= 1        return money - item.price    &#125;    func display() &#123;        print(\"Want something to drink?\")        for itemName in items.keys &#123;            print(\"*\", itemName)        &#125;        print(\"===========================\")    &#125;&#125;let machine = VendingMachine()machine.display()var pocketMoney = 6// 可能抛出异常，但不管不顾，抛出异常后直接崩溃pocketMoney = try! machine.vend(itemName: \"Coca Cola\", money: pocketMoney)// 如果抛出异常，则得到一个nillet p = try? machine.vend(itemName: \"Coca Cola\", money: pocketMoney)// 异常处理，如果抛出异常则进入对应的异常处理，如果都没有捕获到，则进入最后一个处理do&#123;    pocketMoney = try machine.vend(itemName: \"Coca Cola\", money: pocketMoney)    print(pocketMoney,\"Yuan left\")&#125;catch VendingMachine.ItemError.NoSuchItem&#123;    print(\"No Such Item\")&#125;catch VendingMachine.ItemError.NotEnoughMoney(let price)&#123;    print(\"Not Enough Money.\" , price , \"Yuan needed.\")&#125;catch VendingMachine.ItemError.OutOfStock&#123;    print(\"Out of Stock\")&#125;catch&#123;    print(\"Error occured during vending.\")&#125;// 捕获异常，并得到异常实例do&#123;    pocketMoney = try machine.vend(itemName: \"Coca Cola\", money: pocketMoney)    print(pocketMoney,\"Yuan left\")&#125;catch let error as VendingMachine.ItemError&#123;    print(error)&#125;catch&#123;    print(\"Error occured during vending.\")&#125;\n3. defer相当于java中的fanally，用于抛出异常或没有抛出异常都需要执行的语句；使用方式：123456789101112131415161718192021func vend(itemName itemName: String, money: Int) throws -&gt; Int&#123;    // 和代码平级    defer&#123;        print(\"Have a nice day\")    &#125;    guard let item = items[itemName] else&#123;        throw VendingMachine.ItemError.NoSuchItem    &#125;    ...    // 如果有多个defer，则会倒叙执行    // 如果前方就抛出异常，则该局不会执行    defer&#123;        print(\"Thank you\")    &#125;    ...    return money - item.price&#125;\n内存管理1. 析构函数，实例销毁前在这里做一些处理。由于内存自动销毁实例用的情况比较少123456789101112131415161718192021222324252627282930313233343536class Person &#123;    init() &#123;        print(\"init...\")    &#125;    func doSomething() &#123;        print(\"doing something\")    &#125;    deinit &#123;        print(\"person is leaving!!!\")    &#125;&#125;var person: Person? = Person()// 当赋值为nil后，实例会被销毁person = nil// 当实例超出作用域后，实例会被销毁func inTheShop() &#123;    print(\"======\")    print(\"Welcome\")    let person: Person = Person()    person.doSomething()&#125;inTheShop()// 输出//init...//person is leaving!!!//======//Welcome//init...//doing something//person is leaving!!!\n2. 引用计数当引用实例的变量为0的时候，那么就会被释放；ARC：Automatic Reference Count3. 强引用循环和weakweak必须是一个可选型的变量12345678910111213141516171819202122232425262728293031323334353637class Person&#123;    var apartment: Apartment?    init()&#123;        print(\"Person is initialized\")    &#125;    deinit&#123;        print(\"Person is being deinitialized!\")    &#125;&#125;class Apartment&#123;    // 弱引用必须是可选型    // weak必须是var    // 当弱引用的实例被销毁的时候，tenant会被赋值为nil    weak var tenant: Person?    init()&#123;        print(\"Apartment is initialized!\")    &#125;    deinit&#123;        print(\"Apartment is being deinitialized!\")    &#125;&#125;var liuyubobobo: Person? = Person()var imoocApartment: Apartment? = Apartment()liuyubobobo!.apartment = imoocApartmentimoocApartment!.tenant = liuyuboboboliuyubobobo = nilimoocApartment?.tenant //nilimoocApartment = nil// 两种顺序内存都能够正确释放\n4. unowned和上面一样也是弱引用，区别在于它只能修饰常量let，不能是可选的；添加了unowned的实例最好在unowned引用的对象之前销毁，因为如果不这样访问unowned常量时会抛出异常5. 强引用循环123456789101112131415161718192021222324252627282930313233343536class Country&#123;    let name: String    //let capital: City    var capital: City! // 由于定义成这种隐式的可选，表示占时不会赋值，但肯定会被赋值    init(countryName: String, capitalName: String)&#123;        self.name = countryName        //-------两段构造从此分割-------        self.capital = City(cityName: capitalName, country: self) // 由于占时不用赋值，所以到了第二段构造，于是可以使用self        print(\"Country\", name, \"is intialized.\")    &#125;    deinit&#123;        print(\"Country\",name,\"is being deinitialized!\")    &#125;&#125;class City&#123;    let name: String    unowned let country: Country    init(cityName: String, country: Country)&#123;        self.name = cityName        self.country = country        print(\"City\", name, \"is intialized.\")    &#125;    deinit&#123;        print(\"City\",name,\"is being deinitialized!\")    &#125;&#125;var china: Country? = Country(countryName: \"China\", capitalName: \"Beijing\")china = nil\n6. 闭包中的强引用循环12345678910111213141516171819202122232425262728class SmartAirConditioner&#123;    var temperature: Int = 26    var temperatureChange: ((Int) -&gt; ())!    init()&#123;        temperatureChange = &#123; [weak self]newTemperature in            guard let `self` = self else &#123;                return            &#125;            if abs(newTemperature - self.temperature) &gt;= 10&#123;                print(\"It's not healthy to do it!\")            &#125;            else&#123;                self.temperature = newTemperature                print(\"New temperature \\(newTemperature) is set!\")            &#125;        &#125;    &#125;    deinit&#123;        print(\"Smart Air-conditioner is being deinitialized!\")    &#125;&#125;var airCon: SmartAirConditioner? = SmartAirConditioner()airCon?.temperatureairCon?.temperatureChange(100)airCon?.temperatureChange(24)airCon = nil\n类型检查和类型转换1. 类型检查is1234567class Person &#123;&#125;class Student: Person &#123;&#125;var person: Person = Student()person is Student // true\n2. 类型转换as1234// 确定类型（失败有风险）let stu1 = person as! Student// 可选类型（失败为nil）let stu2 = person as? Student\n3. 可以用在协议上4. NSObject,AnyObject和Any12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Person&#123;    var name: String    init(name: String)&#123;        self.name = name    &#125;&#125;//var objects: NSArray = [//    CGFloat(3.1415926),//    \"imooc\",//    UIColor.blueColor(),//    NSDate(),//    Int(32),//    Array&lt;Int&gt;([1,2,3])//]//var objects = [//    CGFloat(3.1415926),//    \"imooc\",//    UIColor.blueColor(),//    NSDate(),//    Int(32),//    Array&lt;Int&gt;([1,2,3]),//    Person(name: \"liuyubobobo\")//]////// a 为AnyObject//let a = objects[0]//var objects: [AnyObject] = [//    CGFloat(3.1415926),//    \"imooc\",//    UIColor.blueColor(),//    NSDate(),//    Int(32),//    Array&lt;Int&gt;([1,2,3]),//    Person(name: \"liuyubobobo\")//]////objects.append( &#123; (a:Int) -&gt; Int in//    return a*a&#125; )var objects: [Any] = [    CGFloat(3.1415926),    \"imooc\",    //swift 2: UIColor.blueColor(),    //swift3中，颜色从“xxxColor()”变成了\"xxx\"。直接调用UIColor.xxx即可    UIColor.blue,                //swift 3    NSDate(),    Int(32),    Array&lt;Int&gt;([1,2,3]),    Person(name: \"liuyubobobo\")]objects.append( &#123; (a:Int) -&gt; Int in    return a*a&#125; )\n一些注意事项1. 变量可以用中文，支持Unicode字符，并且可以用表情2. swift没有 ++ -- 运算3. 类型都需要显示的自己去转换4. Array、Set、Dictionary、String等结构体都是值类型的\n","plink":"https://blog.xujiaji.com/post/swift-study-note/"},{"title":"Dagger2 的深入分析与使用","date":"2018-06-26T16:00:00.000Z","author":"xujiaji","updated":"2019-04-08T06:55:53.838Z","content":"\nDagger2 的深入分析与使用听闻Dagger大名很久，但一直没有去学，直到不得不学 〒▽〒。这个框架开始的时不是很好理解，看了一些文章还是没有理解到精髓，似懂非懂，于是自己做了些简单的测试代码观察Dagger注解的作用。将学习和理解的过程分享出来，希望能帮到一些学些Dagger的朋友，同时我也巩固总结一下。\n本篇文章不讲，Dagger哪里好哪里好！只讲怎么用的和一些原理！\nDagger是什么？\nDagger是一个依赖注入框架（Dependency injection），简称DI。假如有A和B两个对象（B相当于是DI），A中并没有对自己内部的成员进行初始化，它的成员初始化全部是B类注入进来。\n\n大部分注入框架是基于反射实现的，Dagger旨在解决许多困扰基于反射的解决方案的开发和性能问题，Dagger的依赖注入是通过java代码来实现的。相当于你自己可以用java手写依赖注入代码，但这样的话就会更大的工作量，于是Dagger通过注解等帮我们自动生成相关的依赖注入逻辑代码。\n\n额…，有点一头雾水的感觉吧！如果大家想知道详细概念的话，可以去搜索一下啦！\n\n在下面所讲的都是以实际的代码操作为主，来去观察结果，代码本篇不会涉及Android 页面，只想通过简单的代码来理清楚Dagger生成DI的逻辑。\n\n\n需要添加的依赖官方Dagger2项目地址：https://github.com/google/dagger\n1234dependencies &#123;    implementation 'com.google.dagger:dagger:2.15'    annotationProcessor 'com.google.dagger:dagger-compiler:2.15'&#125;\n注解使用欢迎来到本篇最精彩的地方！参考自官方的使用指南\n\n符号含义参考表：\n\n\n\n\n符号══▶\n\n\n\n\n\n\n\n\n\n\n\n\n含义══▶\nprivate变量\nprivate方法\nprotected变量\nprotected方法\n包私有 变量\n包私有方法\npublic 变量\npublic 方法\n\n\n\n\n\n\n符号\n含义\n简单例子\n\n\n\n\n\n继承\nclass A{}class B extend A{}\n\n\n\n实现接口\ninterface I{}class A implements I{}\n\n\n\n依赖\nclass A{}class B{　　void fun(A c) {}}\n\n\n\n并联\nclass A{}class B{　　A a;}\n\n\n\nclass\nclass A{}\n\n\n\nabstract\nabstract class A{}\n\n\n\ninterface\ninterface A{}\n\n\n\nenum\nenum A{}\n\n\n...\n省略代码\nclass A {...}\n\n\n\n咖啡机用咖啡机的例子来演示，首先我们来看一下主要的几个类，下面是简单咖啡机UML关系图！（查考自Dagger2项目example）\n\n\n正常情况下，我们大概会写成这样：\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 定义泵接口 */interface Pump &#123;    void pump();&#125;---------------------------------------------------------------------------------/** * 定义加热器接口 */interface Heater &#123;    void on();    void off();    boolean isHot();&#125;---------------------------------------------------------------------------------/** * 电子加热器 */public class ElectricHeater implements Heater &#123;    boolean heating;    @Override    public void on() &#123;        System.out.println(\"~~~~heating~~~~\");        this.heating = true;    &#125;    @Override    public void off() &#123;        this.heating = false;    &#125;    @Override    public boolean isHot() &#123;        return heating;    &#125;&#125;---------------------------------------------------------------------------------/** * 热虹吸 */public class Thermosiphon implements Pump &#123;    private final Heater heater;    Thermosiphon(Heater heater) &#123;        this.heater = heater;    &#125;    @Override    public void pump() &#123;        if (heater.isHot()) &#123;            System.out.println(\"=&gt;=&gt; 抽水 =&gt;=&gt;\");        &#125;    &#125;&#125;---------------------------------------------------------------------------------/** * 咖啡机 */public class CoffeeMaker &#123;    Heater heater;    Pump pump;    public CoffeeMaker(Heater heater, Pump pump) &#123;        this.heater = heater;        this.pump = pump;    &#125;    public void brew() &#123;        heater.on();        pump.pump();        System.out.println(\"[_]P coffee! [_]P\");        heater.off();    &#125;&#125;---------------------------------------------------------------------------------/** * 出咖啡测试 */public class CoffeeApp &#123;    public static void main(String[] args) &#123;        Heater heater = new ElectricHeater();//实例化加热器        Pump pump = new Thermosiphon(heater);//实例化泵        CoffeeMaker coffeeMaker = new CoffeeMaker(heater, pump);//实例化咖啡机        coffeeMaker.brew();//出咖啡    &#125;&#125;\n@Inject测试文件位置\n\n其名：注入，@Inject的用法是标记成员变量、构造方法或成员方法。\n\n标记了注解@Inject的成员变量或方法，Dagger会自动为其提供实例；标记了@Inject的构造方法表示Dagger将会自动实例化该类提供给其他需要注入的类。\n\n像这这样一个需要注入的成员，一个提供该对象就这样对应起来了。但是还差一个将它们联系起来的东西，它叫Componnet。下面的例子将会提前用到@Component注解您可以先不去深入理解，占时理解为Dagger必要写的的且是注入的关系连接纽带。\n\n\n\n这里在构造方法上加@Inject可以理解为：提供new ElectricHeater()\n\n123456789/** * 电子加热器 */public class ElectricHeater implements Heater &#123;    @Inject    public ElectricHeater() &#123;    &#125;    ...&#125;\n\n@Component起纽带作用，用接口或抽象类来定义。Thermosiphon getPump()表示其他地方需要提供new Thermosiphon()\n\n1234@Componentpublic interface PumpComponent &#123;    Thermosiphon getPump();&#125;\n\n@Inject标记在成员变量上，表示其他地方需要提供ElectricHeater对象，也就是上上面代码中@Inject标记在构造方法的作用。@Inject标记在构造方法上，可以看做new Thermosiphon()，也就是上面接口中需要的对象。\n\n123456789101112131415161718/** * 热虹吸 */public class Thermosiphon implements Pump &#123;    @Inject    ElectricHeater heater;    @Inject    public Thermosiphon()    &#123;&#125;    @Override    public void pump() &#123;        if (heater.isHot()) &#123;            System.out.println(\"=&gt;=&gt; 抽水 =&gt;=&gt;\");        &#125;    &#125;&#125;\n\n我们直接创建一个CoffeeApp类中进行测试，DaggerPumpComponent是通过apt自动生成的类（需要在Android studio中点击：Build -&gt; Make Module）。\n\n123456789//运行测试public class CoffeeApp &#123;    public static void main(String[] args) &#123;        // 全写：Thermosiphon pump = DaggerPumpComponent.builder().build().getPump();        Thermosiphon pump = DaggerPumpComponent.create().getPump();        pump.heater.on();        pump.pump();    &#125;&#125;\n\nCoffeeApp运行结果\n\n12~~~~heating~~~~=&gt;=&gt; 抽水 =&gt;=&gt;\n\n测试一下将@Inject标记在方法上，修改Thermosiphon类，如下所示：\n\n12345678910111213141516171819/** * 热虹吸 */public class Thermosiphon implements Pump &#123;...    @Inject    public void funTest()    &#123;        System.out.println(\"funTest()\");    &#125;    @Inject    public void funTest(ElectricHeater heater)    &#123;        System.out.println(\"heater: \" + this.heater.hashCode());        System.out.println(\"funTest(): \" + heater.hashCode());    &#125;...&#125;\n\nCoffeeApp运行结果\n\n12345funTest()heater: 692404036funTest(): 1554874502~~~~heating~~~~=&gt;=&gt; 抽水 =&gt;=&gt;\n\n一些结论\n\n\n通过DaggerPumpComponent.create().getPump();既可以得到Thermosiphon对象。\n我们看到在Thermosiphon中heater是以ElectricHeater来接收的，并没有向上转型为接口Heater引用，@Inject标记需要是确切的类型。等我们学习了下面@Provides丶@Module部分，我们就能间接的用Heater接口来接收。\n通过上面例子我们明显看到，我们并没有new 对象，然而却有ElectricHeater和Thermosiphon被实例化，这就是Dagger生成java代码中帮我们进行了实例化的操作。\n注意@Inject标记的成员变量、方法和构造方法不能以private修饰。因为如果我们用private，Dagger以java代码注入，自然不能帮我们注入对象，会报错!你可以试试看哦！(￣▽￣)~*\n也许你想问DaggerPumpComponent是哪来的？用@Component标记的接口会生成一个以“Dagger + 接口名”的类。\n经测试，如果将成员变量上的@Inject去掉，不会报错，只是没有引用的对象，变量为null。如果成员变量上标记了@Inject，而没有对应的注入实例，则会编译错误。\nDagger生成代码的位置：项目目录 -&gt; app -&gt; build -&gt; generated -&gt; source -&gt; apt\n如果我们将@Inject标记在方法上，如果有参，Dagger提供该实例，然后自动调用该方法；如果无参则直接调用；如果有参没有对应的实例提供，则报错。\n\n\n接下来将从Dagger生成的注入代码上进行分析（这部分跳过也可以滴！(｀・ω・´)）\n这是上面整体的UML关系图，“绿色”的是Dagger自动生成的代码。\n\n1. 通过我们对Dagger的使用，它为我们生成了4个类。2. 他们这样对应：\n\n\n\n\nPumpComponent\n—–&gt;\nDaggerPumpComponent\n\n\n@Inject public ElectricHeater() { }\n—–&gt;\nElectricHeater_Factory\n\n\n@Inject public Thermosiphon() { }\n—–&gt;\nThermosiphon_Factory\n\n\n@Inject ElectricHeater heater;\n—–&gt;\nThermosiphon_MembersInjector\n\n\n\n通过观察我们可以得出这些结论：\n\n①PumpComponent接口生成的类的名字以：Dagger + 接口名。（我们需要使用生成的这个类，进行Dagger初始化的操作）\n②@Inject标记了构造方法生成类名以：构造名 + _Factory，的命名生一个工厂类。（该工厂类将用来创建对应的实例）\n③类中有@Inject标记成员变量或方法的类，会生成一个以：该类名 + _MembersInjector，的命名生成一个注入类。（该类实现了将实例传递到用@Inject标记的成员变量或方法）\n\n3. 来看看ElectricHeater的工厂类ElectricHeater_Factory（这是一个工厂设计模式中的一种实现方式），实现一个工厂接口Factory&lt;T&gt;(Factory&lt;T&gt;又继承Provider&lt;T&gt;接口)。通过get()获取一个ElectricHeater实例，通过create()获取ElectricHeater_Factory实例（这个类并未被使用，当你看到下面介绍DaggerPumpComponent就明白了）4. 接下来看看Thermosiphon_MembersInjector，这个类实现了为@Inject泛型标记的成员变量或方法传递值的操作。大家看injectHeater方法，这里就是为Thermosiphon的成员变heater添加依赖的地方!5. 再看看Thermosiphon_Factory，这个类比上一个ElectricHeater_Factory复杂一点。因为它在实例化Thermosiphon时，需要注入ElectricHeater对象。这比ElectricHeater_Factory多了个方法并且实例该工厂类时必须传入ElectricHeater的工厂类实例。\n\n构造参数是ElectricHeater的工厂，是为了通过工厂类获得ElectricHeater对象；\n工厂方法get()中创建实例的同时，通过Thermosiphon_MembersInjector的静态方法(injectHeater)向Thermosiphon注入ElectricHeater对象，然后得到最终的Thermosiphon实例；\n最后一个静态方法newThermosiphon()返回一个没有注入ElectricHeater实例的Thermosiphon对象。\n\n6. 最后看DaggerPumpComponent这个类，主要看getPump()、injectThermosiphon和Builder类\n\ngetPump()是我们在接口中定义的方法，在这里实现接口方法，通过调用injectThermosiphon方法并传入一个没有注入ElectricHeater实例的Thermosiphon，得到最终的Thermosiphon\ninjectThermosiphon方法中得到上面传进来的Thermosiphon，然后通过Thermosiphon_MembersInjector注入ElectricHeater实例。看到这里我们会发现第“3.”中介绍的ElectricHeater_Factory居然没有用到，这里直接就new了（这也是上面提到的并没有使用ElectricHeater_Factory）。\nBuilder就是用来创建DaggerPumpComponent的类，学到后面，这个类会根据需求变得复杂！\n\n@Provides丶@Module丶@Binds测试文件位置\n\n由于@Inject注解无法做到以下几点：\n\n\n接口类型无法做为接收类型\n第三方类无法添加@Inject注解（因为这个类不是自己掌控的）\n\n这种情况下我们可以用@Provides注释去满足依赖，方法的返回类型确定了它提供给谁的依赖。\n\n使用\n\n\n创建一个类作用是存放提供实例的方法，约定该类以Module结尾（便于统一分辨，就像我们安卓Activity命名以Activity结尾）\n在类名上标记@Module注解\n使用静态或普通有返回的方法来提供实例\n在这些方法前需要标记@Provides注解\n这些方法以provide开头，也是一种约定\n\n\n\n\n看下方这个DripCoffeeModule类，它提供了两个实例，并且它们的返回类型指向的是接口。也就是说有某个地方可能需要Heater和Pump的实例。\n\n123456789101112131415@Modulepublic class DripCoffeeModule&#123;    @Provides    static Heater provideHeater() &#123;        System.out.println(\"provideHeater\");        return new ElectricHeater();    &#125;    @Provides    static Pump providePump(Thermosiphon pump) &#123;        System.out.println(\"providePump\");        return pump;    &#125;&#125;\n\n在@Component注解中添加DripCoffeeModule.class，如果有多个可写为：@Component(modules = {DripCoffeeModule.class, ....class,....class})\n\n12345@Component(modules = DripCoffeeModule.class)public interface CoffeeShop&#123;    Pump getPump();&#125;\n\n其他类\n\n1234567891011121314151617181920212223242526/** * 电子加热器 */public class ElectricHeater implements Heater&#123;    public ElectricHeater()    &#123;        System.out.println(\"ElectricHeater()\");    &#125;    ...&#125;---------------------------------------------------------------------------------/** * 热虹吸 */public class Thermosiphon implements Pump&#123;    private Heater heater;    @Inject    public Thermosiphon(Heater heater) &#123;        System.out.println(\"Thermosiphon() heater = \" + heater);        this.heater = heater;    &#125;    ...&#125;\n\n测试类：\n\n1234567891011/** * 测试 */public class CoffeeApp&#123;    public static void main(String[] args) &#123;        Pump pump = DaggerCoffeeShop.create().getPump();        System.out.println(\"pump = \" + pump);        pump.pump();    &#125;&#125;\n\nCoffeeApp的输出结果：\n\n12345provideHeaterElectricHeater()Thermosiphon() heater = com.example.jiaji.daggertest.coffee3.ElectricHeater@29453f44providePumppump = com.example.jiaji.daggertest.coffee3.Thermosiphon@5cad8086\n\n首先，我们调用DaggerCoffeeShop.create().getPump()想要得到一个Pump对象，于是DripCoffeeModule中的providePump方法为我们提供一个Pump实例。\n然后，我们看到providePump方法有参数Thermosiphon那么这个这个实例从哪来呢？我们在Thermosiphon的构造方法上标记@Inject就表示提供该对象了。\n接下来，我们深入到Thermosiphon类又会发现，Thermosiphon类的构造方法要求提供Heater对象，那么问题来了Heater实例从哪来？您能想到！我们可以看到在DripCoffeeModule的provideHeater方法提供了该实例。\n最后，我们可以得出来个容易理解的大概流程：\n\n我们需要注意，当@Inject提供了实例并且Module中也提供该实例的情况下，Dagger会优先Module中提供的实例。\n通过上面的例子，我们可以注意到：@Inject可以为Module方法的参数提供实例\n\n我们可以将Module中的方法分到多个Module中，只需要在@Component注释中添加一下，如下所示：\n\n1234567891011121314151617181920212223242526@Modulepublic class DripCoffeeModule&#123;    @Provides    static Heater provideHeater() &#123;        System.out.println(\"provideHeater\");        return new ElectricHeater();    &#125;&#125;---------------------------------------------------------------------------------@Modulepublic class DripCoffeeModule2&#123;    @Provides    static Pump providePump(Thermosiphon pump) &#123;        System.out.println(\"providePump\");        return pump;    &#125;&#125;---------------------------------------------------------------------------------@Component(modules = &#123;DripCoffeeModule.class, DripCoffeeModule2.class&#125;)public interface CoffeeShop&#123;    Pump getPump();&#125;\n\n其实还有种写法，意思是表示某一个Module包含另一个Module。最终效果一样的。如下所示：\n\n12345678910111213141516171819202122232425@Modulepublic class DripCoffeeModule2&#123;    @Provides    static Pump providePump(Thermosiphon pump) &#123;        System.out.println(\"providePump\");        return pump;    &#125;&#125;---------------------------------------------------------------------------------@Module(includes = DripCoffeeModule2.class)public class DripCoffeeModule&#123;    @Provides    static Heater provideHeater() &#123;        System.out.println(\"provideHeater\");        return new ElectricHeater();    &#125;&#125;---------------------------------------------------------------------------------@Component(modules = DripCoffeeModule.class)public interface CoffeeShop&#123;    Pump getPump();&#125;\n\n@Binds可以简化DripCoffeeModule中提供Pump实例的写法，效果是一样的。\n\n123456789101112@Modulepublic abstract class BModule&#123;    @Binds    abstract Pump bindPump(Thermosiphon pump);&#125;---------------------------------------------------------------------------------@Component(modules = &#123;DripCoffeeModule.class, BModule.class&#125;)public interface CoffeeShop&#123;    ...&#125;\n\n接下来是对Dagger生成的代码进行分析（这部分可以选择性跳过！(｀・ω・´)）\n这是整体的UML关系图，“绿色”是自动生成的代码。(由于生成的Thermosiphon_Factory并没有被使用，于是就不放进来了。)\n\n1. 通过上面的三部分代码，Dagger也为我们生成了4个类。2. 他们这样对应：\n\n\n\n\nCoffeeShop\n—–&gt;\nDaggerCoffeeShop\n\n\n@Provides static Heater provideHeater()\n—–&gt;\nDripCoffeeModule_ProvideHeaterFactory\n\n\n@Provides static Pump providePump(Thermosiphon pump)\n—–&gt;\nDripCoffeeModule_ProvidePumpFactory\n\n\n@Inject public Thermosiphon() { }\n—–&gt;\nThermosiphon_Factory\n\n\n\n从名字上我们可以看出：@Provides标记的提供实例的方法对应生成了一个类名以：所在类名 + _ + 方法名(首字大写) + Factory，命名生成一个对应的工厂类。\n3. 我们先来看看Thermosiphon_Factory这个没有被使用的类，如果您是从上面挨着看下来的，就一定明白，其他地方是直接new Thermosiphon，接着往下看您就会看到！\n\n这个类和上面生成的Thermosiphon_Factory有些不一样，因为之前Thermosiphon是无参构造，现在添加了Heater作为构造的参数（该实例在DripCoffeeModule提供）。\n可以看到要实例化这个工厂类，必须要传入Heater的工厂类。然后在创建Thermosiphon实例时通过Heater工厂类创建一个Heater对象传入构造方法中。\n并且它还添加了一个newThermosiphon的静态方法，允许传入heater对象来创建Thermosiphon。\n\n4. 我们在来看Heater工厂类DripCoffeeModule_ProvideHeaterFactory，它相对比较简单点。\n\n可以看到在创建Heater实例时，直接通过DripCoffeeModule.provideHeater()调用我们定义的相对应的静态方法。\n通过Preconditions.checkNotNull又检测了是否提供得有实例，没有将会报第二参数传入的错误信息。\n工厂实例化是通过静态方法create()实例；静态方法newThermosiphon，可不创建工厂类的情况下，直接创建Heater实例。\n\n\n\nDripCoffeeModule中提供实例的方法不仅可以是静态方法！还可以是普通方法或抽象方法。那如果我们将DripCoffeeModule中的静态方法的static去掉改为普通方法生成的代码又是怎么样的呢？(@Provides static Heater provideHeater()改为@Provides Heater provideHeater())看下图：\n\n可以看到DripCoffeeModule_ProvideHeaterFactory的创建须传入DripCoffeeModule实例，get()方法通过该实例获取Heater实例\n创建Heater的静态方法proxyProvideHeater须传入DripCoffeeModule实例。\n\n\n\n\n\n5. 我们来看看Pump对应生成的工厂类：DripCoffeeModule_ProvidePumpFactory\n\n在Module中这样定义：@Provides static Pump providePump(Thermosiphon pump) { return pump; }\n这个方法又必须提供Thermosiphon实例，因此DripCoffeeModule_ProvidePumpFactory的构造参数是Thermosiphon的工厂对象来提供该实例（get()方法中通过调用静态方法providePump得到Pump实例的时候需要该工厂类提供）\n我们看到proxyProvidePump方法，也是可在不创建工厂类实例的情况下调用。\n\n如果我们也把Module中的static修饰去掉又会发生什么样的变化呢？我猜您也应该能想到了！看下图：\n\n比4中去掉static多了划线的地方\n也就是说当我们定义的方法是普通方法时，我们就必须要提供Module的实例\n\n\n\n6. 最后，我们来看DaggerCoffeeShop是如何将这些东东组合在一起的。\n\n我们看到getPump()方法，它在接口CoffeeShop中定义，里面如何实现的呢？\n它直接调用了上面5所讲到的静态方法proxyProvidePump来创建Pump实例，但是需要提供Thermosiphon实例作为参数。（如果是用的@Binds方式，则getPump()的实现为：  public Pump getPump() { return getThermosiphon(); }）\n于是，它定义了方法getThermosiphon()来创建该实例。看到该方法了吗？里面是直接new Thermosiphon，这就是Thermosiphon_Factory没有用到的原因。创建Thermosiphon的构造参数Heater由DripCoffeeModule_ProvideHeaterFactory类名直接调用静态方法proxyProvideHeater()它又调用DripCoffeeModule.provideHeater()来提供。\n\n接下来看到创建DaggerCoffeeShop的Builder静态内部类，这里面可要比我们上次生成的DaggerPumpComponent要多了一个方法，它出现的原因就是因为我们定义了Module类。\n\n这个方法的命名方式是将我们定义的Module类的类名开头小写来作为名字。\n它的作用是我们可以自己创建Module，如果不自己创建，将会自动创建。\n但为什么这里标记为弃用呢？那是因为我们Module中全是静态方法，完全不需要实例化，实例化也白搭！那我们来看看，如果将DripCoffeeModule中的方法改为普通方法是什么样的呢？\n看到了吧！如果build()方法中判断了我们已经调用dripCoffeeModule方法传进来Module实例，那么就不去实例化了。\n还记得上面Module中我们去掉提供方法static后需要的Module实例吗？实例就是开始于这里的。\ndripCoffeeModule的调用方式就是：DaggerCoffeeShop.builder().dripCoffeeModule(new DripCoffeeModule()).build();（如果我们的@Component连接了多个Module那么就可以这样传入这么多个Module实例）\n那么这个方法到底有什么神奇的作用呢？我们想想看，如果Module的构造方法需要传参，此时我们该怎么办呢？如下：\n1234567891011121314151617181920212223242526272829303132333435363738public class TestModuleAttr &#123;    private String str;    public TestModuleAttr(String str) &#123; this.str = str; &#125;    @Override    public String toString() &#123;return \"TestModuleAttr&#123;\" + \"str='\" + str + '\\'' +'&#125;';&#125;&#125;------------------------------------------@Modulepublic class DripCoffeeModule &#123;    private String str;    public DripCoffeeModule(String str) &#123; this.str = str; &#125;    ...    @Provides String provideStr() &#123; return str; &#125;    @Provides TestModuleAttr provideTestModuleAttr(String s) &#123; return new TestModuleAttr(s); &#125;&#125;------------------------------------------@Component(modules = &#123;DripCoffeeModule.class&#125;)public interface CoffeeShop&#123;    Pump getPump();    TestModuleAttr getTestModuleAttr();&#125;------------------------------------------/** * 测试 */public class CoffeeApp&#123;    public static void main(String[] args) &#123;        System.out.println(                DaggerCoffeeShop                        .builder()                        .dripCoffeeModule(new DripCoffeeModule(\"Hello world\"))                        .build()                        .getTestModuleAttr());//        Pump pump = DaggerCoffeeShop.create().getPump();//        System.out.println(\"pump = \" + pump);//        pump.pump();    &#125;&#125;\n\n输入结果：TestModuleAttr{str=&#39;Hello world&#39;}\n\n当我们想向提供的对象传递一些动态的东西时，就可以通过这种方式，当然你也不用向我这样绕了个圈子，这里只想说Module里面可以相互提供实例。这里可以直接@Provides TestModuleAttr provideTestModuleAttr() { return new TestModuleAttr(str); }搞定。\n需要注意的是，如果Module实例是有参构造创建，我们必须自己实例化Module。否则则会抛出异常。原因，如下：\n\n\n\n@Component测试文件位置\n上面都涉及到了它，想必大家也有些熟悉了。ヾ(๑╹◡╹)ﾉ”\n官方把这个定义叫做建立图表，它起到的作用是连接依赖关系，通过上面的分析，我们可以直观的看到在DaggerXXX(@Component修饰的类所对应生成的文件)类中，主要就是将各个工厂类和Module连接起来。\n\n如果我们像下面这样定义一个Component，Dagger将会为我们生成一个类：DaggerFoo_Bar_BazComponent\n\n123456class Foo &#123;  static class Bar &#123;    @Component    interface BazComponent &#123;&#125;  &#125;&#125;\n\n@Component不仅可以装饰接口还可以是抽象类，比如上面的CoffeeShop接口可以改成这样：\n\n123456@Component(modules = &#123;DripCoffeeModule.class&#125;)public abstract class CoffeeShop&#123;    abstract Pump getPump();    abstract TestModuleAttr getTestModuleAttr();&#125;\n在Component中定义的方法我们在对应生成的DaggerXXX实例调用得到对应实例，于是我们需要为其提供对应返回实例。\n\n接下来我们来通过模拟安卓中Activity的启动，该代码大概模拟了一下MVP。为了简单，MNActivity作为View层，我没有写MVP接口的M层。这里主要是想解释为什么在Compnent接口中需要定义一个void inject(XXXActivity activity);，看到别人这么写的！但我当时真心不知道这是啥意思！于是这里我想通过简单的代码去理解它。\n\n\n模拟一个Activity，一般我们在Activity的onCreate()方法中是这样写的。\n123456789101112131415public class MNActivity&#123;    @Inject    MNPresenter presenter;    public void onCreate()    &#123;        System.out.println(\"MNActivity hashCode = \" + hashCode());        DaggerTestComponent                .builder()                .mNModule(new MNModule(this))                .build()                .inject(this);        System.out.println(presenter);    &#125;&#125;\n\nPresenter层，在presenter中一般我们是引用的view的接口，这里我们直接引用activity。\n\n@Inject标记构造，表明这里提供MNPresenter实例\n我们看到有构造方法参数为MNActivity，表明需要实例化我们又需要为它提供MNActivity（我们通过Module提供）12345678910public class MNPresenter&#123;    MNActivity mnActivity;    @Inject    MNPresenter(MNActivity mnActivity)    &#123;        this.mnActivity = mnActivity;        System.out.println(\"MNPresenter mnActivity = \" + mnActivity.hashCode());    &#125;&#125;\n\n\n\n实例提供部分类：Module\n\nMNModule是有参构造，通过上面的学习，我们知道这种情况必须我们自己实例化Module\n通过provedesActivity我们可以将传递进来的MNActivity实例，提供出去（这里提供给MNPresenter）123456789101112131415@Modulepublic class MNModule&#123;    MNActivity mnActivity;    public MNModule(MNActivity mnActivity)    &#123;        this.mnActivity = mnActivity;    &#125;    @Provides    MNActivity provedesActivity()    &#123;        return mnActivity;    &#125;&#125;\n\n\n\n组装纽带部分：Component\n\ninject方法返回值为void12345@Component(modules = MNModule.class)public interface TestComponent&#123;    void inject(MNActivity me);&#125;\n\n\n\n启动Activity类\n12345678public class Main&#123;    public static void main(String[] args)    &#123;        MNActivity injectMe = new MNActivity();        injectMe.onCreate();    &#125;&#125;\n\n运行Main的结果\n123MNActivity hashCode = 21685669MNPresenter mnActivity = 21685669com.example.jiaji.daggertest.coffee4.MNPresenter@61bbe9ba\n\n\n\n为什么这么神奇呢？居然就这样就将MNPresenter的实例注入到MNActivity了！DaggerTestComponent实现我们定义的void inject(MNActivity me);，然后在方法里进行了如这样的操作（简化后）：me.presenter = new Presenter(...);\n\n\n我们将void inject(MNActivity me);的实现代码和上面测试@Inject时定义的Thermosiphon getPump();的实现代码进行比较，来看看有何区别。\n\n\n我们先来看Thermosiphon getPump();是如何实现的呢？重温一下，看下图：\n它首先通过Thermosiphon_Factory.newThermosiphon()直接new Thermosiphon()。\n然后调用injectThermosiphon方法将实例化的Thermosiphon通过Thermosiphon_MembersInjector.injectHeater将一个ElectricHeater赋值到对应的成员变量。\n最后将一个完成的Thermosiphon返回。\n\n\n我们再来看void inject(MNActivity me);是如何实现的呢？看下图：\n这里inject(MNActivity me)的实现省略掉了创建MNActivity的过程，直接调用injectMNActivity进行注入。\n为什么呢？因为当前MNActivity对象已经存在，只需要注入标有@Inject的成员变量就行了。\n我们想想Android中打开一个Activity，他是通过系统去实例化的！我们既然在Activity实例之中，又何必去实例化它呢？对吧！\n\n\n\n将上面所学运用到一开始的咖啡机实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889--------------------------------------------------------interface Heater &#123;    void on();    void off();    boolean isHot();&#125;--------------------------------------------------------interface Pump &#123;    void pump();&#125;--------------------------------------------------------public class Thermosiphon implements Pump &#123;    private final Heater heater;    @Inject    Thermosiphon(Heater heater) &#123;        System.out.println(\"Thermosiphon(Heater heater) - heaterHash = \" + heater.hashCode());        this.heater = heater;    &#125;    @Override    public void pump() &#123;        if (heater.isHot()) &#123;            System.out.println(\"=&gt;=&gt; 抽水 =&gt;=&gt;\");        &#125;    &#125;&#125;--------------------------------------------------------public class ElectricHeater implements Heater &#123;    public ElectricHeater() &#123; System.out.println(\"ElectricHeater()\"); &#125;    boolean heating;    @Override    public void on() &#123;        System.out.println(\"~~~~heating~~~~\");        this.heating = true;    &#125;    @Override    public void off() &#123; this.heating = false; &#125;    @Override    public boolean isHot() &#123; return heating; &#125;&#125;--------------------------------------------------------@Modulepublic class DripCoffeeModule &#123;    @Provides    Heater provideheater() &#123;        System.out.println(\"provideheater()\");        return new ElectricHeater();    &#125;    @Provides    Pump providePump(Thermosiphon pump) &#123;        System.out.println(\"providePump\");        return pump;    &#125;&#125;--------------------------------------------------------/** * 咖啡机 */public class CoffeeMaker &#123;    @Inject    Heater heater;//当我们要使用它时才创建一个加热器    @Inject    Pump pump;//泵    @Inject    CoffeeMaker() &#123; &#125;    public void brew() &#123;        System.out.println(\"CoffeeMaker - heaterHash = \" + heater.hashCode());        heater.on();        pump.pump();        System.out.println(\"[_]P coffee! [_]P\");        heater.off();    &#125;&#125;--------------------------------------------------------@Component(modules = &#123;DripCoffeeModule.class&#125;)public interface CoffeeShop &#123;    CoffeeMaker maker();&#125;--------------------------------------------------------public class CoffeeApp&#123;    public static void main(String[] args)    &#123;        CoffeeShop coffeeShop = DaggerCoffeeShop.builder()                .build();        coffeeShop.maker().brew();    &#125;&#125;\n\n我们来看一下输出结果\n\n123456789provideheater()ElectricHeater()provideheater()ElectricHeater()Thermosiphon(Heater heater) - heaterHash = 1625635731providePumpCoffeeMaker - heaterHash = 1580066828~~~~heating~~~~[_]P coffee! [_]P\n\n大家有木有发现，当调用heater.on()后调用pump.pump()居然没有出水(没有打印：=&gt;=&gt; 抽水 =&gt;=&gt;)\n通过输出结果我们看到provideheater被调用两次也就是两次new，我们还会会发现：Thermosiphon中的Heater对象和CoffeeMaker中的Heater对象打印的hashCode不一样，这根本就是两个实例。怪不得CoffeeMaker中heater.on()后pump.pump()不出水，原因就是Pump中又是另一个Heater实例。\n\n\n看来通过上面的学习，我们的咖啡机还有点缺陷。我们需要通过下面所讲的@Singleton来拯救一下这个多次实例化的问题。\n\n\n最后我将上面这些大致理解思路画了如下流程图，希望能帮助您理解：\n\n\n@Singleton丶@Scope测试文件位置\n\nSingleton：直接翻译过来是独生子的意思。我们可以这样去理解，标记了@Singleton提供的类，在同一个Component实例中(这是条件)只存在一个该实例，多次需要时，提供的实例也只是第一次创建的那个实例。\n\n\n我们只需要将上面咖啡机的实现代码加两个@Singleton就可以解决问题！如下代码：\n在提供实例那里加个@Singleton\n在Component那里加个@Singleton\n也就是说@Singleton起效，得添加两处\n\n\n\n123456789101112131415161718192021222324252627@Singleton@Component(modules = &#123;DripCoffeeModule.class&#125;)public interface CoffeeShop &#123;    CoffeeMaker maker();&#125;--------------------------------------------------------@Modulepublic class DripCoffeeModule &#123;    @Singleton    @Provides    Heater provideheater() &#123;        System.out.println(&quot;provideheater()&quot;);        return new ElectricHeater();    &#125;    ...&#125;----------------------------------------------------------------------------------------------------------------输出日志：provideheater()ElectricHeater()Thermosiphon(Heater heater) - heaterHash = 1872034366providePumpCoffeeMaker - heaterHash = 1872034366~~~~heating~~~~=&gt;=&gt; 抽水 =&gt;=&gt;[_]P coffee! [_]P\n\n那么如果是@Inject标记的构造方法的方式来提供的对象，@Singleton该如何标记呢？如下代码：\n\n\n放到类名之上123456789101112131415161718192021222324252627282930@Singletonpublic class SingletonTest&#123;    @Inject    public SingletonTest()&#123;&#125;&#125;--------------------------------------------------------public class CoffeeMaker &#123;    ...    @Inject    SingletonTest singletonTest1;    @Inject    SingletonTest singletonTest2;    @Inject    SingletonTest singletonTest3;    ...    public void brew() &#123;        ...        System.out.println(                &quot;singletonTest1 = &quot; + singletonTest1.hashCode() + &quot;\\n&quot;                + &quot;singletonTest2 = &quot; + singletonTest2.hashCode() + &quot;\\n&quot;                + &quot;singletonTest3 = &quot; + singletonTest3.hashCode() + &quot;\\n&quot;);    &#125;&#125;----------------------------------------------------------------------------------------------------------------输出日志：...singletonTest1 = 1581781576singletonTest2 = 1581781576singletonTest3 = 1581781576\n\n\n\n为什么说上面条件是需要在一个Component实例中？原因是如果Component被多次实例化，那么不同的Component中@Singleton标记的实例也将不同！\n\n\n来看看下面我们如果有多个Component实例的情况\n我们修改一下CoffeeApp这个类，让他重复调用brew()方法和重新创建Component\n12345678910111213141516public class CoffeeApp&#123;    public static void main(String[] args)    &#123;        CoffeeShop coffeeShop = DaggerCoffeeShop.builder()                .build();        coffeeShop.maker().brew();        System.out.println(\"*************************************\");        coffeeShop.maker().brew();        System.out.println(\"*************************************\");        DaggerCoffeeShop.builder()                .build()                .maker()                .brew();    &#125;&#125;\n\n输出结果(我们只看一些关键部分)：\n1234567891011121314151617...CoffeeMaker - heaterHash = 1872034366...singletonTest1 = 1581781576...*************************************...CoffeeMaker - heaterHash = 1872034366...singletonTest1 = 1581781576...*************************************...CoffeeMaker - heaterHash = 1725154839...singletonTest1 = 1670675563...\n\n从输出信息中我们可看出，第一次和第二次都是同一个heater实例，第三次却是不同的实例，因为我们重新实例化了一个Component。\n\n如果我们想在多个地方调用的时候也得到同一个Component实例，我们可以将Component作为抽象类，并改为单例。如下：\n12345678910111213141516@Component(modules = &#123;DripCoffeeModule.class&#125;)public abstract class CoffeeShop &#123;    private static CoffeeShop instance;    abstract CoffeeMaker maker();    public static CoffeeShop getInstance()    &#123;        if (instance == null)        &#123;            synchronized (CoffeeShop.class)            &#123;                instance = DaggerCoffeeShop.create();            &#125;        &#125;        return instance;    &#125;&#125;\n\n我们的使用的时候，直接这样：CoffeeShop.getInstance().maker().brew()\n\n我们在Android中，可以把这种全局的定义放到Application中也可以确保在该进程中的唯一。\n\n\n上面讲了@Singleton，那么@Scope又是什么呢？@Scope是用来标识注解的。我们看一下，@Singleton的源码你就明白了！\n\n1234@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125;\n\n用@Scope标识的注解都有@Singleton的功能，于是我们可以定义我们自己想要的名字来实现相同功能。\n但需要注意一点就是用的时候相对应的注解必须是同一个（比方说我定义了一个@MySingle，就不能在Component那里用@MySingle的同时，对应的提供对象那里却用的是@Singleton）\n\n\n又到了我们分析生成代码的环节，大家可以选择性跳过哦！(〃’▽’〃)\n\n\n我们直接来看DaggerCoffeeShop这个类，其他都和上面讲解的一样，变化就在该类！\n我们看到下图画红线的部分！他将@Singleton标记的对象直接放到了DaggerCoffeeShop作为成员变量（由于代码太多，我将CoffeeMaker中的SingletonTest都注释了）。\n等等！Provider&lt;Heater&gt;根据上面我们对工厂代码的研究！每次调用get()不都会重新实例化一个对象吗？为什么每次get()都是同一个实例？这就是第二根红线DoubleCheck的封装起的作用了！\n\n\nDoubleCheck.provider搞了什么名堂？大家跟着我点进去悄悄！\n\n我们看到这个静态方法！很明显，它是为了创建一个DoubleCheck对象，如果传进来的就是DoubleCheck对象，则直接返回实例。\n1234567public static &lt;P extends Provider&lt;T&gt;, T&gt; Provider&lt;T&gt; provider(P delegate) &#123;    checkNotNull(delegate);    if (delegate instanceof DoubleCheck) &#123;        return delegate;    &#125;    return new DoubleCheck&lt;T&gt;(delegate);&#125;\n\n我们看到DoubleCheck类也是实现了Provider接口的，所以在DaggerCoffeeShop中才能直接用Provider来引用。它既然也是一个Provider却又要传入一个Provider，它起了一个代理的作用。\n\n为什么get()调用后是同一个实例？原因是get()中进行了处理，如果get()过一次实例，那么下次将返回上一次的实例。下面是这部分源码：\n我们可以看到它不仅仅简单写了只返回一个实例的的代码，还写了一堆关于多线程同步相关代码。\n也就是说我们在多线程的情况下也可以放心的调用get()方法，而不用担心因为多线程而创建额外的实例。1234567891011121314151617181920public T get() &#123;   Object result = instance;   if (result == UNINITIALIZED) &#123;       synchronized (this) &#123;           result = instance;          if (result == UNINITIALIZED) &#123;                result = provider.get();                Object currentInstance = instance;                if (currentInstance != UNINITIALIZED &amp;&amp; currentInstance != result) &#123;                    throw new IllegalStateException(\"Scoped provider was invoked recursively returning \"                            + \"different results: \" + currentInstance + \" &amp; \" + result + \". This is likely \"                            + \"due to a circular dependency.\");                &#125;                instance = result;                provider = null;            &#125;        &#125;    &#125;    return (T) result;&#125;\n\n\n\n\n\n\n@Reusable测试文件位置\n它和@Singleton达到的效果差不多，而且逻辑也差不多，但是它却不保证是单实例！\n它的用法比@Singleton还简单点，只需要在提供实例的地方加个@Reusable就可以了，如下代码：\n\n就像下面这么简单就OK了，不用在Component中添加。\n\n12345678910@Modulepublic class DripCoffeeModule &#123;    @Reusable    @Provides    Heater provideheater() &#123;        System.out.println(\"provideheater()\");        return new ElectricHeater();    &#125;    ...&#125;\n\n我们再来看看，生成的代码和@Singleton的不同！\n\n\n我们改用@Reusable后，DaggerCoffeeShop有什么变化？\n唯一发生变化了地方就是这个方法里面的实现由DoubleCheck.provider变成了SingleCheck.provider\n\n\n那我们来到SingleCheck这个类，它和DoubleCheck不同点就在于get()方法的实现上，请看下面SingleCheck的get()源代码：\n可以看到它省去了DoubleCheck中一堆关于线程同步的代码\n也就是说我们在单线程中是可以放心使用@Reusable而不用担心重复实例化。12345678public T get() &#123;    Provider&lt;T&gt; providerReference = provider;    if (instance == UNINITIALIZED) &#123;        instance = providerReference.get();        provider = null;    &#125;    return (T) instance;&#125;\n\n\n\n\nLazy 注入测试文件位置\n通过它可以实现惰性实例化，也就是当我们第一次调用的时候才会创建实例。并且多次调用不会再次创建实例，只会返回第一次调用创建的实例。\n\n我们来看看它的用法！\n\n\n首先我们创建一个需要提供的对象\n12345678public class LazyEntity&#123;    @Inject    public LazyEntity()    &#123;        System.out.println(&quot;LazyEntity()&quot;);    &#125;&#125;\n\n然后我们创建一个Component，需要提供提供一个Main类\n12345@Componentpublic interface MyComponent&#123;    Main getMain();&#125;\n\n我们来看看这个Main类。Lazy的使用方法就是将要使用的对象作为Lazy的泛型参数，如下所示\n1234567891011121314151617181920public class Main&#123;    @Inject    Lazy&lt;LazyEntity&gt; entityLazy;    @Inject    public Main() &#123;&#125;    public static void main(String[] args)    &#123;        Main main = DaggerMyComponent.builder()                .build()                .getMain();        System.out.println(&quot;此时LazyEntity还没有实例化&quot;);        for (int i = 0; i &lt; 3; i++)        &#123;            System.out.println(main.entityLazy.get().hashCode());        &#125;    &#125;&#125;\n\n输出结果，也就是说我们重复调用都是一个实例。\n12345此时LazyEntity还没有实例化LazyEntity()162563573116256357311625635731\n\n\n\n来吧！进入生成代码分析阶段（当然可以选择跳过哈！）ヾ(◍°∇°◍)ﾉﾞ\n\n\n我们看到Dagger生成的DaggerMyComponent，需要值得注意的就是下面图片上划线的部分。\n可以看到这里也使用了DoubleCheck类（大家通过上面的学习应该熟悉了），也就是说我们得到的Lazy对象其实就是一个DoubleCheck。\n所以说我们能多次调用也只能返回相同的实例，而且也能在多线程调用也不担心重复实例化。\n\n\n那么我们来看一下DoubleCheck.lazy这个静态方法，源代码如下：\n可以看到和之前介绍的DoubleCheck.provider一个模子刻出来的，那这里大家就自行了解咯！！1234567public static &lt;P extends Provider&lt;T&gt;, T&gt; Lazy&lt;T&gt; lazy(P provider) &#123;    if (provider instanceof Lazy) &#123;        @SuppressWarnings(\"unchecked\") final Lazy&lt;T&gt; lazy = (Lazy&lt;T&gt;) provider;        return lazy;    &#125;    return new DoubleCheck&lt;T&gt;(checkNotNull(provider));&#125;\n\n\n\n\nProvider 注入测试文件位置\n当您需要多个实例时，可以通过Provider&lt;T&gt;作为成员变量，您只需要每次调用它的get()方法就会返回不同的实例。\n\n我们直接将上面例子的Lazy改成Provider，其他都不变，如下：\n\n123456public class Main&#123;    @Inject    Provider&lt;LazyEntity&gt; entityLazy;    ...&#125;\n\n来看一下输出的结果：\n\n\n我们循环调用了三次get()方法，产生了三个不同的实例1234567此时LazyEntity还没有实例化LazyEntity()692404036LazyEntity()1554874502LazyEntity()1846274136\n\n\n\n来吧！生成代码分析阶段(｡･ω･｡)\n\n\n我们看DaggerMyComponent中是怎么注入的！看到划线部分传入的参数是LazyEntity的工厂类，意思说我们定义的成员变量指向的就是一个工厂类\n\n我们来看看这个工厂类吧！相信大家也相当熟悉了！(于是就不做说明了！！！)\n\n\n@Named丶@Qualifier测试文件位置\n大家可以先思考一个问题：一个机器人对象有两只手的实例（假如有手实现类：Hand），那么Dagger在提供实例时，如何才能区分这是提供给左的实例还是提供给右手的实例呢？\n\n解决这个问题的办法可以用@Named分别在变量名和提供实例的地方都标记一下名字。该名字作为@Named()的参数，如：@Named(&quot;who am i&quot;)。请看下面的例子演示！\n\n\n我们定义手实现类\n\ntoString()输出描述信息。1234567891011121314public class Hand&#123;    private String desc;    public Hand(String desc)    &#123;        this.desc = desc;    &#125;    @Override    public String toString()    &#123;        return desc;    &#125;&#125;\n\n\n\n我们定义Module类提供手的实例\n\n使用@Named标记该实例是哪只手，参数为机器人左手还是右手1234567891011121314151617@Modulepublic class RobotModule&#123;    @Named(\"left\")    @Provides    static Hand provideLeftHand()    &#123;        return new Hand(\"left hand\");    &#125;    @Named(\"right\")    @Provides    static Hand provideRightHand()    &#123;        return new Hand(\"right hand\");    &#125;&#125;\n\n\n\n我们定义一个Robot（当然这里Robot只看这两只手(～￣▽￣)～ ），顺便我就直接在这个类中测试了。\n\n通过@Named(&quot;left&quot;)标记这里要引用左手的实例\n通过@Named(&quot;right&quot;)标记这里要引用右的实例1234567891011121314151617181920212223public class Robot&#123;    @Named(\"left\")    @Inject    Hand leftHand;    @Named(\"right\")    @Inject    Hand rightHand;    @Inject    public Robot()    &#123;    &#125;    public static void main(String[] args)    &#123;        Robot robot = DaggerRobotComponent.create().getRobot();        System.out.println(robot.leftHand);        System.out.println(robot.rightHand);    &#125;&#125;\n\n\n\n创建一个Component\n12345@Component(modules = RobotModule.class)public interface RobotComponent&#123;    Robot getRobot();&#125;\n\n我们来看一看运行结果，可以看出跟我们标记的一样。\n12left handright hand\n\n\n\n那么@Qualifier又是什么呢？其实它和上面讲的@Scope一样，是标记在注解上的，就像@Singleton是官方为我们写好的一个用@Scope标记好的注解。@Named也是官方为我们准备好的用@Qualifier标注的注解。看@Named源码：\n\n12345678@Qualifier@Documented@Retention(RUNTIME)public @interface Named &#123;    /** The name. */    String value() default \"\";&#125;\n\n 因此我们可以定义自己@Qualifier，我们可以定义不传参数的，像下面这样：\n\n1234567@Qualifier@Retention(RUNTIME)public @interface Left &#123; &#125;---------------------------------------------------@Qualifier@Retention(RUNTIME)public @interface Right &#123; &#125;\n\n使用（结果是一样的效果）：\n\n1234567891011121314151617181920212223242526272829303132333435@Modulepublic class RobotModule&#123;    @Left    @Provides    static Hand provideLeftHand()    &#123;        return new Hand(\"left hand\");    &#125;    @Right    @Provides    static Hand provideRightHand()    &#123;        return new Hand(\"right hand\");    &#125;&#125;---------------------------------------------------public class Robot&#123;    @Left    @Inject    Hand leftHand;    @Right    @Inject    Hand rightHand;    @Inject    public Robot()    &#123;    &#125;    ...&#125;\n\n生成的代码分析：\n\n\n通过标记名字Dagger知道我们哪个变量对应哪个实例\n\n\n@BindsOptionalOf测试文件位置\n可选绑定，我们知道如果某个变量标记了@Inject，那么必须要为它提供实例，否则无法编译通过。现在我们可以通过将变量类型放入Optional&lt;T&gt;泛型参数，则可以达到：即使没有提供它的实例，也能通过编译。\nOptional这个类是什么呢？它的引入是为了解决Java中空指针的问题，您可以去这里了解一下：Java 8 Optional 类\n\n我们还是拿代码说话！这里有一个杯子，杯子里可以有咖啡，也可以没有咖啡！\n\n\n我们先来看有咖啡的时候的代码\n\n\n我们首先我们定义一个咖啡类\n1public class Coffee &#123; &#125;\n\n我们将Coffee类定义为可选的绑定\n\n创建一个Module抽象类来定义，返回类型就是咖啡\n用@BindsOptionalOf来标记123456@Modulepublic abstract class CModule&#123;    @BindsOptionalOf    public abstract Coffee optionalCoffee();&#125;\n\n\n\n我们在定义一个有提供Coffee实例的Module\n123456789@Modulepublic class CoffeeModule&#123;    @Provides    public Coffee provideCoffee()    &#123;        return new Coffee();    &#125;&#125;\n\n定义杯子类和Component\n\n我们直接在Cup添加main方法进行测试\nComponent将两个Module添加进来123456789101112131415161718192021222324252627282930public class Cup&#123;    @Inject    Optional&lt;Coffee&gt; coffee;    @Inject    public Cup()    &#123;    &#125;    public static void main(String[] args)    &#123;        Cup cup = DaggerCComponent.create().getCup();        System.out.println(cup.coffee);        if (cup.coffee.isPresent())        &#123;            System.out.println(\"有咖啡\");        &#125; else        &#123;            System.out.println(\"无咖啡\");        &#125;    &#125;&#125;------------------------------------------------------------------@Component(modules = &#123;CoffeeModule.class, CModule.class&#125;)public interface CComponent&#123;    Cup getCup();&#125;\n\n\n\n\n\n输出结果：\n\n12Optional[com.example.jiaji.daggertest.coffee8_optional_binding.Coffee@4b1210ee]有咖啡\n\n如果我们将CoffeeModule提供Coffee实例的方法注释掉123456789@Modulepublic class CoffeeModule&#123;//    @Provides//    public Coffee provideCoffee()//    &#123;//        return new Coffee();//    &#125;&#125;\n\n\n\n输出结果：\n\n12Optional.empty无咖啡\n\n这就是可选绑定的作用，Optional这个类在java 8中，并且最低Android Api 24。或者你可以选择导入guava这个类库，不过我去喵了一眼，它呀的太大了！！\n\n\n\nOptional还可以这样用！\n\n\nOptional&lt;Coffee&gt;\nOptional&lt;Provider&lt;Coffee&gt;&gt;\nOptional&lt;Lazy&lt;Coffee&gt;&gt;\nOptional&lt;Provider&lt;Lazy&lt;Coffee&gt;&gt;&gt;\n\n\n下面我们来看一看生成的代码长什么样吧! ヾ(=･ω･=)o\n\n目前我们直接看Component就够了，于是我们看到DaggerCComponent\n\n这是没有提供Coffee实例的情况下\n我们可以看到注入的时候，直接通过Optional.&lt;Coffee&gt;empty()创建了了一个没有内容的Optional\n\n\n来看提供了Coffee实例的情况\n我们需要知道Optional.of()是向Optional里面添加实例的意思，它将返回一个包含有该实例的Optional类\n\n\n\n@BindsInstance测试文件位置\n绑定实例，大家可以想象一下：如果我们提供实例的时候，需要在运行时提供参数去创建，那么该如何做呢？\n\n我们可以使用Builder绑定实例来做！这里我们举例一个需要参数名字和爱好才能创建的User对象。\n\n\n名字和爱好都是String类型，定义了两个@Scope注解来标识\n1234567@Qualifier@Retention(RUNTIME)public @interface Name &#123; &#125;----------------------------------------------------------@Qualifier@Retention(RUNTIME)public @interface Love &#123; &#125;\n\n创建一个User类\n\n该类为需要提供的对象，在构造方法上用@Inject标识\n由于姓名和爱好都属于String类型，所以我们需要标记一下区分123456789101112131415161718192021public class User&#123;    private String name;    private String love;    @Inject    public User(@Name String name, @Love String love)    &#123;        this.name = name;        this.love = love;    &#125;    @Override    public String toString()    &#123;        return \"User&#123;\" +                \"name='\" + name + '\\'' +                \", love='\" + love + '\\'' +                '&#125;';    &#125;&#125;\n\n\n\n创建Component，这里是关键部分了\n\n首先我们需要在该接口内部在定义Builder接口，该接口用`@Component.Builder标记，表示该接口会由Component的Builder`静态内部类实现。\n然后我们需要为定义方法name()和love()，加上注解@BindsInstance，返回类型为Builder。传入的参数需要用注解标识，去对应User构造参数。需要注意一点的就是方法只有一个参数，如果多个参数就会报错：只能有一个参数。\n最后UComponent build();就是我们通常最后调用的那个build()方法，创建返回Component实例。12345678910111213@Componentpublic interface UComponent&#123;    User getUser();    @Component.Builder    interface Builder    &#123;        @BindsInstance Builder name(@Name String name);        @BindsInstance Builder love(@Love String love);        UComponent build();    &#125;&#125;\n\n\n\n使用测试：\n1234567891011public class Main&#123;    public static void main(String[] args)    &#123;        UComponent uComponent = DaggerUComponent.builder()                .name(&quot;奏响曲&quot;)                .love(&quot;beautiful girl&quot;)                .build();        System.out.println(uComponent.getUser());    &#125;&#125;\n\n\n\n输出结果：\n\n1User&#123;name=&apos;奏响曲&apos;, love=&apos;beautiful girl&apos;&#125;\n可以看出BindsInstance就是就是改造了Component里面的Builder类，Builder类实现了用`@Component.Builder`标注的接口。\n\n接下来来看一下生成的相关代码！\n\n\n可以看到Component中的Builder实现了UComponent.Builder接口，并将传递进来的参数进行空检测与成员变量引用\n并且参数的实例也将会作为Component的成员变量，当创建User时作为其参数传入。\n\nComponent dependencies测试文件位置\ndependencies是注解@Component中的一个参数可以引用其他Component，我们看一下它的源码：\n\n可以看到它的定义和modules是一模一样\n也就是说我们可以依赖一个或多个Component12345678@Retention(RUNTIME)@Target(TYPE)@Documentedpublic @interface Component &#123;  Class&lt;?&gt;[] modules() default &#123;&#125;;  Class&lt;?&gt;[] dependencies() default &#123;&#125;;  ...&#125;\n\n\n它的主要作用就是将需要依赖的Component，放到自己的Component中当做成员变量直接引用。被依赖的Component就可以为主Component提供它在接口中定义的需要返回的实例。\n\n如果有AComponent dependencies BComponent\n那么则生成public class DaggerAComponent implements AComponent { BComponent bComponent;...}\n并且这个bComponent实例是我们在Builder类里面传进去的。\n\nComponent dependency只允许您通过组件依赖关系访问接口中公开的类型，既：你只能访问到Component接口中定义的返回类型。\n\n我们来实际操作！例子：咖啡和水\n\n\n定义咖啡和水的实例，在Coffee中我们覆写toString()把Coffee和Water的hashCode打印出来。\n12345678910111213141516public class Water &#123; &#125;---------------------------------------------------public class Coffee&#123;    private Water water;    public Coffee(Water water)    &#123;        this.water = water;    &#125;    @Override    public String toString()    &#123;        return \"coffee:\" + hashCode() + \"; water:\" + water.hashCode();    &#125;&#125;\n\n定义两个的Module分别提供实例\n12345678910111213141516171819@Modulepublic class WModule&#123;    @Provides    public Water provideWater()    &#123;        return new Water();    &#125;&#125;---------------------------------------------------@Modulepublic class CModule&#123;    @Provides    public Coffee provideCoffee(Water water)    &#123;        return new Coffee(water);    &#125;&#125;\n\n我们定义WComponent为Water的Component，定义CComponent为Coffee的Component。CComponent依赖于WComponent\n\n如下代码我们只需要在注解@Component中添加dependencies = WComponent.class就可以产生依赖。\n在使用的时候，我们只需要在创建CComponent的Builder对象中传入WComponent就可以了。12345678910111213141516171819202122232425262728public class ComponentDependency&#123;    @Component(modules = WModule.class)    public interface WComponent    &#123;        Water water();    &#125;    @Component(modules = CModule.class, dependencies = WComponent.class)    public interface CComponent    &#123;        Coffee coffee();    &#125;    public static void main(String[] args)    &#123;        WComponent wComponent = DaggerComponentDependency_WComponent                .create();        System.out.println(\"water:\" + wComponent.water().hashCode());        CComponent cComponent = DaggerComponentDependency_CComponent                .builder()                .wComponent(wComponent)                .build();        System.out.println(cComponent.coffee());    &#125;&#125;\n\n\n\n\n\n输出结果：\n\n12water:1846274136coffee:1639705018; water:1627674070\n\n通过结果我们可以看到，Water被重复实例化了，最简单的解决方法就是直接在provideWater()加上@Reusable注解。OK，达到效果\n\n1234567891011121314@Modulepublic class WModule&#123;    @Reusable    @Provides    public Water provideWater()    &#123;        return new Water();    &#125;&#125;---------------------------------------------------运行结果：water:491044090coffee:644117698; water:491044090\n\n但这也许不能保证您得到的一定是同一个实例，我们可以加上@Singleton注解，但是这里却是一个坑！因为这些Component的生命周期是不一样的，所以不能跨多个Component用同一个@Singleton来标记。如果这样做将会抛出一个错误信息：This @Singleton component cannot depend on scoped componentsstackoverflow\n\n\n我们可这样做，自定义一个Scope\n1234@Scope@Documented@Retention(RUNTIME)public @interface MySingle &#123; &#125;\n\n我们在Water这边用@Singleton\n1234567    @Singleton    @Provides    public Water provideWater()---------------------------------------------------    @Singleton    @Component(modules = WModule.class)    public interface WComponent\n\n我们在Coffee这边用@MySingle\n1234567    @MySingle    @Provides    public Coffee provideCoffee(Water water)---------------------------------------------------    @MySingle    @Component(modules = CModule.class, dependencies = WComponent.class)    public interface CComponent\n\n输出结果OK：\n12water:1625635731coffee:1580066828; water:1625635731\n\n\n\n我们来分析一下Dagger所生成的代码，主要我们看到DaggerComponentDependency_CComponent这个类，主要变化了在这里！\n\n\n我们看到DaggerComponentDependency_CComponent的内部Builder静态类\n从下面划线的地方我们可以看出，必须要传入依赖的Component的实例，否则会抛异常。\n\n\n我们看DaggerComponentDependency_CComponent里面的实现\n看到第一根划线处，它会把Builder中依赖的Component实例的引用传递给成员变量。\n看到第二根划线处，这里就跟我们平常调用接口中的方法一样能获得需要的实例，但是这里实例是通过依赖的Component来获取的实例。\n\n\n当我们用了Scope的时候，DaggerComponentDependency_CComponent还会生成一个静态类内部类\n可以看出它实现了Provider&lt;T&gt;因该就是为了通过Provider的get()方法来提供Water实例。\n并且这里它将依赖的Component放这里面了\n\n\n我们再来看此时的DaggerComponentDependency_CComponent\n它依赖的则是上面的静态内部类。\n并且通过我们熟悉的DoubleCheck.provider来对get()内逻辑进行的转变，使我们只获取一个实例。\n\n\n\n@Subcomponent测试文件位置\n最后我们来研究一下@Subcomponent，就如它名字一样，可以看做是一个Component的子类。\n\n我们来看一下它的源码：\n\n\n除了没有Class&lt;?&gt;[] dependencies() default {};长得和@Component一样。\n也就是说Subcomponent就不能依赖其他Component了123456789@Retention(RUNTIME)@Target(TYPE)@Documentedpublic @interface Subcomponent &#123;  Class&lt;?&gt;[] modules() default &#123;&#125;;  @Target(TYPE)  @Documented  @interface Builder &#123;&#125;&#125;\n\n\nSubComponent可以在声明它时从父级访问整个绑定图，即可以使用在其Modules中提供的实例。\n\n怎么使用，我们就直接用上个咖啡和水的代码！重新写一下他们的Component就行。\n\n\n这里我们将CComponent作为子Component用Subcomponent来标记\n然后我们还得在它的父Component中添加，如下面代码中的CComponent cComponent(CModule cModule);，如果@Subcomponent有多个Module，那么可以就要传递多个Module的参数。假如有：@Subcomponent(modules = {CModule.class, CModule2.class})，那么可以这样：CComponent cComponent(CModule cModule, CModule2 cModule2);\n我们在使用的时候需要先创建父Component，然后才能去创建子Component，如下main()方法中\n\n123456789101112131415161718192021222324public class SubComponent&#123;    @Component(modules = WModule.class)    public interface WComponent    &#123;        CComponent cComponent(CModule cModule);    &#125;    @Subcomponent(modules = CModule.class)    public interface CComponent    &#123;        Coffee coffee();    &#125;    public static void main(String[] args)    &#123;        WComponent wComponent = DaggerSubComponent_WComponent                .create();        CComponent cComponent = wComponent                .cComponent(new CModule());        System.out.println(cComponent.coffee());    &#125;&#125;\n\n@Subcomponent 和Component dependencies的一些对比\n\n\n@Subcomponent实例是通过父Component创建。Component dependencies可以依赖多个Component，并且各个Component单独创建且分离。\nComponent dependencies只运行您访问接口中公开定义提供的实例，@Subcomponent可访问其Modules中声明的所有对象\nComponent dependencies存在生命周期的不同，@Subcomponent是比当前父Component “更小”的周期。\n\n\n来看一下生成的代码DaggerSubComponent_WComponent，我们将其分成三部分来看\n\n\n首先我们看到DaggerSubComponent_WComponent内部类：子Component的定义\n它实现了我们定义的接口，并且和我们之前所生成的Component是类似的，只不过内部没有Builder静态类了。\n由于是内部类，所以它能访问所有父Component成员。\n\n\n我们来看Builder，Builder好说的，跳过！\n我们来看DaggerSubComponent_WComponent的方法\n可以看到，当我们调用cComponent时就会创建一个子Component现在类实例\n这是由于子Component是没有Builder去创建的也没有默认创建Module的功能。当然子Component也是需要他的Module的，于是要创建它需要的Module给它。\n\n\n\nSubcomponent和Component dependencies的关系区别\n安卓扩展的相关框架如果有机会，如果希望看我这种啰嗦介绍的人多的话，在写一篇关于这个的吧！\n\n结束好了，神不知鬼不觉的一星期码了这么多字。能挨着看到这里的同学，能有多少咧Σ(っ°Д°;)っ\n想起来，我以前写了一个MVP框架XMVP就是通过获取配置的泛型参数类型然后再通过反射去实例化的自动完成它们之间的依赖关系。也可以说是这就是依赖注入了吧！哈哈！有兴趣的朋友可以去看一看用一用非常简洁哦！(｀・ω・´)\n\n\n\n相关信息\n链接\n\n\n\n\n文章中所有代码的地址\nhttps://github.com/xujiaji/learn-android/tree/learn-dagger\n\n\n本文作者（欢迎关注）\n奏响曲\n\n\nGithub\nhttps://github.com/xujiaji/\n\n\n个人博客\nhttps://blog.xujiaji.com\n\n\n本文地址\nhttps://blog.xujiaji.com/post/learn-dagger\n\n\n\n如果文中内容有误或不合适欢迎您的指正！\nover\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/learn-dagger/home.jpg","plink":"https://blog.xujiaji.com/post/learn-dagger/"},{"title":"python web 从Win部署到ubuntu小记","date":"2018-05-28T07:54:30.000Z","author":"xujiaji","updated":"2019-04-08T06:56:53.997Z","content":"本篇文章主要是用来记录我将python后台部署到amazon ec2服务器的全过程，以及一些坑坑洼洼。希望对有需要的朋友提供帮助，并且往后也好快速回忆。我的学习地址:廖雪峰 实战 Day15-部署Web App\n注册并创建Amazon EC2实例\n首先需要创建一个账号，有12 个月的免费套餐访问权限。注册流程有点麻烦，需要添加信用卡，支付1美元来认证账号(•́へ•́╬)。然后验证码居然是打电话认证，电脑上会显示验证码，随后电话来了等她说完，手机输入验证码“#”结束。到此因该都注册成功了！\n找到EC2启动实例，创建一个ubuntu的实例，默认创建就OK了。\n创建结束会让你输入一个ssh密钥的名称，你输入一个邮箱之类的就行了，随后会帮你生成一个.pem的私密，下载下来放好咯！这玩意儿就相当于登录密码了。\n编辑安全组，添加22端口和80端口的访问权限\n在EC2管理界面将你创建的实例拉拉到最右边有个叫安全组的栏目，点进去\n进去后点击入站-编辑\n创建SSH入站规则，绑定自己的IP地址，第3步选了后会自动获取你的ip地址。如下图\n您还需要添加http 80端口，并且设置为任何位置都可访问，如下：\n\n\n\n连接到服务器使用 PuTTY 连接到服务器\n下载并安装PuTTY\n找到PuTTY安装目录，双击打开puttygen.exe\n加载之前您下载的.pem文件，需要转换一下私密格式\n点击save进行保存\n打开PuTTY进行配置\n配置SSH\n配置主机地址(ubuntu服务器地址前需要加上ubuntu@)，并保存配置。主机地址\n最后输入配置名称点击保存，下次就可以直接双击已配置好的选项直接进入。\n打开后也许也许你会发现进不去！这时你需要检查服务器安全组里是否添加SSH（如果最后也无法连接可把ssh来源改为任何位置试试），还有检查window防火墙是否开放22端口（可关闭防火墙试试，或在防火墙高级规则里面添加22端口访问）\n\n\n\nWinSCP 管理服务器文件资源\n下载地址\n安装时会自动检测到PuTTY的配置，选择导入\n直接选中你的站点登录就OK了。\n也许你会遇到没有权限无法创建文件的情况winscp普通用户上传文件没有权限解决\n\n配置python web环境\n接下来可以直接到这里去看部署过程了 廖雪峰 Python Day 15 - 部署Web App\n\n\n此时我们通过PuTTY登录服务器，我们输入python，会发现进入的是python2的版本\n我们需要安装python 3.6的版本，注意我们不要直接apt-get install python3，这样会直接安装成3.5的版本，然而aiomysql这个库不支持，折腾了许久。pip3也需要自己手动去安装的。\nUbuntu16.04安装Python3.6 和pip\n安装Nginx丶Supervisor丶MySQL命令：$ sudo apt-get install nginx supervisor mysql-server\nmysql安装的时候需要配置密码，密码得记好了\n编辑mysql配置文件设置utf8编码，输入命令：vim /etc/mysql/my.cnf\ni进入输入模式，添加下面配置, Esc进入命令模式 :wq进行保存退出\n重启MySQL1234567[client]default-character-set = utf8[mysqld]default-storage-engine = INNODBcharacter-set-server = utf8collation-server = utf8_general_ci\n\n\n\n\n5.将sql建数据库和表的配置文件传到服务器运行：$ mysql -u root -p &lt; schema.sql6.通过Navicat连接服务器数据库，这里的配置就跟本地的配置一样的，密码就是数据库的密码。然后我们去配置SSHip地址就是之前我们在网页后台看到的地址，端口号默认的22，选择公钥验证，私密选择我们之前用puttygen.exe导出的.ppk文件，密码短语就是创建服务器后创建的密钥名称（可以在EC2网页后台看到密钥名称这一栏）这下就爽了7.安装Web App用到的python库，命令：$ sudo pip3 install jinja2 aiomysql aiohttp\n部署\n安装自动化部署工具Fabric，命令：pip3 install fabric3\n此处都可以去看廖老师所讲的部署，因为教程是安装的python2环境下的fabric所以在这里绕了很久。\n配置的时候我们配置验证的时候我们可以直接用ssh来进行验证，env.hosts就是之前我们配置PuTTY是的主机地址，env.key_filename就是我们下载的ssh私密.pem\n我的fabric配置：fabfile.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# fabfile.pyimport os, refrom datetime import datetime# 导入Fabric API:from fabric.api import *# 服务器登录用户名:# env.user = 'ubuntu'# sudo用户为root:# env.sudo_user = 'ubuntu'# 服务器地址，可以有多个，依次部署:env.hosts = ['ubuntu@ec2-18-220-216-89.us-east-2.compute.amazonaws.com']env.key_filename = '~/.ssh/jiajixuqqcom.pem'# env.ssh_config_path = '~/.ssh/config'# env.use_ssh_config = True# 服务器MySQL用户名和口令:db_user = 'root'db_password = '6Sb8qzM38'_TAR_FILE = 'dist-awesome.tar.gz'_REMOTE_TMP_TAR = '/tmp/%s' % _TAR_FILE_REMOTE_BASE_DIR = '/srv/awesome'def touchfile():                         # 随便创建一个任务，用来测试    run('touch /tmp/www.txt')def deploy():    newdir = 'www-%s' % _now()    # 删除已有的tar文件:    run('rm -f %s' % _REMOTE_TMP_TAR)    # 上传新的tar文件:    put('dist/%s' % _TAR_FILE, _REMOTE_TMP_TAR)    # 创建新目录:    with cd(_REMOTE_BASE_DIR):        sudo('mkdir %s' % newdir)    # 解压到新目录:    with cd('%s/%s' % (_REMOTE_BASE_DIR, newdir)):        sudo('tar -xzvf %s' % _REMOTE_TMP_TAR)        # 需要添加权限浏览器才能访问        sudo('chmod -R 775 static/')        sudo('chmod 775 favicon.ico')        # 由于app.py的文件格式有问题，转换一下        run('dos2unix app.py')    # 重置软链接:    with cd(_REMOTE_BASE_DIR):        sudo('rm -f www')        sudo('ln -s %s www' % newdir)        sudo('chown ubuntu:ubuntu www')        sudo('chown -R ubuntu:ubuntu %s' % newdir)    # 重启Python服务和nginx服务器:    with settings(warn_only=True):        sudo('supervisorctl stop awesome')        sudo('supervisorctl start awesome')        sudo('/etc/init.d/nginx reload')def build():    includes = ['static', 'templates', 'transwarp', 'favicon.ico', '*.py']    excludes = ['test', '.*', '*.pyc', '*.pyo']    local('rm -f dist/%s' % _TAR_FILE)    with lcd(os.path.join(os.path.abspath('.'), 'www')):        cmd = ['tar', '--dereference', '-czvf', '../dist/%s' % _TAR_FILE]        cmd.extend(['--exclude=\\'%s\\'' % ex for ex in excludes])        cmd.extend(includes)        local(' '.join(cmd))\n\n\n添加https添加这个的原因嘛！就不加多少的啦！来看如何如何做吧！\n\n我是在阿里云上面找的一个免费版，可以在这里找到，进去后点击立即购买\n选择免费类型，如下操作\n然后就是需要填写一些您的个人信息和需要绑定的域名，比如我绑定：www.xujiaji.com，提交审核。（此时可能需要等个半个来小时审核）\n点击下载\n点击下载证书for Nginx，然后将压缩包解压得到两个文件。我们将这两个文件放到如下位置，/ect/nginx/是服务器nginx的安装目录，cert是新建的目录，就放这里面\n然后我们编辑/etc/nginx/sites-available/awesome，我们将这些东西直接拷贝过来\n重启nginx：sudo /etc/init.d/nginx reload\n配置完成后您可能还是无法访问https（我就在这纠结了半天），注意需要在服务器安全组添加所有用户对443端口的访问权限。\n下面是我的nginx整体配置代码，含义请看注释1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253server &#123;    # 监听80端口，作用是将用户http的请求转发到https    listen      80;    # 绑定的域名    server_name www.xujiaji.com;    rewrite ^(.*)$  https://www.xujiaji.com permanent;&#125;server &#123;    #listen      80;    # 下面这部分就是从阿里云下载AC认证那里直接拷贝过来的配置    listen 443;    ssl on;    ssl_certificate   cert/214731123750166.pem;    ssl_certificate_key  cert/214731123750166.key;    ssl_session_timeout 5m;    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_prefer_server_ciphers on;        # 代理的服务器根目录 日志    root       /srv/awesome/www;    access_log /srv/awesome/log/access_log;    error_log  /srv/awesome/log/error_log;    server_name www.xujiaji.com;    client_max_body_size 1m;    gzip            on;    gzip_min_length 1024;    gzip_buffers    4 8k;    gzip_types      text/css application/x-javascript application/json;    sendfile on;    location /favicon.ico &#123;        root /srv/awesome/www;    &#125;    location ~ ^\\/static\\/.*$ &#123;        root /srv/awesome/www;    &#125;    location / &#123;        proxy_pass       http://127.0.0.1:9000;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header Host $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    &#125;&#125;\n\n\n","thumbnail":null,"plink":"https://blog.xujiaji.com/post/python_server_deploy/"},{"title":"Android 无缝换肤深入了解与使用","date":"2018-04-21T01:03:41.000Z","author":"xujiaji","updated":"2019-04-08T15:57:46.648Z","content":"\n思路整体结构\n\n\n方案及轮子\n内部资源加载方案\n通过在BaseActivity中setTheme\n不好实时的刷新，需要重新创建页面\n存在需要解决哪些Vew需要刷新的问题\n\n\n自定义View\nMultipleTheme\n通过自定义View配合setTheme后立即刷新资源。\n需要替换所有需要换肤的view\n\n\n自定义xml属性，Java中绑定view\nColorful\n首先通过在java代码中添加view\n然后setTheme设置当前页面主题\n最后通过内部引用的上下文getTheme遍历view来修改资源\n\n\n动态资源加载方案\nAndroid-Skin-Loader\nThemeSkinning（是上面那个框架的衍生，整篇就是研究的这框架）\nresource替换：通过单独打包一个资源apk，只用来访问资源，资源名得与本身对应\n无需关心皮肤多少，可下载，等等\n准备采用该方案\n\n\n\n采用方案的技术点\n获取皮肤资源包apk的资源\n自定义xml属性，用来标记需要换肤的view\n获取并相应有换肤需求的布局\nLayoutInflater Factory使用基础与进阶\nAndroid 探究 LayoutInflater setFactory\n\n\n其他\n扩展可自行添加所支持换肤的属性\n改变状态栏颜色\n改变字体\n\n\n\n采用方案的实现过程\n加载皮肤apk获取里面的资源（为了得到皮肤apk  Resources对象）\n下面所有的代码位置，包括处理一些特殊问题的方案等等！\n\nhttps://github.com/xujiaji/ThemeSkinning\n\n通过皮肤apk的全路径，可知道其包名（需要用包名来获取它的资源id）\n\n\nskinPkgPath是apk的全路径，通过mInfo.packageName就可以得到包名\n代码位置：SkinManager.java\n\n123PackageManager mPm = context.getPackageManager();PackageInfo mInfo = mPm.getPackageArchiveInfo(skinPkgPath, PackageManager.GET_ACTIVITIES);skinPackageName = mInfo.packageName;\n\n通过反射添加路径可以创建皮肤apk的AssetManager对象\n\n\nskinPkgPath是apk的全路径，添加路径的方法是AssetManager里一个隐藏的方法通过反射可以设置。\n此时还可以用assetManager来访问apk里assets目录的资源。\n想想如果更换的资源是放在assets目录下的，那么我们可以在这里动动手脚。123AssetManager assetManager = AssetManager.class.newInstance();Method addAssetPath = assetManager.getClass().getMethod(\"addAssetPath\", String.class);addAssetPath.invoke(assetManager, skinPkgPath);\n\n\n\n创建皮肤apk的资源对象\n\n\n获取当前的app的Resources，主要是为了创建apk的Resources12Resources superRes = context.getResources();Resources skinResource = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());\n\n\n\n当要通过资源id获取颜色的时候\n\n\n先获取内置的颜色int originColor = ContextCompat.getColor(context, resId);\n如果没有外置皮肤apk资源或就用默认资源的情况下直接返回内置颜色\n通过 context.getResources().getResourceEntryName(resId);获取资源id获取它的名字\n通过mResources.getIdentifier(resName, &quot;color&quot;, skinPackageName)得到皮肤apk中该资源id。（resName：就是资源名字；skinPackegeName就是皮肤apk的包名）\n如果没有获取到皮肤apk中资源id（也就是等于0）返回原来的颜色，否则返回mResources.getColor(trueResId)\n\n通过getIdentifier方法可以通过名字来获取id，比如将第二个参数修改为layout、mipmap、drawable或string就是通过资源名字获取对应layout目录、mipmap目录、drawable目录或string文件里的资源id\n1234567891011121314151617public int getColor(int resId) &#123;    int originColor = ContextCompat.getColor(context, resId);    if (mResources == null || isDefaultSkin) &#123;        return originColor;    &#125;    String resName = context.getResources().getResourceEntryName(resId);    int trueResId = mResources.getIdentifier(resName, \"color\", skinPackageName);    int trueColor;    if (trueResId == 0) &#123;        trueColor = originColor;    &#125; else &#123;        trueColor = mResources.getColor(trueResId);    &#125;    return trueColor;&#125;\n\n当要通过资源id获取图片的时候\n\n\n和上面获取颜色是差不多的\n只是在图片在drawable目录还是mipmap目录进行了判断\n\n12345678910111213141516171819202122public Drawable getDrawable(int resId) &#123;    Drawable originDrawable = ContextCompat.getDrawable(context, resId);    if (mResources == null || isDefaultSkin) &#123;        return originDrawable;    &#125;    String resName = context.getResources().getResourceEntryName(resId);    int trueResId = mResources.getIdentifier(resName, \"drawable\", skinPackageName);    Drawable trueDrawable;    if (trueResId == 0) &#123;        trueResId = mResources.getIdentifier(resName, \"mipmap\", skinPackageName);    &#125;    if (trueResId == 0) &#123;        trueDrawable = originDrawable;    &#125; else &#123;        if (android.os.Build.VERSION.SDK_INT &lt; 22) &#123;            trueDrawable = mResources.getDrawable(trueResId);        &#125; else &#123;            trueDrawable = mResources.getDrawable(trueResId, null);        &#125;    &#125;    return trueDrawable;&#125;\n对所有view进行拦截处理\n自己实现LayoutInflater.Factory2接口来替换系统默认的\n\n\n那么如何替换呢？\n\n\n就这样通过在Activity方法中super.onCreate之前调用\n代码位置：SkinBaseActivity.java\n\n123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;    mSkinInflaterFactory = new SkinInflaterFactory(this);//自定义的Factory    LayoutInflaterCompat.setFactory2(getLayoutInflater(), mSkinInflaterFactory);    super.onCreate(savedInstanceState);&#125;\n\n我们使用的Activity一般是AppCompatActivity在里面的onCreate方法中也有对其的设置和初始化，但是setFactory方法只能被调用一次，导致默认的一些初始化操作没有被调用，这么操作？\n\n\n这是实现了LayoutInflater.Factory2接口的类，看onCreateView方法中。在进行其他操作前调用delegate.createView(parent, name, context, attrs)处理系统的那一套逻辑。\nattrs.getAttributeBooleanValue获取当前view是否是可换肤的，第一个参数是xml名字空间，第二个参数是属性名，第三个参数是默认值。这里相当于是attrs.getAttributeBooleanValue(&quot;http://schemas.android.com/android/skin&quot;, &quot;enable&quot;, false)\n代码位置：SkinInflaterFactory.java\n\n12345678910111213141516171819202122232425262728293031323334public class SkinInflaterFactory implements LayoutInflater.Factory2 &#123;    private AppCompatActivity mAppCompatActivity;    public SkinInflaterFactory(AppCompatActivity appCompatActivity) &#123;        this.mAppCompatActivity = appCompatActivity;    &#125;    @Override    public View onCreateView(String s, Context context, AttributeSet attributeSet) &#123;        return null;    &#125;    @Override    public View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;        boolean isSkinEnable = attrs.getAttributeBooleanValue(SkinConfig.NAMESPACE, SkinConfig.ATTR_SKIN_ENABLE, false);//是否是可换肤的view        AppCompatDelegate delegate = mAppCompatActivity.getDelegate();        View view = delegate.createView(parent, name, context, attrs);//处理系统逻辑        if (view instanceof TextView &amp;&amp; SkinConfig.isCanChangeFont()) &#123;            TextViewRepository.add(mAppCompatActivity, (TextView) view);        &#125;        if (isSkinEnable || SkinConfig.isGlobalSkinApply()) &#123;            if (view == null) &#123;                view = ViewProducer.createViewFromTag(context, name, attrs);            &#125;            if (view == null) &#123;                return null;            &#125;            parseSkinAttr(context, attrs, view);        &#125;        return view;    &#125;&#125;\n\n当内部的初始化操作完成后，如果判断没有创建好view，则需要我们自己去创建view\n\n\n看上一步是通过ViewProducer.createViewFromTag(context, name, attrs)来创建\n那么直接来看一下这个类ViewProducer，原理功能请看代码注释\n在AppCompatViewInflater中你可以看到相同的代码\n代码位置：ViewProducer.java\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class ViewProducer &#123;    //该处定义的是view构造方法的参数，也就是View两个参数的构造方法：public View(Context context, AttributeSet attrs)    private static final Object[] mConstructorArgs = new Object[2];    //存放反射得到的构造器    private static final Map&lt;String, Constructor&lt;? extends View&gt;&gt; sConstructorMap            = new ArrayMap&lt;&gt;();    //这是View两个参数的构造器所对应的两个参数    private static final Class&lt;?&gt;[] sConstructorSignature = new Class[]&#123;            Context.class, AttributeSet.class&#125;;    //如果是系统的View或ViewGroup在xml中并不是全路径的，通过反射来实例化是需要全路径的，这里列出来它们可能出现的位置    private static final String[] sClassPrefixList = &#123;            \"android.widget.\",            \"android.view.\",            \"android.webkit.\"    &#125;;    static View createViewFromTag(Context context, String name, AttributeSet attrs) &#123;        if (name.equals(\"view\")) &#123;//如果是view标签，则获取里面的class属性（该View的全名）            name = attrs.getAttributeValue(null, \"class\");        &#125;        try &#123;            //需要传入构造器的两个参数的值            mConstructorArgs[0] = context;            mConstructorArgs[1] = attrs;            if (-1 == name.indexOf('.')) &#123;//如果不包含小点，则是内部View                for (int i = 0; i &lt; sClassPrefixList.length; i++) &#123;//由于不知道View具体在哪个路径，所以通过循环所有路径，直到能实例化或结束                    final View view = createView(context, name, sClassPrefixList[i]);                    if (view != null) &#123;                        return view;                    &#125;                &#125;                return null;            &#125; else &#123;//否则就是自定义View                return createView(context, name, null);            &#125;        &#125; catch (Exception e) &#123;            //如果抛出异常，则返回null，让LayoutInflater自己去实例化            return null;        &#125; finally &#123;            // 清空当前数据，避免和下次数据混在一起            mConstructorArgs[0] = null;            mConstructorArgs[1] = null;        &#125;    &#125;    private static View createView(Context context, String name, String prefix)            throws ClassNotFoundException, InflateException &#123;        //先从缓存中获取当前类的构造器        Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);        try &#123;            if (constructor == null) &#123;                // 如果缓存中没有创建过，则尝试去创建这个构造器。通过类加载器加载这个类，如果是系统内部View由于不是全路径的，则前面加上                Class&lt;? extends View&gt; clazz = context.getClassLoader().loadClass(                        prefix != null ? (prefix + name) : name).asSubclass(View.class);                //获取构造器                constructor = clazz.getConstructor(sConstructorSignature);                //将构造器放入缓存                sConstructorMap.put(name, constructor);            &#125;            //设置为无障碍（设置后即使是私有方法和成员变量都可访问和修改，除了final修饰的）            constructor.setAccessible(true);            //实例化            return constructor.newInstance(mConstructorArgs);        &#125; catch (Exception e) &#123;            // We do not want to catch these, lets return null and let the actual LayoutInflater            // try            return null;        &#125;    &#125;&#125;\n\n当然还有另外的方式来创建，就是直接用LayoutInflater内部的那一套\n将view = ViewProducer.createViewFromTag(context, name, attrs);删除，换成下方代码：\n代码位置：SkinInflaterFactory.java\n\n123456789101112131415161718192021222324LayoutInflater inflater = mAppCompatActivity.getLayoutInflater();if (-1 == name.indexOf('.'))//如果为系统内部的View则，通过循环这几个地方来实例化View，道理跟上面ViewProducer里面一样&#123;    for (String prefix : sClassPrefixList)    &#123;        try        &#123;            view = inflater.createView(name, prefix, attrs);        &#125; catch (ClassNotFoundException e)        &#123;            e.printStackTrace();        &#125;        if (view != null) break;    &#125;&#125; else&#123;    try    &#123;        view = inflater.createView(name, null, attrs);    &#125; catch (ClassNotFoundException e)    &#123;        e.printStackTrace();    &#125;&#125;\n\nsClassPrefixList的定义\n\n12345private static final String[] sClassPrefixList = &#123;        \"android.widget.\",        \"android.view.\",        \"android.webkit.\"&#125;;\n\n最后是最终的拦截获取需要换肤的View的部分，也就是上面SkinInflaterFactory类的onCreateView最后调用的parseSkinAttr方法\n\n\n定义类一个成员来保存所有需要换肤的View, SkinItem里面的逻辑就是定义了设置换肤的方法。如：View的setBackgroundColor或setColor等设置换肤就是靠它。\n\n1private Map&lt;View, SkinItem&gt; mSkinItemMap = new HashMap&lt;&gt;();\n\nSkinAttr: 需要换肤处理的xml属性，如何定义请参照官方文档：https://github.com/burgessjp/ThemeSkinning\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private void parseSkinAttr(Context context, AttributeSet attrs, View view) &#123;    //保存需要换肤处理的xml属性    List&lt;SkinAttr&gt; viewAttrs = new ArrayList&lt;&gt;();    //变量该view的所有属性    for (int i = 0; i &lt; attrs.getAttributeCount(); i++) &#123;        String attrName = attrs.getAttributeName(i);//获取属性名        String attrValue = attrs.getAttributeValue(i);//获取属性值        //如果属性是style，例如xml中设置：style=\"@style/test_style\"        if (\"style\".equals(attrName)) &#123;            //可换肤的属性            int[] skinAttrs = new int[]&#123;android.R.attr.textColor, android.R.attr.background&#125;;            //经常在自定义View时，构造方法中获取属性值的时候使用到。            //这里通过传入skinAttrs，TypeArray中将会包含这两个属性和值，如果style里没有那就没有 - -            TypedArray a = context.getTheme().obtainStyledAttributes(attrs, skinAttrs, 0, 0);            //获取属性对应资源的id，第一个参数这里对应下标的就是上面skinAttrs数组里定义的下标，第二个参数是没有获取到的默认值            int textColorId = a.getResourceId(0, -1);            int backgroundId = a.getResourceId(1, -1);            if (textColorId != -1) &#123;//如果有颜色属性                //&lt;style name=\"test_style\"&gt;                    //&lt;item name=\"android:textColor\"&gt;@color/colorAccent&lt;/item&gt;                    //&lt;item name=\"android:background\"&gt;@color/colorPrimary&lt;/item&gt;                //&lt;/style&gt;                //以上边的参照来看                //entryName就是colorAccent                String entryName = context.getResources().getResourceEntryName(textColorId);                //typeName就是color                String typeName = context.getResources().getResourceTypeName(textColorId);                //创建一换肤属性实力类来保存这些信息                SkinAttr skinAttr = AttrFactory.get(\"textColor\", textColorId, entryName, typeName);                if (skinAttr != null) &#123;                    viewAttrs.add(skinAttr);                &#125;            &#125;            if (backgroundId != -1) &#123;//如果有背景属性                String entryName = context.getResources().getResourceEntryName(backgroundId);                String typeName = context.getResources().getResourceTypeName(backgroundId);                SkinAttr skinAttr = AttrFactory.get(\"background\", backgroundId, entryName, typeName);                if (skinAttr != null) &#123;                    viewAttrs.add(skinAttr);                &#125;            &#125;            a.recycle();            continue;        &#125;        //判断是否是支持的属性，并且值是引用的，如：@color/red        if (AttrFactory.isSupportedAttr(attrName) &amp;&amp; attrValue.startsWith(\"@\")) &#123;            try &#123;                //去掉属性值前面的“@”则为id                int id = Integer.parseInt(attrValue.substring(1));                if (id == 0) &#123;                    continue;                &#125;                //资源名字，如:text_color_selector                String entryName = context.getResources().getResourceEntryName(id);                //资源类型，如:color、drawable                String typeName = context.getResources().getResourceTypeName(id);                SkinAttr mSkinAttr = AttrFactory.get(attrName, id, entryName, typeName);                if (mSkinAttr != null) &#123;                    viewAttrs.add(mSkinAttr);                &#125;            &#125; catch (NumberFormatException e) &#123;                SkinL.e(TAG, e.toString());            &#125;        &#125;    &#125;    //是否有需要换肤的属性？    if (!SkinListUtils.isEmpty(viewAttrs)) &#123;        SkinItem skinItem = new SkinItem();        skinItem.view = view;        skinItem.attrs = viewAttrs;        mSkinItemMap.put(skinItem.view, skinItem);        //是否换肤        if (SkinManager.getInstance().isExternalSkin() ||                SkinManager.getInstance().isNightMode()) &#123;//如果当前皮肤来自于外部或者是处于夜间模式            skinItem.apply();//应用于这个view        &#125;    &#125;&#125;\n采用方案的注意事项和疑问\n可能系统会更改相关方法，但好处大于弊端\n插件化也是外置apk来加载，如何做到呢？\n占时不去研究\n\n\n皮肤从网络上下载到哪个目录？如何断定皮肤已经下载？\n可以通过SkinFileUtils工具类调用getSkinDir方法获取皮肤的缓存目录\n下载的时候可以直接下载到这个目录\n有没有某个皮肤就判断该文件夹下有没有这个文件了\n\n\n如何不打包之前可以直接预览？\n想要能在打包前提前预览效果，而不每次想看一看效果就要打一个apk包\n首先，大家都应该知道分渠道的概念。通过分渠道打包，因为我们能把资源也分成不同渠道的，运行不同渠道，所得到的资源是不一样的。\n然后，我们在:项目目录\\app\\src，创建一个和渠道相同名字的目录。比如说有个red渠道。 \n最后，我们选编译的渠道为red，然后直接运行就可以看到效果了。如果可以直接把res拷贝到皮肤项目打包就行了。\n\n\n换肤对应的属性需要是View提供了set方法的的属性！\n如果没有提供则不能在java代码中设置值\n如果是自定义View那么就添加对应方法\n如果是系统或类库View，额(⊙o⊙)…\n\n\n换肤的属性值需要是@开头的数据引用，如：@color/red\n原因是因为固定的值一般不可能是需要换肤的属性，在SkinInfaterFactory的方法parseSkinAttr中有这样一句来进行过滤没有带@的属性值：\n但此时，正好有一个自定义View没有按照常路出牌，它的值就是图片名字没有类型没有引用，通过java代码context.getResources().getIdentifier(name, &quot;mipmap&quot;, context.getPackageName())来获取图片资源（参考这奇葩方式的库）。但由于这个属性是需要换肤更换的属性，于是没办法，专门为这两个属性在SkinInfaterFactory的parseSkinAttr方法中写了个判断。参考这代码\n\n\n\n其他参考\nAndroid主题换肤 无缝切换 (主要参考对象，用的也是他修改Android-Skin-Loader后的框架ThemeSkinning）\nAndroid换肤技术总结\nAndroid apk动态加载机制的研究\n\n涉及及其延生\n插件化开发，既然能这样获取资源，也能获取class文件\n通过对view的拦截可以把某个控件整体替换掉。比如AppCompatActivity将TextView偷偷替换成了AppCompatTextView等等。\n\n\n\n其他一些帮助信息：\n\n上面对应的代码片段都有对应路径哦！\n这篇文章的全部代码，测试项目位置：https://github.com/xujiaji/ThemeSkinning\n测试项目中的首页底部导航测试和修改位置：https://github.com/xujiaji/FlycoTabLayout\n下面这张Gif图片是测试项目运行的效果图：\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/android-skin/skin_home.jpg","plink":"https://blog.xujiaji.com/post/android-skin/"},{"title":"Android开发-零碎笔记","date":"2018-01-24T09:03:41.000Z","author":"xujiaji","updated":"2019-04-08T06:55:02.961Z","content":"垂直RecyclerView嵌套垂直RecyclerView滑动时出现的卡顿原因：内部RecyclerView重复设置适配器导致的卡顿\n解决：判断内部RecyclerView是否设置过适配器，如果没有才设置\n12345678910//内部RecyclerView的获取和处理问题的代码RecyclerView rvItem = helper.getView(R.id.rvItem);rvItem.setNestedScrollingEnabled(false);if(rvItem.getAdapter() == null)&#123;    LinearLayoutManager layoutManager = new LinearLayoutManager(mContext);    layoutManager.setAutoMeasureEnabled(true);    rvItem.setLayoutManager(layoutManager);    rvItem.setAdapter(new OrderItemAdapter(item.getList()));&#125;\nScrollView嵌套RecyclerView滑动滑动起来很吃力1recyclerView.setNestedScrollingEnabled(false);\nRecyclerView嵌套RecyclerView时，刷新内部RecyclerView会跳动原因：内部RecyclerView抢占了焦点\n解决：将内部RecyclerView的焦点设置为false1recyclerView.setFocusableInTouchMode(false);\nadb之Wifi连接手机\n查看当前设备adb devices\n\n123$ adb devices7d1cbcbb\tdevice192.168.56.101:5555\tdevice\n\n让adb重新启动，并监听端口5555adb -s 设备名 tcpip 5555\n\n12$ adb -s 7d1cbcbb tcpip 5555restarting in TCP mode port: 5555\n\n连接adb connect ip地址:端口，在手机上查看连接的wifi地址，WiFi需要和电脑网络同网段\n\n12$ adb connect 192.168.2.207:5555connected to 192.168.2.207:5555\n空包签名1jarsigner -verbose -keystore [keystore签名秘钥路径] -signedjar [apk输出路径] [apk输入路径（需要签名的空包）] [签名秘钥别名]\n获取签名sha11keytool -list -v -keystore [签名路径]\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/android-notes/banner.png","plink":"https://blog.xujiaji.com/post/android-notes/"},{"title":"HappyBubble-气泡对话框（根据被点击View位置显示、可定制）","date":"2017-12-16T06:08:50.000Z","author":"xujiaji","updated":"2019-04-08T06:55:29.450Z","content":"\n\n\n\n\n\n\n\n\nHappyBubbleGithub\n气泡布局的形状可以改变，如四角弧度、气泡颜色、箭头大小和阴影。\n气泡Dialog可以根据被点击的view的位置来确定自己展示的位置。\n旧文档\n更新\n1.1.7: 修复位置问题，修复autoPosition无效问题，修复横屏模式问题。#13#11#10\n1.1.6:新增方向优先级:issues/9\n1.1.5:修复:issues/8\n1.1.4：①新增方法setLayout(int width, int height, int margin)，width（设置气泡的宽）、height（设置气泡的高）、margin（设置距离屏幕边缘的间距,只有当设置width或height为MATCH_PARENT才有效）。②autoPosition(true)方法准备弃用（现在还可以用），使用新方法autoPosition(Auto),如果两个都使用了会直接用autoPosition(Auto)。请参考下方“方法参考表”。③感谢@wolf8088521提供建议#4\n1.1.3：①通过重新调用setClickedView可以直接更新当前dialog的所在位置。②新添加setRelativeOffset(int)方法，设置dialog相对与被点击View的偏移（负值：向被点击view的中心偏移；正值：向被点击view的外侧偏移）③测试页面SetClickedViewTestActivity.java\n\n\n\n1.1.2：修复默认值没有适配屏幕\n\n1.1.1：修复大小变化后，没有对应变化位置的问题；修复接触顶部偏位问题；\n\n1.1.0：①Dialog交互事件传递到Activity达到不在不关闭Dialog的情况下做其他Activity的操作。②添加自动根据被点击View距离屏幕边缘的距离确定Dialog的位置。③新增“autoPosition”和“setThroughEvent”方法，请参考“BubbleDialog方法参考表”\n\n1.0.3:继续优化了点击在气泡之外才会被dismiss；修复了Dialog周围会有部分点击无法dismiss；\n\n1.0.2:修复点击dialog边缘无法取消\n\n\n哪些app使用了它？\n\n\n玩清单\n\n\n\n\n\n\n\n\n如何开始？在你模块中的build.gradle添加上HappyBubble依赖\n1implementation 'com.github.xujiaji:happy-bubble:1.1.7'\n如何使用 HappyBubble-BubbleDialog？\n方法参考表\n\n\n\n\n方法名\n参数\n描述\n\n\n\n\naddContentView\nView\n添加填充在气泡中的视图\n\n\nsetClickedView\nView\n被点击的View（触发Dialog出现的View）\n\n\nsetPosition\nenum …  BubbleDialog.Position:LEFTTOPRIGHTBOTTOM\nBubbleDialog相对于被点击的view的位置。如果传入多个位置，那么最前面的位置优先级越高\n\n\nsetOffsetX\nint\n如果您对dialog所展示的x轴位置不满，需要调整x轴方向偏移\n\n\nsetOffsetY\nint\n如果您对dialog所展示的y轴位置不满，需要调整y轴方向偏移\n\n\nsetBubbleLayout\nBubbleLayout\n自定义dialog的气泡布局\n\n\nsetTransParentBackground\n-\n背景透明\n\n\nsoftShowUp\n-\n当气泡dialog中有EditText时，软键盘弹出会遮挡EditText时，dialog随软键盘上移。\n\n\nshow\n-\n显示\n\n\nautoPosition\nenum Auto:AROUNDUP_AND_DOWNLEFT_AND_RIGHT\n自动确定位置功能，显示在被点击View距离屏幕边缘的最大空间。开启后，“setPosition”功能失效。AROUND：被点击View四周；UP_AND_DOWN：被点击View上下显示；LEFT_AND_RIGHT：被点击View左右显示；\n\n\nsetThroughEvent\nboolean, boolean\n第一个参数isThroughEvent设置是否穿透Dialog手势交互。第二个参数cancelable点击空白是否能取消Dialog，只有当”isThroughEvent=false”时才有效\n\n\nsetRelativeOffset\nint\n设置dialog相对与被点击View的偏移（负值：向被点击view的中心偏移；正值：向被点击view的外侧偏移），设置后会直接影响setOffsetX和setOffsetY方法。\n\n\nsetLayout\nint，int，int\n设置气泡的宽高和距离屏幕边缘的距离第一个参数：width（设置气泡的宽）；第二个参数：height（设置气泡的高）；第三个参数：margin（设置距离屏幕边缘的间距,只有当设置width或height为MATCH_PARENT才有效）。宽高单位为px或MATCH_PARENT\n\n\n\n最简单的实现\n\n\n\n\n\n\n\n\n1234new BubbleDialog(this)        .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view3, null))        .setClickedView(mButton)        .show();\n向下偏移8dp\n123456new BubbleDialog(this)        .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view3, null))        .setClickedView(mButton4)        .setPosition(mPosition)        .setOffsetY(8)        .show();\n当想要输入框随软键盘上移时\n123456new BubbleDialog(this)        .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view, null))        .setClickedView(mButton12)        .setPosition(mPosition)        .softShowUp()        .show();\n自定义 BubbleLayout\n123456789101112BubbleLayout bl = new BubbleLayout(this);bl.setBubbleColor(Color.YELLOW);bl.setShadowColor(Color.RED);bl.setLookLength(Util.dpToPx(this, 18));bl.setLookWidth(Util.dpToPx(this, 24));bl.setBubbleRadius(Util.dpToPx(this, 3));new BubbleDialog(this)        .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view5, null))        .setClickedView(mButton8)        .setPosition(mPosition)        .setBubbleLayout(bl)        .show();\n自定义 BubbleDialog，可交互的 BubbleDialog\n\n1、布局\n\n12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"160dp\"    android:layout_height=\"match_parent\"    android:orientation=\"vertical\"&gt;    &lt;Button        android:id=\"@+id/button13\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:text=\"Button1\" /&gt;    &lt;Button        android:id=\"@+id/button14\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:text=\"Button2\" /&gt;    &lt;Button        android:id=\"@+id/button15\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:text=\"Button3\" /&gt;&lt;/LinearLayout&gt;\n\n2、自定义 BubbleDialog\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 自定义可操作性dialog * Created by JiajiXu on 17-12-11. */public class CustomOperateDialog extends BubbleDialog implements View.OnClickListener&#123;    private ViewHolder mViewHolder;    private OnClickCustomButtonListener mListener;    public CustomOperateDialog(Context context)    &#123;        super(context);        setTransParentBackground();        setPosition(Position.TOP);        View rootView = LayoutInflater.from(context).inflate(R.layout.dialog_view4, null);        mViewHolder = new ViewHolder(rootView);        addContentView(rootView);        mViewHolder.btn13.setOnClickListener(this);        mViewHolder.btn14.setOnClickListener(this);        mViewHolder.btn15.setOnClickListener(this);    &#125;    @Override    public void onClick(View v)    &#123;        if (mListener != null)        &#123;            mListener.onClick(((Button)v).getText().toString());        &#125;    &#125;    private static class ViewHolder    &#123;        Button btn13, btn14, btn15;        public ViewHolder(View rootView)        &#123;            btn13 = rootView.findViewById(R.id.button13);            btn14 = rootView.findViewById(R.id.button14);            btn15 = rootView.findViewById(R.id.button15);        &#125;    &#125;    public void setClickListener(OnClickCustomButtonListener l)    &#123;        this.mListener = l;    &#125;    public interface OnClickCustomButtonListener    &#123;        void onClick(String str);    &#125;&#125;\n\n3、显示\n\n123456789101112CustomOperateDialog codDialog = new CustomOperateDialog(this)        .setPosition(mPosition)        .setClickedView(mButton10);codDialog.setClickListener(new CustomOperateDialog.OnClickCustomButtonListener()&#123;    @Override    public void onClick(String str)    &#123;        mButton10.setText(\"点击了：\" + str);    &#125;&#125;);codDialog.show();\n查看关于BappyDialog的使用代码TestDialogActivity 代码\n写法建议根据@hm该朋友在文章中反馈的多次点击后位置不对的问题，是由于多次对BappyDialog进行了设置导致，所以建议下方写法。(当然如果对重复调用setClickedView()方法设置不同的被点击的控件来更新位置有需要，是需要写在外面的。)\n123456789if(mBubbleDialog == null)&#123;    mBubbleDialog = new BubbleDialog(this)        .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view3, null))        .setClickedView(mButton4)        .setPosition(mPosition)        .setOffsetY(8);&#125;mBubbleDialog.show();\n\n如何使用 HappyBubble-BubbleLayout？在XML代码中设置属性值\n属性参照表\n\n\n\n\n属性\n值\n描述\n\n\n\n\nlookAt\nleft, top, right, bottom\n箭头指向\n\n\nlookLength\ndimension\n箭头的长度\n\n\nlookPosition\ndimension\n箭头相对于x或y轴的位置\n\n\nlookWidth\ndimension\n箭头的宽度\n\n\nbubbleColor\ncolor\n气泡的颜色\n\n\nbubbleRadius\ndimension\n气泡四角的圆弧\n\n\nbubblePadding\ndimension\n气泡边缘到BubbleLayout边缘的距离\n\n\nshadowRadius\ndimension\n阴影的扩散大小\n\n\nshadowX\ndimension\n阴影在x轴方向的偏移\n\n\nshadowY\ndimension\n阴影在y轴方向的偏移\n\n\nshadowColor\ncolor\n阴影的颜色\n\n\n\n\nxml 例子\n\n12345678910&lt;com.xujiaji.happybubble.BubbleLayout    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    android:id=\"@+id/bubbleLayout\"    android:layout_width=\"match_parent\"    android:layout_height=\"200dp\"    android:layout_margin=\"16dp\"    app:lookAt=\"left\"    app:lookLength=\"16dp\"    app:lookPosition=\"20dp\"    app:lookWidth=\"16dp\" /&gt;\n在java代码中定义属性值\nBubbleLayout 通过“set属性名”方法和invalidate方法来更新BubbleLayout。\n\n1mBubbleLayout.setLook(BubbleLayout.Look.LEFT);\n\n查看更多\n\nMainActivity 代码\n\ndemo 下载\n\nLicense12345678910111213Copyright 2016 XuJiajiLicensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/happy-bubble/img5.png","plink":"https://blog.xujiaji.com/post/happy-bubble/"},{"title":"Android开发中的bug清单","date":"2017-12-12T07:34:41.000Z","author":"xujiaji","updated":"2019-04-08T06:54:57.703Z","content":"Android Gradle plugin 3.0.0-alpha5 must not be applied to project\n解决地址：https://stackoverflow.com/questions/44857191/failed-to-apply-plugin-android-gradle-plugin-3-0-0-alpha5-must-not-be-applied-to\n原因：\n解决办法：\n\n\n在gradle.properties：\n\n1org.gradle.configureondemand=false\n\n然后在终端窗口中停止守护进程\n\n1gradlew --stop\njava.lang.IllegalStateException: Fragment already added: DialogFragment\n解决地址：http://blog.csdn.net/kifile/article/details/47442899\n原因：点击过快DialogFragment消息队列还没有执行完\n解决办法：\n\n12345getFragmentManager().executePendingTransactions();if (!mDialogFragment.isAdded())&#123;    mDialogFragment.show(getFragmentManager(), \"DialogFragment\");&#125;\njava.lang.RuntimeException: Unable to get provider\n解决地址：https://stackoverflow.com/questions/37312103/unable-to-get-provider-com-google-firebase-provider-firebaseinitprovider\n原因：在SDK &lt;22的设备中遇到同样的问题，原因是MultiDex，MultiDex.install必须在attachBaseContext方法中\n解决方法自定义Application中添加如下：12345678public class YourApplication extends Application &#123;    @Override    protected void attachBaseContext(Context context) &#123;        super.attachBaseContext(context);        MultiDex.install(this);    &#125;&#125;\n\n\nbuild.gradle中添加如下：1compile &apos;com.android.support:multidex:1.0.1&apos;\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/android-bug-list.png","plink":"https://blog.xujiaji.com/post/android-bug-list/"},{"title":"linux(Ubuntu)笔记","date":"2017-12-12T04:25:29.000Z","author":"xujiaji","updated":"2019-04-08T06:56:30.022Z","content":"每次开机弹出软件崩溃反馈\n解决：删除崩溃日志\n\n1$ sudo rm /var/crash/*\n更新软件源的索引1$ sudo apt-get update\n升级软件1$ sudo apt-get upgrade\n修复依赖关系\n假如用户的系统上有某个package不满足依赖条件，这个命令就会自动修复，安装程序包所依赖的包\n\n1$ sudo apt-get -f install\n创建启动器\n安装软件\n\n1$ sudo apt install gnome-panel\n\n打开创建图标的界面，下边的~/桌面/为启动器创建的位置\n\n1gnome-desktop-item-edit ~/桌面/ --create-new\n\n最后根据提示创建图标\n\n安装xmind-linux\n下载地址：https://www.xmind.cn/download/\n\n下载下来是一个压缩包，将其放到~/目录并解压。由于我是64位系统，所以进入~/xmind/XMind_amd64/目录双击XMind运行软件。\n\n由于我创建启动器遇到下面的错误，必须在当前目录才能运行XMind，否则就有下面的错误提示对话框出现。\n\n1234The configuration area at '/./configuration'could not be created.Please choose a writable locationusing the '-configuration' command line option.\n\n解决：写一个命令脚步，先跳转到~/xmind/XMind_amd64/目录再执行XMind运行软件，脚步如下：\n\nstart.sh\n123#!/bin/bashcd ~/xmind/XMind_amd64./XMind\n\n下面是启动器xmind.desktop\n\n12345678910#!/usr/bin/env xdg-open[Desktop Entry]Version=1.0Type=ApplicationTerminal=falseIcon[zh_CN]=/home/soul/xmind/icon.pngName[zh_CN]=xmindExec=/home/soul/xmind/XMind_amd64/start.shName=xmindIcon=/home/soul/xmind/icon.png\n更新hosts文件后让文件生效12sudo apt-get install nscdsudo /etc/init.d/nscd restart\n使用Samba让Linux与Windows共享文件夹\n安装samba\n\n1$ sudo apt-get install samba\n\n创建共享目录\n\n12$ mkdir /home/soul/文档/ShareFiles$ sudo chmod /home/soul/文档/ShareFiles\n\n修改samba配置文件\n\n打开文件1$ sudo vim /etc/samba/smb.conf\n末尾添加如下内容1234567[share]     comment = my share directory     path = /home/soul/文档/ShareFiles   browseable = yes     writable = yes   public = yes   valid users = xujiaji\nxujiaji是我当前linux的用户名，相应换成你的\n\n设置登录密码\n\n12sudo touch /etc/samba/smbpasswdsudo smbpasswd -a xujiaji\nxujiaji换成上一步你设置的用户名\n\n启动samba服务器\n\n1$ sudo /etc/init.d/samba restart\n\nwindows中打开\n\n\n打开windows文件管理器，顶部输入\\\\linux ip\\share\n账号密码为linux账户的账户密码\n\n清理系统删除一些不必要的资源12$ sudo apt-get autoclean$ sudo apt-get autoremove\n删除旧内核\n查看当前使用的内核信息：uname -a\n\n12$ uname -aLinux boomake-pc 4.10.0-42-generic #46~16.04.1-Ubuntu SMP Mon Dec 4 15:57:59 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n\n查看已存在的内核：dpkg --get-selections| grep linux\n\n1234567891011121314151617181920212223242526$ dpkg --get-selections| grep linuxconsole-setup-linux\t\t\t\tinstalllibselinux1:amd64\t\t\t\tinstalllibselinux1:i386\t\t\t\tinstalllinux-base\t\t\t\t\tinstalllinux-firmware\t\t\t\t\tinstalllinux-generic-hwe-16.04\t\t\t\tinstalllinux-headers-4.10.0-40\t\t\t\tinstalllinux-headers-4.10.0-40-generic\t\t\tinstalllinux-headers-4.10.0-42\t\t\t\tinstalllinux-headers-4.10.0-42-generic\t\t\tinstalllinux-headers-generic-hwe-16.04\t\t\tinstalllinux-image-4.10.0-40-generic\t\t\tinstalllinux-image-4.10.0-42-generic\t\t\tinstalllinux-image-extra-4.10.0-40-generic\t\tinstalllinux-image-extra-4.10.0-42-generic\t\tinstalllinux-image-generic-hwe-16.04\t\t\tinstalllinux-libc-dev:amd64\t\t\t\tinstalllinux-libc-dev:i386\t\t\t\tinstalllinux-sound-base\t\t\t\tinstalllinuxbrew-wrapper\t\t\t\tinstallpptp-linux\t\t\t\t\tinstallsyslinux\t\t\t\t\tinstallsyslinux-common\t\t\t\t\tinstallsyslinux-legacy\t\t\t\t\tinstallutil-linux\t\t\t\t\tinstall\n\n删除：sudo apt-get purge\n\n\n更新一下启动引导：sudo update-grub或者sudo update-grub2\n\nappstreamcli错误\nsudo-apt get update时出现下面错误\n\n1234The AppStream system cache was updated, but some errors were detected, which might lead to missing metadata. Refer to the verbose log for more information.Reading package lists... DoneE: Problem executing scripts APT::Update::Post-Invoke-Success 'if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh-cache &gt; /dev/null; fi'E: Sub-process returned an error code\n\n解决\n\n123456$ sudo rm /usr/bin/appstreamclicd /tmp &amp;&amp; mkdir asfixcd asfixwget https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.debwget https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.debsudo dpkg -i *.deb\n安装截屏软件Shutter\n添加软件源\n\n1$ sudo add-apt-repository ppa:shutter/ppa\n\n更新源并安装\n\n12$ sudo apt-get update$ sudo apt-get install shutter\n\n设置快捷键\n\n系统设置 &gt; 键盘 &gt; 快捷键 &gt; 自定义快捷键 &gt; +\n\n\n\n自定义快捷键\n\n\n\n\n\n名称：\nShutter Select\n\n\n命令：\nshutter -s\n\n\n\n点击新添加条目的右侧新建快捷键，然后同时按住Ctrl+Alt+A，结束。\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/linux-notes.jpg","plink":"https://blog.xujiaji.com/post/linux-notes/"},{"title":"Git笔记","date":"2017-12-12T03:02:34.000Z","author":"xujiaji","updated":"2019-05-05T07:30:44.427Z","content":"记录在Git的使用过程中遇到的操作\n\nGit笔记初始化git仓库\n移动到需要初始化的目录\n1git init\n\n添加修改后的文件，或用“.”表示添加当前目录所有修改内容\n1git add &lt;文件&gt;\n\n提交修改了什么内容\n1git commit -m \"&lt;内容&gt;\"\n\n\n查看状态\n查看当前版本库的状态，如：修改了什么文件，是否有需要添加或者提交的文件\n1git status\n\n查看修改前后的不同之处（difference）\n1git diff\n\n查看工作区和版本库里HEAD指向的版本（最新版本）有什么区别\n1git diff HEAD -- &lt;文件&gt;\n\n\n版本回退\n查看commit提交的日志，每个commit都有一串哈希值表示id\n1git log\n\n用一行信息来展示一次提交的信息（简化上面的展示）\n1git log --pretty=oneline\n\nGit中，用HEAD表示当前版本，上个版本表示为HEAD^，上上版本就是HEAD^^…。也可直接指定，如往上100个版本：HEAD~100\n12git reset --hard HEAD^HEAD is now at ebeb505 add distributed\n\n如果窗口还没关闭，还可以后悔。7a19是commit id的SHA1值开头，他会自动根据开头这几个字符去找\n1git reset --hard 7a19\n\n如果窗口关闭，那么也能后悔。查看你的历史命令的记录\n1git reflog\n\n\n撤销修改\n如果还没有git add时想要撤销修改\n1git checkout -- &lt;文件&gt;\n\n如果git add了，想要撤销。先进行进行下面将文件从暂存区退回到工作区，然后在进行上面步骤。\n1git reset HEAD &lt;file&gt;\n\n\n删除文件\n当删除文件后，需要更新版本库时。最后还需要commit提交\n1git add/rm &lt;file&gt;\n\n\n远程仓库\n添加为本地仓库并联远程仓库\n1git remote add origin xxx.git\n\n删除已并联的远程库\n1git remote rm origin\n\n重新设置远程仓库\n1git remote set-url origin git@xxx.com/xxx/xxx.git\n\n本地仓库并联多个远程仓库\n123456789101112git remote rm origingit remote add github git@github.com:xxx/xxx.gitgit remote add gitee git@gitee.com:xxx/xxx.gitgit remote -v... gitee    git@gitee.com:xxx/xxx.git (fetch)... gitee    git@gitee.com:xxx/xxx.git (push)... github    git@github.com:xxx/xxx.git (fetch)... github    git@github.com:xxx/xxx.git (push)git push github mastergit push gitee master\n\n推送到远程仓库，第一次推送加上-u会把本地master分支和远程master分支并联起来，以后推送或拉取可简化命令\n1git push -u origin master\n\n查看远程仓库的名称，一般是origin，如果没有远程仓库则没有结果。\n1git remote\n\n查看更详细信息，如果没有推送权限则没有(push)标记的地址。\n1git remote -v\n\n\n设置用户信息  12git config --global user.name \"John Doe\"git config --global user.email johndoe@example.com\n\n如果使用了 –global ，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。\n\n分支\n查看本地分支\n1git branch\n\n查看远程分支\n1git branch -a\n\n创建分支1.1.2并切换到1.1.2分支\n1git checkout -b 1.1.2\n\n拆分写法\n12git branch 1.1.2git checkout 1.1.2\n\n删除本地分支\n1git branch -d 1.1.2\n\n把该分支上的所有本地提交推送到远程库（推送时，后面指定本地分支，这样git就会把该分支推送到远程库对应的远程分支上。）\n1git push origin master\n\n创建远程origin的dev分支到本地\n1git checkout -b dev origin/dev\n\n指定本地分支dev和远程origin/dev的链接\n1git branch --set-upstream-to=origin/dev dev\n\n推送本地分支到远程分支，远程分支不存在则创建\n1git push origin 1.1.2:1.1.2\n\n本地分支留空则是删除远程分支\n1git push origin :1.1.2\n\n合并work分支到当前分支\n1git merge work\n\n合并分支时，git可能会用Fast forward模式。但这个模式下删除分支后会丢失分支信息。如要禁用Fast forward模式可在merge时--no-ff生成一个新的commit\n1git merge --no-ff -m \"&lt;commit内容&gt;\" &lt;分支&gt;\n\n强制删除分支\n1git branch -D &lt;分支名&gt;\n\n\n标签\n创建标签，默认为HEAD，也可以指定一个commit id\n12git tag &lt;tagname&gt;git tag &lt;tagname&gt; &lt;commit id&gt;\n\n创建带有说明的标签\n1git tag -a &lt;tagname&gt; -m \"&lt;说明&gt;\" &lt;commit id&gt;\n\n查看所有标签\n1git tag\n\n查看标签信息\n1git show &lt;tagname&gt;\n\n删除标签\n1git tag -d &lt;tagname&gt;\n\n推送某个标签到远程\n1git push origin &lt;tagname&gt;\n\n一次性推送全部尚未推送到远程的本地分支\n1git push origin --tags\n\n删除远程标签时，先删除本地，然后push，格式如下：\n12git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt;\n\n\n解决冲突\n当git merge发生冲突的时候\n可先通过git status查看冲突的文件\nGit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容我们修改后保存。\n然后git add、git commit -m提交。\n查看分支合并图\n12git log --graphgit log --graph --pretty=oneline --abbrev-commit\n\n\nstash\n临时需要处理其他分支任务的时候，可以将当前分支没完成的工作储藏起来。\n1git stash\n\n查看当前分支储藏\n12$ git stash liststash@&#123;0&#125;: WIP on dev: 5e7a253 merge dev2 test\n\n恢复储藏\n\n1.用git stash apply恢复，恢复后，stash内容并不删除，需要用git stash drop删除。\n\n1234567git stash liststash@&#123;0&#125;: WIP on dev: 5e7a253 merge dev2 testgit stash apply stash@&#123;0&#125;git stash liststash@&#123;0&#125;: WIP on dev: 5e7a253 merge dev2 testgit stash drop stash@&#123;0&#125;Dropped stash@&#123;0&#125; (78fffa0577da9beb962a341cf13d74d9cfa148c6)\n\n2.用git stash pop恢复的同时删去stash\n\n1git stash pop\n\n\ngit pull和本地冲突\n冲突log\n\n123456789101112git pullremote: Counting objects: 24, done.remote: Compressing objects: 100% (17/17), done.remote: Total 24 (delta 7), reused 23 (delta 6), pack-reused 0Unpacking objects: 100% (24/24), done.From https://github.com/elmorec/hexo-theme-inside   a98e719..3b64c8a  master     -&gt; origin/mastererror: Your local changes to the following files would be overwritten by merge:        _config.ymlPlease commit your changes or stash them before you merge.AbortingUpdating a98e719..3b64c8a\n\n1、用 git stash本地暂时保存起来\n\n12git stashSaved working directory and index state WIP on master: a98e719 update scripts\n\n2、pull3、还原git stash pop stash@{0}\n\n1234git stash pop stash@&#123;0&#125;Auto-merging _config.ymlOn branch masterYour branch is up-to-date with 'origin/master'.\n克隆其他分支\n如下所示，只克隆source分支\n\n1git clone -b source git@github.com:xujiaji/xujiaji.github.io.git\n强制覆盖远程1git push -f\n忽略特殊文件.gitignore\n忽略python编译产生的.pyc、.pyo、dist等文件或目录\n1234567# Python:*.py[cod]*.so*.egg*.egg-infodistbuild\n\n\n配置别名\n–global是针对当前用户起作用，如果不加只对当前仓库起作用\n\n123git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\"git lg\n\n配置文件位置：当前项目.git/config\n\n当前用户的Git配置文件，在用户主目录的.gitconfig，配置别名可修改这个文件，也可删除用命令重新配置。\n\n\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/git-notes.png","plink":"https://blog.xujiaji.com/post/git-notes/"},{"title":"VIM爬坡到半山腰的总结","date":"2016-11-30T01:43:00.000Z","author":"xujiaji","updated":"2019-04-08T06:57:01.540Z","content":"\n简介将Linux Mint做为我的主系统后，来来回回到处撞墙。慢慢的到现在不仅习惯了Linux下的娱乐和开发，居然还渐渐的顺手顺眼起来，对于Linux生存有了保障的我现在对Linux下的VIM开始好奇了。\n虽听说VIM乃是上古神器，但一直以来对于VIM映像只有黑不溜秋的界面、白晃晃的文字，只知道从命令界面进去后可以点击i进入文本编辑模式、上下左右箭头移动光标、修改完成后Ese然后:wq保存退出、走人。总的来说不想撩你，怕惹祸上身，最终精尽人亡（精神的精）。\n这到现在都没面试，哎！手里闲不住，前几天开始对VIM开始下手了，胆颤心惊的先去网上秋秋别人的VIM长啥样啊！谷歌直接搜图片吧！（我已做好随时逝去）。这一看，瓦特？vim可以分屏？这个人的vim界面还有目录？这GIT分支结构侧边栏怎么都来了？为什么左侧还有代码行号？这些人的代码高亮的这么好看？最下面的那行漂亮的状态栏我咋过没有？我瞬间就被这些人的界面给吸引住了，我感觉我从农村第一次来到城市。\n就这样我走上了撩VIM之路（我有Java精神我不怕，万物皆对象），到现在我已经将上面看到的目录结构弄出来、代码行号、代码高亮主题更换、状态栏显示、VIM中使用GIT等加入到我的VIM之中。从中我了解到了VIM的插件放哪、怎么配置插件，学习了一波基本命令助我前行。我认为写代码最主要的就是要先有个安心、悦目的环境，然后是快捷的操作，这样写代码会感觉很舒服。当然，还有就是提升了一个格调，集齐技术、快捷、装逼、高效与一身。\n下图是我当前的VIM界面截图，是不是有鼻子有眼了。\n有想要到达的方向，一切的困难不过是个过程我从这里开始入门先为您献上链接：世界上最牛的编辑器： Vim 1 (原创动图演示所有例子!)世界上最牛的编辑器： Vim 2 (原创动图演示所有例子!)世界上最牛的编辑器： Vim 3 (原创动图演示所有例子!)\n当这三篇看完后，可以了解到VIM的基本操作，可以安装一些插件（其实我也只是用到了里面的几个插件，其他没用的先不管吧！）。虽然现在你是不明不白的安装了一些插件，但重在先体验体验VIM的感觉。\n这里我想要补充一下(因为我是用的Linux，其他系统原谅我没了解)：.vimrc就是vim的配置文件.vim/bundle目录下放的都是插件，可以直接将Github插件git clone（下载到）这个目录。\n.vim/bundle/vundle\n\n如果您下载了上面教程的.vim里面会有这个目录，这个插件可以在Github搜索然后更新一下。\n如果是Github上可下载的插件就不用亲自去克隆下来了，直接在.vimrc添加如：Plugin &#39;majutsushi/tagbar&#39;（Github地址是：htttps://github.com/majutsushi/tagbar），直接取后面一部分就行了。\n最后打开终端输入vim回车，进入Vim。然后，输入命令:PluginInstall就会将所有的第二步这种形式的插件自动下载下来。\n\n从这里开始明白了Vim插件管理，如何配置还是先敬上链接：不要在害怕Vim\n当然我的英语水平是个渣渣，越来越不得不多学学English了。看了了大概，总体上面是介绍，下面是实际的一些例子。有预览图，理解起来还是比较轻松。里面介绍了一个Vim游戏http://vim-adventures.com/ ，挺有意思了玩到三关之后要money，20多美元解锁，屌丝的我只能干望着了。\n这里简单说一下我装了的里面提及的几个：fugitive：可以在Vim中对项目进行Git命令操作。gundo：查看提交以树行结构展示（请看下图）nerdtree：展示目录结构，看起比使用:Ve展示的目录爽多了。（请看下图）powerline：底部状态栏，这个可是把我给折腾够了，不过弄完之后，瞬间展示效果杠杠的。\n\n还是简单记录一下我的历程吧！\n\n一开始我以为和其他插件一样，直接在.vimrc中添加Plugin &#39;Lokaltog/powerline&#39;然后在Vim中:PluginInstall，Very Good搞定。其实不然，根本就可以不需要往.vim/bundle中添加，需要配置python，需要在.vimrc中配置。\n通过这篇文章：为Bash和VIM配置一个美观奢华的状态提示栏我不仅仅将Vim给加上了状态栏，命令界面的用户状态也变了，我把默认的字体改成powerline的字体，更加美观。先欣赏一下：\n\n我的步骤：\n\n安装python-pip 与 git 套件\n1sudo apt-get install python-pip git\n\n使用pip安装Powerline\n1pip install --user powerline-status\n\n字体配置（如果没有这字体，那么Powerline的那些符号我的会显示乱码）\n123$ git clone https://github.com/powerline/fonts.git$ cd fonts$ ./install.sh\n\n配置环境，打开.bashrc，添加如下信息。\n12345678export TERM=&quot;screen-256color&quot;export PATH=&quot;$HOME/.local/bin:$PATH&quot;export POWERLINE_COMMAND=powerlineexport POWERLINE_CONFIG_COMMAND=powerline-configpowerline-daemon -qPOWERLINE_BASH_CONTINUATION=1POWERLINE_BASH_SELECT=1. ~/.local/lib/python2.7/site-packages/powerline/bindings/bash/powerline.sh\n\n\n第二行是加入powerline的命令位置，下图是查看位置。最下面的一行是安装powerline后的路径. ~/.local/lib/python2.7/site-packages/powerline可能大家会有所不同。（再执行第二步你会看到安装位置哦，如下图）\n\n选择字体，此时您应该已经可以在命令中中显示如上图的状态了，只是默字体可能无法显示其真正效果。Edit &gt; Preferences看下图：我直接搜索选择了powerline semi\n最终目的不要忘了，是配置Vim啊！此时只需要在.vimrc中添加如下信息即可：（第一行为powerline目录）\n12345678910set rtp+=~/.local/lib/python2.7/site-packages/powerline/bindings/vim/set guifont=Sauce\\ Code\\ Powerline:h14.5set laststatus=2set encoding=utf-8set t_Co=256set numberset fillchars+=stl:\\ ,stlnc:\\set term=xterm-256colorset termencoding=utf-8set background=dark\n\n重启Vim看看，是不是搞定了！\n\n\n\n最后献上一个我现在用的主题\n\ngruvbox\n配置.vimrc1234Plugin &apos;morhetz/gruvbox&apos;colorscheme gruvboxset background=lightset background=dark\n在Vim中下载1:PluginInstall\n\n好了就到这里，其他插件看个人需求添加，都是大同小异的了。\n\n总结结束在放几个网址在这里：Vim Cheat Sheet : 多种语音查看Vim命令vimcolors : 很多的Vim配色AndroidStudio——-IdeaVim插件\n\n从现在开启Vim神器功能，进入无尽的砍怪之旅吧！\n\n\nGithub：@xujiaji\n\n本文是我开始VIM爬到半山坡后的总结！什么半山坡啊！装B，其实就是刚刚个入了门，哈哈。如有欠妥之处还望给予指正，如有什么Vim淫巧还望推荐，谢谢！\n\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/vim-1/home.png","plink":"https://blog.xujiaji.com/post/vim-note1/"},{"title":"面向对象设计-依赖倒置原则（DIP）","date":"2016-05-29T04:08:00.000Z","author":"xujiaji","updated":"2019-04-08T06:56:34.482Z","content":"简介\n\n引入：高层的决定不能因为某一个低层次模块的变动而影响全局，导致整个系统的变动。\n\n什么是DIP？\n全称：依赖倒置原则（Dependency inversion principle）\n定义：\n高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口\n抽象接口不应该依赖于具体实现，而具体实现则因该依赖于抽象接口。\n\n\n\n我们如何理解DIP？\n知道依赖倒置的由来\n由于过去传统软件开发方法倾向于高层依赖于低层\n如今依赖倒置通过接口隔离，高层和底层都依赖于接口后\n结论：从结构上相对于传统编程方式而言就是倒置了。\n\n\n依赖倒置反面教材\n\n结构如下：没有遵循依赖倒置\n\n\n\n代码如下：\n\n1234567891011121314151617181920212223/** * 高层 */class GaoCeng &#123;    ZhongCeng mZhongCeng;    public GaoCeng(ZhongCeng mZhongCeng) &#123;        this.mZhongCeng = mZhongCeng;    &#125;&#125;/** * 中层 */class ZhongCeng&#123;    DiCeng mDiCeng;    public ZhongCeng(DiCeng mDiCeng)&#123;        this.mDiCeng = mDiCeng;    &#125;&#125;/** * 底层 */class DiCeng&#123;&#125;\n\n依赖倒置正面教材\n\n结构如下：\n\n\n\n代码如下：\n\n123456789101112131415161718192021222324252627282930313233/** * 中层接口 */interface ZhongCengInterface&#123;   &#125;/** * 高层接口 */interface GaoCengInterface&#123;   &#125;/** * 高层 */class GaoCeng &#123;    GaoCengInterface mGaoCengInterface;    public GaoCeng(GaoCengInterface mGaoCengInterface) &#123;        this.mGaoCengInterface = mGaoCengInterface;    &#125;&#125;/** * 中层 */class ZhongCeng implements GaoCengInterface&#123;    ZhongCengInterface mZhongCengInterface;    public ZhongCeng(ZhongCengInterface mZhongCengInterface)&#123;        this.mZhongCengInterface = mZhongCengInterface;    &#125;&#125;/** * 底层 */class DiCeng implements ZhongCengInterface&#123;&#125;\n\n结论\n\n可以从结构图上明确看出两种方式依赖结构是相反的，所以叫依赖倒置\n通过这种结构我们可以肆意的更改具体的接口实现类，而不会影响高层\n\n\n\n遵循DIP有什么好处？既然我们理解了DIP，那么DIP的好处不言而喻。\n\n通过依赖于接口，隔离了具体实现类\n低一层的变动并不会导致高一层的变动\n提高了代码的容错性、扩展性和易于维护\n\n既然有好处，那么就必定有坏处：代码的增加，学习成本和代码思考时间的增加。（不过相对于后期的好处，这点我们还是能理解的）\n例子其实理解DIP的例子就是一个很好的对比例子。现在来一个实际一点的例子：超重提价\n\n需求：编写一个称重提价装置，物体2元/斤（物体重量 &lt;= 100）计算。当物体超过100kg提醒，然后超出部分以10元/斤（物体重量 &gt; 100）计算。\n\n\n以传统方式编程\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 称重器传统编程 */class Scales&#123;    private double readValue;//获取到的物体的重量    private double highestValue;    private double inPrice;    private double outPrice;    public Scales(double highestValue, double inPrice, double outPrice) &#123;        this.highestValue = highestValue;        this.inPrice = inPrice;        this.outPrice = outPrice;    &#125;    /**     * 当有物体放上去后称重     */    public void startScales() &#123;        //...readValue = ？ （这里获取称重器计算的重量）        showWeigh(readValue);        double price = 0;        double diff = readValue - highestValue;        if (diff &gt; 0) &#123;            outWeighWarn(diff);            price += highestValue * inPrice;            price += diff * outPrice;        &#125; else &#123;            price += readValue * inPrice;        &#125;        showPrice(price);    &#125;    /**     * 显示重量     */    private void showWeigh(double weigh) &#123;    &#125;    /**     * 超重提醒     */    private void outWeighWarn(double outWeigh) &#123;&#125;    /**     * 显示价格     */    private void showPrice(double price) &#123;    &#125;&#125;\n\n依赖倒置后\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** 称重接口*/interface Weigh &#123;    double read();&#125;/** 最大重量、范围内价格、范围外价格的设置*/interface Value&#123;    double highestValue();    double inPrice();    double outPrice();&#125;/** 显示器接口*/interface Show &#123;    void outWeighWarn(double diff);    void showWeigh(double weigh);    void showPrice(double price);&#125;class Scales&#123;    private Weigh mWeigh;    private Show mShow;    private Value mValue;    public Scales(Weigh mWeigh, Show mShow, Value mValue) &#123;        this.mShow = mShow;        this.mWeigh = mWeigh;        this.mValue = mValue;    &#125;    /**     * 当有物体放上去后称重     */    public void startScales() &#123;        mShow.showWeigh(mWeigh.read());        double price = 0;        double diff = mWeigh.read() - mValue.highestValue();        if (diff &gt; 0) &#123;            mShow.outWeighWarn(diff);            price += mValue.highestValue() * mValue.inPrice();            price += diff * mValue.outPrice();        &#125; else &#123;            price += mWeigh.read() * mValue.inPrice();        &#125;        mShow.showPrice(price);    &#125;&#125;\n我们可以看出依赖倒置后使代码可复用，可以是任意的称重装置，可以是任意的显示装置，只要它们实现对应的接口即可。高层不必在意底层具体是什么东西。\n总结\nDIP的规则：依赖于抽象，不应该依赖于具体类。\n任何变量都不应该持有一个指向具体类的指正或这引用\n任何类都不应该从具体类派生\n任何方法都不应该覆写它的任何基类中已经实现了的方法\n\n每个程序都会有违反这些规则的情况，有时必须创建具体类的实例。此外，这些规则对于那些具体但却稳定的类来说似乎不太合理。如果一个具体类不太会改变，并且也不会创建其他类似的派生类，那么依赖于它并不会造成损害，比如说String类型。\n\n然而，我们编写的大多数具体类都是不稳定的，我们将它们隐藏在抽象接口后面，隔离它们的不稳定性。\n\n由于抽象将高层和细节彼此隔离，所以代码也非常容易维护\n\n\n参考文献敏捷软件开发 第12章 依赖倒置原则（DIP）\n","plink":"https://blog.xujiaji.com/post/ood-dip/"},{"title":"面向对象设计-接口隔离(ISP)","date":"2016-05-07T02:12:00.000Z","author":"xujiaji","updated":"2019-04-08T06:56:38.340Z","content":"引入：\n\n老手机： 你们这些年轻手机光溜溜的，全身上下只有两个插孔几个按钮，为啥这么受欢迎？新手机：老前辈，您虽然占了一半都是按钮，可以快速的点到，但是多数情况下都没用呀！我虽然只有几个按钮，但都是经常用到滴。我也能达到和你一样的效果，而且更简洁。老手机：恩，人们只有打字的时候才用到那些按钮。新手机：所以在平常时候，我这几个按钮就可以满足大部分需要了。老手机：真是一代比一代强咯！\n\n\n\nISP\n\n\n1.何为ISP？\n全称：接口隔离原则（Interface Segregation Principle）\n定义：客户程序不应该被迫依赖于它们不使用的方法\n\n2.如何理解ISP？\n比如图2-1.违反了ISP中的鸵鸟类不应该被迫依赖于不使用的飞翔方法\n\n\n现在将2-1.满足ISP的例子中的接口鸟进行拆分，能飞的鸟类麻雀实现接口飞鸟，不能飞的鸟类鸵鸟实现接口鸟，如下图2-2所示。\n\n\n\n可能到这里大家有个疑惑：接口变多了！对！就是接口变多了。不是上面还举例了手机的例子吗？阐明了减少接口的好处。\n其实我们减少并不是接口，而是接口中的抽象方法。\n通过分离来满足客户端的需求，使客户端程序中只存在需要的方法。\n客户端的不同需求才是导致接口改变的原因。\n\n\n\n3.遵循ISP有什么好处？\n不遵循ISP而导致的一些问题，在图2-1中，鸵鸟是不需要飞的，但保留了飞的方法。\n\n现在接口中的飞()方法需要进行改动，假如改成：boolean fly()—可以理解为调用一次向上飞，再调用一次向下飞，依次循环。\n现在不仅会飞的鸟需要改动，连鸵鸟这些不会飞的鸟都要莫名奇妙的跟着去改动。\n显然这导致了程序之间的耦合增强，影响到了不应该影响的客户程序\n\n\n现在正过来看遵循ISP接口，如图2-2所示的例子，分离了方法飞，使得更改时并不会影响到不相干的客户程序（鸵鸟类）\n\n需要尽可能避免这种耦合，因此我们希望分离接口。\n可以看出，分离接口有利于我们对需求变更时的快速高效的执行行动。\n并且使之解构层次更加的分明\n\n\n\n4.循序渐进的例子（来自敏捷软件开发[^foot1]）\n以ATM用户界面为例\n\n\nATM的用户界面有不同的交易模式，现将从ATM的基类Transaction（交易类）中派生子类：\n\nDepositTransaction存款\nWithdrawalTransaction取款\nTransferTransaction转账\n\n\n每一个子类交易都有一个界面，因此要依赖于UI，调用的不同方法，如：DepositTransaction会调用UI类中的RequestDepositAmount()方法，当前ATM结果如下图4-2-1.ATM操作解构所示。\n\n这样做是ISP告诉我们应当避免的情形\n每个操作使用的UI方法，其他的操作都不会使用\n当每次Transaction子类的改动都会迫使对UI进行改动，从而影响到了其他所有Transaction子类及其他所有依赖于UI接口的类。\n当要增加一个支付煤气费的交易时，为了处理该操作想要显示的特定消息，就需要在UI中加入新的方法。糟糕的是，由于Transaction的子类全部依赖于UI接口，所以它们都需要重新编译。\n\n\n因此现在有一个办法，将UI接口分解成像DepositUI、WithdrawalUI以及TransferUI这样的单独接口，可以避免这种不合适的耦合，最终的UI接口可以去多重继承这些单独的接口。图5-3-1.分离的ATM接口和之后的代码展示了这个模型。\n\n定义交易接口\n\n12345678910111213141516171819/** 存款UI接口*/interface DepositUI &#123;    void RequestDepositAmount();&#125;/** 取款UI接口*/interface WithdrawalUI &#123;    void RequestWithdrawalAmount();&#125;/** 转账UI接口*/interface TransferUI &#123;    void RequestTransferAmount();&#125;/** UI接口继承所有的交易接口*/interface UI extends DepositUI, WithdrawalUI, TransferUI&#123;&#125;\n\n交易抽象类\n\n1234/** 交易类*/abstract class Transaction &#123;    public abstract void Execute();&#125;\n\n交易派生类\n\n123456789101112131415161718192021222324252627282930313233343536373839404142/** 存款交易类*/class DepositTransaction extends Transaction &#123;    private DepositUI mDepositUI;    public DepositTransaction(DepositUI mDepositUI) &#123;        this.mDepositUI = mDepositUI;    &#125;    @Override    public void Execute() &#123;        //...        mDepositUI.RequestDepositAmount();        //...    &#125;&#125;/** 取款交易类*/class WithdrawalTransaction extends Transaction &#123;    private WithdrawalUI mWithdrawalUI;    public WithdrawalTransaction(WithdrawalUI mWithdrawalUI) &#123;        this.mWithdrawalUI = mWithdrawalUI;    &#125;    @Override    public void Execute() &#123;        //...        mWithdrawalUI.RequestWithdrawalAmount();        //...    &#125;&#125;/** 转账交易类*/class TransferTransaction extends Transaction &#123;    private TransferUI mTransferUI;    public TransferTransaction(TransferUI mTransferUI) &#123;        this.mTransferUI = mTransferUI;    &#125;    @Override    public void Execute() &#123;        //...        mTransferUI.RequestTransferAmount();        //...    &#125;&#125;\n\n创建交易对象：由于每个操作都必须以特定的方式知晓UI版本，如TransferTransaction必须知道TransferUI。在程序中，使每个操作的构造时给它传入指向特定于它的UI的引用，从而解决这个问题。如下进行初始化\n\n1234UI GUI;void fun() &#123;    DepositTransaction mDepositTransaction = new DepositTransaction(GUI);&#125;\n\n虽然这样很方便，但同样要求每个操作都有一个指向对应UI的引用成员。另外一种解决这个问题的方法是创建一组全局常量。全局变量并不总是意味着拙劣的设计，在这种情况下，它们有着明显的易于访问的有点。\n\n1234567891011/** UI全局变量*/class UIGlobals &#123;    public static DepositUI mDepositUI;    public static WithdrawalUI mWithdrawalUI;    public static TransferUI mTransferUI;    public UIGlobals(UI lui) &#123;        UIGlobals.mDepositUI = lui;        UIGlobals.mWithdrawalUI = lui;        UIGlobals.mTransferUI = lui;    &#125;&#125;\n123456789/** 转账交易类*/class TransferTransaction extends Transaction &#123;    @Override    public void Execute() &#123;        //...        UIGlobals.mTransferUI.RequestTransferAmount();        //...    &#125;&#125;\n1234567891011121314151617181920/** * UI的实现类 */class UIEntity implements UI &#123;    @Override    public void RequestDepositAmount() &#123;        //...    &#125;    @Override    public void RequestTransferAmount() &#123;        //...    &#125;    @Override    public void RequestWithdrawalAmount() &#123;        //...    &#125;&#125;\n12345678910111213/** * 使用 */class A &#123;    //初始化UI静态类    UIGlobals mUIGlobals = new UIGlobals(new UIEntity());    //调用姿势    void fun() &#123;        Transaction mTransaction = new TransferTransaction();        mTransaction.Execute();    &#125;&#125;\n\n由于敏捷软件开发举的例子是c++的，知识有限，表示很多看不懂，可能有些地方偏差较大，想了解更多建议亲自去看看( ¯▽¯；)\n\n\n5.总结\n胖类（fat class）：就是上边讲解的不满足ISP的类型\n\n可以看出胖类增强了类之间的耦合，使得对该胖类进行改动会影响到所有其他类。\n\n通过将胖类接口分解成多个特定类（客户端程序）的接口，使得强耦合得以解决\n\n然后该胖类继承所有特定类的接口，并实现它们。就解除了这个特定类和它没有调用方法间的依赖关系，并使得这些特定类之间互不依赖。\n\n\n6.参考文献\n敏捷软件开发  第12章   接口隔离原则（ISP）\n如何向妻子解释OOD\n\n","plink":"https://blog.xujiaji.com/post/ood-isp/"},{"title":"面向对象设计-里氏替换原则(LSP)","date":"2016-04-23T03:02:00.000Z","author":"xujiaji","updated":"2019-04-08T06:56:42.415Z","content":"引：\n\n有一只小麻雀在大平原上，飞呀飞～。飞累了，看见前方一个大鸟…小麻雀：大鸟兄你好，本鸟叫麻雀！请问您怎么称呼？大鸵鸟：原来是麻雀小弟呀！本鸟叫鸵鸟！小麻雀：鸵鸟哥耶！小弟飞的累的不行！让兄弟在您雄伟的身躯上歇歇脚么？大鸵鸟：不行！本鸟还走累了呢！那我咋办？小麻雀：你飞呗！难道我还拖着你不成？大鸵鸟：前提是我要是能飞的起来呀！小麻雀：开什么玩笑！咱们都是鸟，你飞不起来？“飞”是咋们鸟类的特征，想到飞就想到咋们鸟～。\n\n\n\nLSP\n\n\n1. 何为LSP？\n全称：里氏替换原则（Liskov Substitution principle）\n定义：派生类（子类）对象能够替换其基类（超类）对象被使用[^foot1]\nBarbara Liskov对LSP定义是这么说的：若对每个类型S的对象q1，都存在一个类型T的对象q2，使得在所有对T编写的程序P中，用q1替换q2后，程序P行为功能不变，则S是T的子类型。听着有些绕，我将它画一个类图便于理解：\nLSP定义理解dsf在类P中将T的对象q2，换成S的对象q1行为功能不变则S继承T，得如图所示的关系\n\n\n\n\n\n\n2. 何为L？何为S？L:芭芭拉·利斯科夫（Barbara Liskov）因为提出这个原则的女士姓里S:替换（Substitution）父类能被子类替换\n\n替换如上述定义所述，子类替换父类后不会影响其行为和功能。\n\n3. 为何要有LSP？\n①首先谈谈要是违反LSP\n\n\n来张违反LSP的类图\n\n\n\n分析\n\n现在我说天上飞着一只鸟。。。\n子类麻雀替换父类：天上飞着一只麻雀。\n子类鸵鸟替换父类：天上飞着一只鸵鸟。\n\n\n由上因为违反了里氏替代原则，导致整个设计存在严重逻辑错误。\n\n由于违反了里氏替代原则，间接的违反了OCP原则[^foot2]。因为明显可以看出飞翔对于鸵鸟因该是封闭的。\n\n\n②再来看一些代码（LSP的违反导致OCP的违反）\n\n\n代码如下\n\n有三个类：鸟、鸵鸟、麻雀。鸵鸟和麻雀都有要去北京的方法\n1234567891011121314151617181920212223242526272829303132333435/** * 鸟 */class Bird&#123;    public static final int IS_OSTRICH = 1;//是鸵鸟    public static final int IS_SPARROW = 2;//是麻雀    public int isType;    public Bird(int isType) &#123;        this.isType = isType;    &#125;&#125;/** * 鸵鸟 */class Ostrich extends Bird&#123;    public Ostrich() &#123;        super(Bird.IS_OSTRICH);    &#125;    public void toBeiJing()&#123;        System.out.print(\"跑着去北京！\");    &#125;&#125;/** * 麻雀 */class Sparrow extends Bird&#123;    public Sparrow() &#123;        super(Bird.IS_SPARROW);    &#125;    public void toBeiJing()&#123;        System.out.print(\"飞着去北京！\");    &#125;&#125;\n现在有一个方法birdLetGo，统一处理去北京的行为\n123456789public void birdLetGo(Bird bird) &#123;    if (bird.isType == Bird.IS_OSTRICH) &#123;        Ostrich ostrich = (Ostrich) bird;        ostrich.toBeiJing();    &#125; else if (bird.isType == Bird.IS_SPARROW) &#123;        Sparrow sparrow = (Sparrow) bird;        sparrow.toBeiJing();    &#125;&#125;\n\n分析大家可以看出，birdLetGo方法明显的违反了开闭原则[^foot2]，它必须要知道所有Bird的子类。并且每次创建一个Bird子类就得修改它一次。\n\n\n③结论\n\n由上面的分析可以大致的了解了遵守LSP的重要性了吧！\n\n如果不遵守，导致逻辑设计缺陷\n如果不遵守，导致同时违反开闭原则\n单个模型，孤立时并不具有设计意义。当多个模型出现时，抽象提取共同特征作为父类（基类），使之任何子类能替代于父类\n如果试图预测所有假设，我们所得到的结果可能会充满很多不必要的复杂性。通常最好的办法是只预测那些最明显的LSP的违反状态，直到设计开始出现脆弱的状态，才去处理它们。[^foot3]\n\n4. 基于契约设计能支持LSP？\n什么是契约设计？\n通过为每个方法声明的前置条件和后置条件[^foot4]来指定的。要是使一个方法得以执行，前置条件必须要为真。执行完毕后，该方法要保证后置条件为真。\n\n\n一个例子\n\n\n几个继承关系的类\n\n1234567891011121314151617181920212223242526272829303132//动物public class Animal &#123;    private String food;    public Animal(String food) &#123;        this.food = food;    &#125;    public String getFood() &#123;        return food;    &#125;&#125;//鸟class Bird extends Animal&#123;    public Bird(String food) &#123;        super(food);    &#125;&#125;//鸵鸟class Ostrich extends Bird&#123;    public Ostrich() &#123;        super(\"草\");    &#125;&#125;//麻雀class Sparrow extends Bird&#123;    public Sparrow() &#123;        super(\"虫子\");    &#125;&#125;\n\n在动物园对象中调用吃的方法\n\n12345678class Zoo &#123;    /**     * 吃早餐     */    public String eatBreakfast(Animal animal) &#123;        return animal.getFood();    &#125;&#125;\n\n分析\n\n\n这里的满足前置条件就是调用方需满足能接受String这个食物类型\n满足后置条件可以看做是参数和返回类型\n前置条件不能更强，只能更弱，比如可以这样调用：\n\n1Object food = new Zoo().eatBreakfast(new Animal(\"肉\"));\n\n后置条件可以更强，比如可以这样写：\n\n1String food = new Zoo().eatBreakfast(new Ostrich());\n\n这样我们就可以说是前置条件和后置条件就都得以满足\n\n5. 结论总结\n如果LSP有效运用，程序会具有更多的可维护性、可重用性和健壮性\n\nLSP是使OCP成为可能的主要原则之一\n\n正是因为子类的可替换性，才使得父类模块无须修改的情况就得以扩展\n\n\n6. 参考文章\n里氏替换原则-维基百科\nOCP\n敏捷软件开发  第10章  里氏替换原则(LSP)\n前置条件和后置条件是什么？\n\n","plink":"https://blog.xujiaji.com/post/ood-lsp/"},{"title":"Android-UI事件传递就是这么个事儿","date":"2016-04-16T07:31:00.000Z","author":"xujiaji","updated":"2019-04-08T06:55:13.177Z","content":"\n我们寻找的，也只不过是内心世界的片刻安宁，以及，那样一场盛大的清欢。\n\n聊聊UI事件传递\n什么是UI事件？\n触摸屏幕中UI控件的那一刻即为事件发生\nMotionEvent对象包含了所有的触摸事件，如触摸的位置、多指触摸等\nMotionEvent描述了当前的操作类型，以下为常见类型(数字代表对应的值)：\nACTION_DOWN = 0 按下\nACTION_UP = 1 抬起\nACTION_MOVE = 2 移动\nACTION_CANCEL = 3 动作取消\nACTION_OUTSIDE = 4  动作超出边界\nACTION_POINTER_DOWN = 5 已有一个点被按住，此时再按下一个点\nACTION_POINTER_UP = 6 多个点被按住，非最后放开的点都会调用\n\n\n\n事件如何传递？\n自定义的父布局和子布局，用来观察事件的变化(View1和Button1为自定义View和自定义Button，默认以自定义View1举例\n\n\n上图简略关系如下：\n× 之前一直以为事件是从子布局开始传递到父布，因为以直观的角度我们先碰到的是子布局得到错误的事件顺序：view1 --&gt; ViewGroup2 --&gt; ViewGroup1\n√ 后来才知道事件是从父布局传递到子布局，是由父布局判断点击位置上面有子布局然后向子布局传递。如果事件向子布局传递没有被拦截和消费，那么事件又会向父布局传递。正确的没有被拦截和消费的事件顺序：Activity --&gt; ViewGroup1 --&gt; ViewGroup2 --&gt; View1 --&gt; ViewGroup2 --&gt; ViewGroup1 --&gt; Activity\n以下的Log为当手指对view1点击、滑动、抬起时，\n发生的一系列事件传递（0.按下；1.抬起； 2.移动）：\n-1234567891011121314151617181920E/MainActivity: ----------- dispatchTouchEvent = 0E/ViewGroup1: ------------- dispatchTouchEvent = 0E/ViewGroup1: ------------- onInterceptTouchEvent = 0E/ViewGroup2: ------------- dispatchTouchEvent = 0E/ViewGroup2: ------------- onInterceptTouchEvent = 0E/View1: ------------------ dispatchTouchEvent = 0E/View1: ------------------ onTouchEvent = 0E/ViewGroup2: ------------- onTouchEvent = 0E/ViewGroup1: ------------- onTouchEvent = 0E/MainActivity: ----------- onTouchEvent = 0E/MainActivity: ----------- dispatchTouchEvent = 2E/MainActivity: ----------- onTouchEvent = 2E/MainActivity: ----------- dispatchTouchEvent = 2E/MainActivity: ----------- onTouchEvent = 2E/MainActivity: ----------- dispatchTouchEvent = 2E/MainActivity: ----------- onTouchEvent = 2E/MainActivity: ----------- dispatchTouchEvent = 1E/MainActivity: ----------- onTouchEvent = 1E/MainActivity: ----------- dispatchTouchEvent = 1E/MainActivity: ----------- onTouchEvent = 1\n\n\n\n观察\n\n\n\n\n可以看出事件由外层大布局到内部子布局传进去，在从子布局传出去（Activity --&gt; ViewGroup1 --&gt; ViewGroup2 --&gt; View1 --&gt; ViewGroup2 --&gt; ViewGroup1 --&gt; Activity）\n\n\n由此log还可以看出：当按下的事件没有被拦截，那么所有状态的事件都由Activity进行处理\n\n\n\n\n没有拦截事件时\n\n\n如何拦截？\n通过dispatchTouchEvent对事件进行拦截，当返回值为true的时候拦截事件\n拦截后事件将不会传到子布局\n现在以ViewGroup1为例：\n让ViewGroup1中的dispatchTouchEvent直接返回true\n当手指对View1点击、移动、抬起时\n发生的一系列事件传递（0.按下；1.抬起； 2.移动）\n   12345678910E/MainActivity: ----------------  dispatchTouchEvent = 0E/ViewGroup1: ------------------  dispatchTouchEvent = 0E/MainActivity: ----------------  dispatchTouchEvent = 2E/ViewGroup1: ------------------  dispatchTouchEvent = 2E/MainActivity: ----------------  dispatchTouchEvent = 2E/ViewGroup1: ------------------  dispatchTouchEvent = 2E/MainActivity: ----------------  dispatchTouchEvent = 2E/ViewGroup1: ------------------  dispatchTouchEvent = 2E/MainActivity: ----------------  dispatchTouchEvent = 1E/ViewGroup1: ------------------  dispatchTouchEvent = 1\n\n\n\n\n\n观察\n\n\n\n\n可以看出事件传递到ViewGroup1后被拦截，没有被任何布局消费\n\n\n也就是说事件还没被消费就被拦截会导致触摸无效\n\n\n我们可以在dispatchTouchEvent判断哪些情况需要拦截，哪些不需要拦截就放事件过去（以上直接返回了true拦截了所有情况的事件）\n\n\n\n\n拦截ViewGroup1的所有事件\n\n\n如何获取？\n通过onInterceptTouchEvent获取事件，当返回值为true的时候获取事件\n获取事件后会调用onTouchEvent方法，调用这个方法后，如果我们设置了OnTouchListener，那么触摸监听将会被调用。现在以ViewGroup2为例：\n让ViewGroup2中的onInterceptTouchEvent直接返回true\n当手指对View1点击、移动、抬起时\n发生的一系列事件传递（0.按下；1.抬起； 2.移动）\n\n\n-12345678910111213141516E/MainActivity: ----------------  dispatchTouchEvent = 0E/ViewGroup1: ------------------  dispatchTouchEvent = 0E/ViewGroup1: ------------------  onInterceptTouchEvent = 0E/ViewGroup2: ------------------  dispatchTouchEvent = 0E/ViewGroup2: ------------------  onInterceptTouchEvent = 0E/ViewGroup2: ------------------  onTouchEvent = 0E/ViewGroup1: ------------------  onTouchEvent = 0E/MainActivity: ----------------  onTouchEvent = 0E/MainActivity: ----------------  dispatchTouchEvent = 2E/MainActivity: ----------------  onTouchEvent = 2E/MainActivity: ----------------  dispatchTouchEvent = 2E/MainActivity: ----------------  onTouchEvent = 2E/MainActivity: ----------------  dispatchTouchEvent = 2E/MainActivity: ----------------  onTouchEvent = 2E/MainActivity: ----------------  dispatchTouchEvent = 1E/MainActivity: ----------------  onTouchEvent = 1\n\n\n\n观察问题\n原因\n解决\n\n\n\n\n哎呀呀~！为啥我获取到了的事件之后，移动和抬起手指的事件被MainActivity吃了！愤怒！！\n原来onTouchEvent如果处理按下事件DOWN的时候没有返回true。如果onTouchEvent处理DOWN时候返回false，则表示没有消费事件，事件将会回到父布局，并且后续事件将不会再传递过来。\nonTouchEvent方法中判断为按下DOWN事件的时候，返回true即下面要说的消费\n\n\n\n\n当ViewGroup2事件获取到了，但没有消费\n\n\n如何消费？\n上边已经提到过，就是获取事件遗留下来一个问题：获取到了按下事件，为啥没继续获取到后续的事件？就是因为按下时onTouchEvent没有返回true，导致事件从新回到父布局，也就是没有消费事件。\n现在接着以ViewGroup2为例：\n还是让ViewGroup2中的onInterceptTouchEvent直接返回true\n添加：在onTouchEvent方法中添加判断if (event.getAction() == MotionEvent.ACTION_DOWN) {return true;}\n当手指对View1点击、移动、抬起时\n发生的一系列事件传递（0.按下；1.抬起； 2.移动）\n  123456789101112131415161718192021222324E/MainActivity: ----------------  dispatchTouchEvent = 0E/ViewGroup1: ------------------  dispatchTouchEvent = 0E/ViewGroup1: ------------------  onInterceptTouchEvent = 0E/ViewGroup2: ------------------  dispatchTouchEvent = 0E/ViewGroup2: ------------------  onInterceptTouchEvent = 0E/ViewGroup2: ------------------  onTouchEvent = 0E/MainActivity: ----------------  dispatchTouchEvent = 2E/ViewGroup1: ------------------  dispatchTouchEvent = 2E/ViewGroup1: ------------------  onInterceptTouchEvent = 2E/ViewGroup2: ------------------  dispatchTouchEvent = 2E/ViewGroup2: ------------------  onTouchEvent = 2E/MainActivity: ----------------  onTouchEvent = 2E/MainActivity: ----------------  dispatchTouchEvent = 2E/ViewGroup1: ------------------  dispatchTouchEvent = 2E/ViewGroup1: ------------------  onInterceptTouchEvent = 2E/ViewGroup2: ------------------  dispatchTouchEvent = 2E/ViewGroup2: ------------------  onTouchEvent = 2E/MainActivity: ----------------  onTouchEvent = 2E/MainActivity: ----------------  dispatchTouchEvent = 1E/ViewGroup1: ------------------  dispatchTouchEvent = 1E/ViewGroup1: ------------------  onInterceptTouchEvent = 1E/ViewGroup2: ------------------  dispatchTouchEvent = 1E/ViewGroup2: ------------------  onTouchEvent = 1E/MainActivity: ----------------  onTouchEvent = 1\n\n\n\n\n\n观察\n\n\n\n\n由上边log可以看出，现在在ViewGroup2中的onTouchEvent的按下事件返回一个true后，按下事件并没有在传递回父布局中，使得后续事件都将能得到\n\n\n可以看出当后续事件传递过来时，ViewGroup2已经没有再次调用onInterceptTouchEvent方法\n\n\n我们只是将按下DOWN的事件返回true，所以除了按下事件其他移动或抬起的事件activity都也能获取到。当onTouchEvent不管三七二十一直接返回一个true时，activity就不会获取到事件\n\n\n\n\n当消费ViewGroup2的按下DOWN事件时\n\n\n\n当ViewGroup2中onTouchEvent直接返回true时\n\n\nButton获取事件是怎么回事？\n现在将View1换成Button1，其他的恢复最初状态，先来看看触摸的log\n12345678910111213141516171819202122232425262728E/MainActivity: -------------  dispatchTouchEvent = 0E/ViewGroup1: ---------------  dispatchTouchEvent = 0E/ViewGroup1: ---------------  onInterceptTouchEvent = 0E/ViewGroup2: ---------------  dispatchTouchEvent = 0E/ViewGroup2: ---------------  onInterceptTouchEvent = 0E/Button1: ------------------  dispatchTouchEvent = 0E/Button1: ------------------  onTouchEvent = 0E/MainActivity: -------------  dispatchTouchEvent = 2E/ViewGroup1: ---------------  dispatchTouchEvent = 2E/ViewGroup1: ---------------  onInterceptTouchEvent = 2E/ViewGroup2: ---------------  dispatchTouchEvent = 2E/ViewGroup2: ---------------  onInterceptTouchEvent = 2E/Button1: ------------------  dispatchTouchEvent = 2E/Button1: ------------------  onTouchEvent = 2E/MainActivity: -------------  dispatchTouchEvent = 2E/ViewGroup1: ---------------  dispatchTouchEvent = 2E/ViewGroup1: ---------------  onInterceptTouchEvent = 2E/ViewGroup2: ---------------  dispatchTouchEvent = 2E/ViewGroup2: ---------------  onInterceptTouchEvent = 2E/Button1: ------------------  dispatchTouchEvent = 2E/Button1: ------------------  onTouchEvent = 2E/MainActivity: -------------  dispatchTouchEvent = 1E/ViewGroup1: ---------------  dispatchTouchEvent = 1E/ViewGroup1: ---------------  onInterceptTouchEvent = 1E/ViewGroup2: ---------------  dispatchTouchEvent = 1E/ViewGroup2: ---------------  onInterceptTouchEvent = 1E/Button1: ------------------  dispatchTouchEvent = 1E/Button1: ------------------  onTouchEvent = 1\n\n在来看看序列图\n\n\n\nButton获取触摸事件\n\n\n\n这一看，这不是和上面那张图当ViewGroup2中onTouchEvent直接返回true时的效果一样的吗？也就是说button默认就是直接获取了事件，没有让事件返回主布局中。\n\n等等还有一个！！！大家都知道布局有个属性clickable吧！当设置它的值为true时，使得这个布局事件如button所述！\n\n更深入的理解的话这里博客已经介绍的很详细了\n\nAndroid事件分发机制完全解析，带你从源码的角度彻底理解(上)\nAndroid事件分发机制完全解析，带你从源码的角度彻底理解(下)\n\n\n\n实际的应用-来一个简单的应用\nxml布局1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:orientation=\"vertical\"    android:padding=\"10dp\"&gt;    &lt;CheckBox        android:id=\"@+id/checkbox_lock\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:text=\"Lock Selection\" /&gt;    &lt;RadioGroup        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:orientation=\"horizontal\"&gt;        &lt;RadioButton            android:id=\"@+id/selection_first\"            android:layout_width=\"0dp\"            android:layout_height=\"wrap_content\"            android:layout_weight=\"1\"            android:text=\"First\"/&gt;        &lt;RadioButton            android:id=\"@+id/selection_second\"            android:layout_width=\"0dp\"            android:layout_height=\"wrap_content\"            android:layout_weight=\"1\"            android:text=\"Second\"/&gt;        &lt;RadioButton            android:id=\"@+id/selection_third\"            android:layout_width=\"0dp\"            android:layout_height=\"wrap_content\"            android:layout_weight=\"1\"            android:text=\"Third\"/&gt;    &lt;/RadioGroup&gt;&lt;/LinearLayout&gt;\nactivity代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.examples.customtouch;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.widget.CheckBox;/** * Created by Dave Smith * Double Encore, Inc. * Date: 9/25/12 * TouchListenerActivity */public class TouchListenerActivity extends Activity implements View.OnTouchListener &#123;    /* Views to display last seen touch event */    CheckBox mLockBox;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.touch_listener);        mLockBox = (CheckBox) findViewById(R.id.checkbox_lock);        findViewById(R.id.selection_first).setOnTouchListener(this);        findViewById(R.id.selection_second).setOnTouchListener(this);        findViewById(R.id.selection_third).setOnTouchListener(this);    &#125;    @Override    public boolean onTouch(View v, MotionEvent event) &#123;        /*         * Consume the events here so the buttons cannot process them         * if the CheckBox in the UI is checked         */        Log.e(\"TouchListenerActivity\", getNameForEvent(event));        return mLockBox.isChecked();    &#125;    @Override    public boolean onTouchEvent(MotionEvent event) &#123;        Log.e(\"onTouchEvent\", getNameForEvent(event));        return super.onTouchEvent(event);    &#125;    private String getNameForEvent(MotionEvent event) &#123;        String action = \"\";        switch (event.getAction()) &#123;            case MotionEvent.ACTION_DOWN:                action = \"ACTION_DOWN\";                break;            case MotionEvent.ACTION_CANCEL:                action = \"ACTION_CANCEL\";                break;            case MotionEvent.ACTION_MOVE:                action = \"ACTION_MOVE\";                break;            case MotionEvent.ACTION_UP:                action = \"ACTION_UP\";                break;            default:                return null;        &#125;        return String.format(\"%s\\n%.1f, %.1f\", action, event.getX(), event.getY());    &#125;&#125;\n\n\n\n\n状态\n描述\n\n\n\n\n当Lock Selection没有勾选时\n下边的单选能正常选择\n\n\n当Lock Selection勾选时\n下边的单选无法点击\n\n\n\n\n大家是否疑惑了，为什么复选框选中状态，ontouch返回了true反而不能点击了。为什么不是返回false无法点击，返回true时才能点击呢？其实这些控件默认可以点击的都是默认获取事件的，如上面说的button为什么获取事件一样，所以返回true和false和预想的结果相反。\n\n所用知识和资料\nAndroid studio插件plantUml画序列图和类图\nPlantUML快速指南 和 PlantUML官网\nAndroid事件分发机制完全解析，带你从源码的角度彻底理解(上)Android事件分发机制完全解析，带你从源码的角度彻底理解(下)\n公共技术点之 View 事件传递\n最后的那个例子来自于这儿\n\n","plink":"https://blog.xujiaji.com/post/android-ui-event/"},{"title":"面向对象设计-开闭原则(OCP)","date":"2016-04-12T00:43:00.000Z","author":"xujiaji","updated":"2019-04-08T06:56:47.148Z","content":"\nOCP\n\n\n啥是OCP？\n全称：开闭原则(Open-Closed Principle)[^foot2]\n定义：软件实体（类、模块、函数等等）应该是可以扩展的\n\n开(O)什么？关(C)什么？\n开(O)：对于扩展是开放的\n\n对于某个模块的功能是可以进行扩展的。当需求改变，我们只需对其进行扩展即可满足于新的需求。\n比如说：“砖”，我们不需要改变它的形态与结构，就可以根据需求来建高楼、建围墙、建厕所、建这样建那样(๑乛乛๑)。 - - 所以可以认为“砖”对于扩展的需求是开放的。又比如说电脑主板对于cpu、内存等是可扩展的。\n\n关(C)：对于更改是封闭的\n\n对模块进行扩展时，不必改动模块的源代码或者二进制代码。如果说这个模块已经明确的定义、稳定、有效的被多个其他模块使用，那么关闭这个模块，提供接口供其它模块使用。\n比如我们的电脑由“CPU”、“主板”、“内存”等构成，它们并不是紧紧耦合做成一块的。想想，要是紧紧的长一块，什么CUP、什么内存密密麻麻的小线、触角、身体的一部分和主板一体化。那么现在我的一个内存坏了，我表示我是渣渣得重新买一台电脑了，能内存修好的高手因该不多吧！就算内存能修好CPU又多少人能修好啊！但还好它们都是分离的，接口都是规定好了的，我需要买一个内存插上就好了。我们不需要知道知道内存里面、CPU里面是啥构造。要是坏了时，要是升级时，只需要更换这个模块而不需要更换整个硬件系统或修理这个硬件系统里的某个小模块。- - 原谅我废话了一大圈，就是想表达个封闭内部，能减少bug，方便扩展，能更好的分工合作（做主板的就做主板）\n为何要提倡OCP？其实在上面大家因该已经明白一些了，“开放”是为了更好的扩展，适应更多的相应需求。“关闭”是为了降低耦合，降低了维护难度和制作成本。两者可以说本是互为一体，而又被分开说成两样。因为关闭时得留出口开放本就是处理的一个模块同时进行。\n\n在许多方面，OCP的面向对象的核心所在注意：\n\n我们因该对频繁出现的变化进行封闭开放处理也就是进行抽象\n拒绝不成熟的抽象和抽象本身一样重要\n\n\n比如说？(实际例子)\n违反OCP,既不开放又不封闭\n上图展示了一个没有遵循OCP的设计例子，电灯类和电源类是两个具体的类。要让电灯发光，需要电源这个属性。如果此时要将电灯接在另一个电源上面，就必须更换成另一个电源的属性（将电灯连线与另一个电源）。\n\n遵循OCP,既开放又封闭\n上图展示了一个解决上面问题的OCP设计，灯座是一个拥有抽象成员的接口（比如说与电源的连线）。电灯类使用这个抽象类（有插座的成员属性），而电灯的对象使用的是灯座接口的实现类电源。如果我们需要将电灯接到另一个电源，只需要接到另一插座。如果要更换电源，那么将插座接到另一个电源。这样双方的改变，被插座接口隔离而不会影响到具体的类。（我理解为隔离了变化的扩散）\n\n\n\n\n\n注意\n\n\n\n\n只有当我们预测到这种变化，那么就可以设计一个抽象来进行隔离\n\n\n无论模块是多么的封闭都会存在一些无法对之封闭的变化（比如说我现在要让灯泡闪红光），没有对所有的情况都贴切的模型\n\n\n设计人员必须对设计的模块应该对哪种变化封闭做出选择\n\n\n\nEND\n总的来说开闭原则也如锦上添花，在原有锦织物上增添鲜花，让美的东西更美。\n\n在许多方面，OCP都是面向对象的核心所在。遵循这个原则可给面向对象技术带来巨大的好处（灵活性、可重用性以及可维护性）。然而，并不是说只要使用一种面向对象语言就是遵循了这个原则。\n\n对于应用程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确地做法是开发人员应当仅仅对程序中频繁变化的那些部分做出抽象，拒绝不成熟的抽象和抽象本身一样重要。\n参考文章\n《敏捷软件开发：原则、模式与实践》第9章  开放-封闭原则\n维基百科-开闭原则\n《面向对象软件构造》第二版 中英对照 第3章 3.3五项原则\n\n","plink":"https://blog.xujiaji.com/post/ood-ocp/"},{"title":"面向对象设计-单一职责原则(SRP)","date":"2016-04-07T15:55:00.000Z","author":"xujiaji","updated":"2019-04-08T06:56:50.532Z","content":"\nSRP\n\n\n何为SRP？\n全称：单一职责原则(Single Responsibility Principle)\n定义:该原则规定每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来\n\n何为职责(R)?\n既然是单一“职责”，那么职责即为被规定的因素。\n\n\n概括：”功能(职责)”为改变的原因，一个类或者模块应该有且只有一个改变的原因。\n\n如下图农活责任所示，耕菜地和耕水田即为牛和耕地机的职责，即为这个对象存在的原因（下面将来讨论这个关系图）。\n\n\n\n农活责任\n\n\n为何要提倡SRP？\n其思想简单，但却难以掌握。就是一个模块，一个类只能干一件事情。\n\n看上图农活责任，晃眼一看我们会决定这是对的！但仔细一分析农活接口其中包含的耕菜地和耕水田两个责任。\n\n牛耕水田，但它耕不动菜地，只能调用耕水田的接口，因此耕菜地的接口对于牛来说就是多余的。但耕地机即能耕菜地，也能耕水田。这就像是牛本来是耕田的，我们却说它还能去耕菜地，耕地机能做的事情，老牛表示无能为力！\n\n这样违反了SRP，导致了严重的问题。因为我们给牛保留了一个多余而不会完成的责任，这让我们每次提到牛不仅说它能耕水田还能耕菜地。这让我们对牛的描述更加的复杂而没有准确性。程序也时这样，当没用的责任增加，就会让相应的类都变得臃肿腐臭。当我们要添加牛要耕后要吃草，耕地机耕地后要加油时，继续往农活接口中添加，这样使得农活什么都能干，使得后期修改维护等难度太大。\n\n如果不分离责任，在不断变化和添加的需求面前，责任之间耦合度强导致我们的程序更加的脆弱。比如说？（实际举例说明）\n例子一\n农活责任(改)\n\n\n\n\n如上图将两个责任分离，牛实现耕水田的时候，不会知道也不会去在意耕菜地，分离了责任，该做的才做，不做的不用管。\n\n例子二（来自敏捷软件开发第8章）[^foot]1234567//调制解调器interface Modem &#123;    void dial(String pno);//拨号    void hangup();//挂断    void send(char c);//发送消息    void recv();//接收消息&#125;\n\n\n\n这个接口中显示了两个职责，一个是连接管理，一个是数据通信。dial和hangup函数进行调制解调器的连接处理，而send和recv函数进行数据的通信。\n\n这两个责任应该被分开吗？这决定于应用程序以何种方式变化。如果应用程序的变化会影响连接函数的部署，那么这个设计就具有僵化性的臭味。因为调用send和recv的类必须要重新编译连接处理函数，部署的次数常常会超过我们希望的次数。在这种情况下，这两个职责应该被分离。如图下图所示，这样避免了客户应用程序和这两个职责耦合在一起。\n\n分离的Modem接口\n\n\n\n\n\n注意\n\n\n\n\n另一方面，如果应用程序的变化方式总是会导致两个职责同时变化，那么就不必分离他们，分离后会导致不必要的复杂性。\n\n\n此外还有个推论：变化的曲线是仅当变化实际发生时才具有真正的意义。如果没有征兆，那么去应用SRP，或者其他原则都是不明智的。\n\n\n\n结论总结\nSRP为最简单的原则，也是最难运用好的原则\n软件设计真正要做的其实就是发现责任并把那些责任分离\n其他原则都将能追溯到SRP\n大道至简，只有不断在代码中运用才能真正体会其中的奥妙\n\n参考文章[1]《敏捷软件开发：原则、模式与实践》第8章 单一职责原则[2]维基百科[3]我是怎样向妻子解释OOD的\n","plink":"https://blog.xujiaji.com/post/ood-srp/"},{"title":"Ubuntu安装Android studio","date":"2016-03-26T23:13:00.000Z","author":"xujiaji","updated":"2019-04-08T06:55:34.245Z","content":"1.安装jdk①由于linux自带openjdk因此我就将openjdk卸载了装jdk1.71$ sudo apt-get remove openjdk-*\n②下载jdk1.7jdk1.7下载链接我下载的文件为：jdk-7u79-linux-x64.tar.gz\n③解压\n创建/usr/java目录\n1$ sudo mkdir /usr/java\n\n将当前目录下的jdk压缩包移/usr/java\n1~/下载 $ sudo mv jdk-7u79-linux-x64.tar.gz /usr/java\n\n解压到/usr/java，删除压缩包\n123$ cd /usr/java$ sudo tar -zxvf /usr/java/jdk-7u79-linux-x64.tar.gz$ sudo rm jdk-7u79-linux-x64.tar.gz\n\n\n④配置jdk环境变量\n打开环境变量配置文件profile\n1$ sudo gedit /etc/profile\n\n在文本最后添加如下信息，注意改成自己的jdk版本\n1234JAVA_HOME=/usr/java/jdk1.7.0_79PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH\n\n保存、重启、java -version验证是否配置成功\n\n\n2.安装android studio①下载linux android studio官网下载\n②解压将下载好的android studio压缩包移动到/usr/local目录，然后unzip命令解压1unzip android-studio-ide-141.2456560-linux.zip\n③运行进入android-studio/bin,然后运行studio.sh12$ cd android-studio/bin$ sh studio.sh\n④因为在linux mint第一天已经修改hosts翻墙，所以就自动下载sdk和更新，节省操作咯！3.安装Genymotion\nGenymotion被称为是速度最快的Android模拟器可不是盖的，手机也没有两，就打算安装一个模拟器。\n\nGenymotion官网genymotion-2.11.0-linux_x64下载genymotion-2.6.0下载\n安装步骤\n需要安装一个软件virtualbox才能使用Gecymotion,命令:sudo apt-get install virtualbox\n运行genymotion文件\n12$ chmod +x genymotion-2.11.0-linux_x64.bin$ ./genymotion-2.11.0-linux_x64.bin\n\n完成后进入该用户目录下的genymotion目录，双击运行genymotion。好了，接下来就可以下载genymotion虚拟机来体验快感了。\n\n\n","thumbnail":"https://xujiaji.oss-cn-beijing.aliyuncs.com/blog/android-studio.jpg","plink":"https://blog.xujiaji.com/post/install-android-studio-linux/"},{"title":"关于我","date":"2019-04-08T10:17:16.112Z","updated":"2019-04-08T10:17:16.112Z","content":"\n大家好！我是一枚喜欢编程，喜欢分享和记录的小小小开发者！\n联系我QQ：26323405（请大侠注明一下来路😄）Email：jiajixu@qq.com\n","plink":"https://blog.xujiaji.com/about/"},{"title":"珍藏链接","date":"2018-03-16T15:20:10.000Z","updated":"2019-04-08T10:18:20.316Z","content":"友情链接\n\n\n\nhexo inside主题\n玩Android\n\n\n\n\n\n\n\nAndroid开源项目\n\n\n名称\n分类\n链接\n作用\n\n\n\n\nHappyBubble\nUI Library\n\n随意变化的气泡布局，Dialog根据点击View的位置定位它的位置，Dialog可定制方向等！\n\n\nXMVP\nLibrary\nXMVP\n一个简洁的，只需要简单配置即可构架MVP模式的MVP框架\n\n\nMVPManager\n插件\n\n可配合上面的XMVP，快速生成相关代码并配置的AS插件\n\n\n\n工具\n\n\n名称\n链接\n作用\n\n\n\n\ncubic bezier\n\n贝塞尔曲线动画，可通过该工具调节出合适的数值\n\n\n缓动函数\n\n也是贝塞尔曲线，这里提供很多预定的动画缓冲效果，还有css代码\n\n\n创客贴\n\n制作一些博客封面，各种封面很方便\n\n\nezGIF\n\n视频转Gif，Gif大小优化、剪切、尺寸改变等\n\n\nWORD ART\n\n一句文字+一个图形=该文字组成的图形\n\n\nSilk\n\n生成图片，通过自己绘制一些绚丽的图案，像左边这种图形\n\n\nPixel Calculator\n\ndp、sp、px、mm、pt、in单位互转\n\n\nProcessOn\n\n在线画流程图、思维导图、UI原型图、UML等等\n\n\n站长工具\n\n在线网站检测，URL编码解码，UTF-8编码解码，Ascii编码解码等等\n\n\n\n","plink":"https://blog.xujiaji.com/links/"}]