{"title":"面向对象设计-开闭原则(OCP)","slug":"ood-ocp","url":"http://yoursite.com/ood-ocp","author":"xujiaji","date":"2016-04-12T00:43:00.000Z","updated":"2017-12-17T03:31:10.428Z","comments":true,"excerpt":"","content":"<p><img src=\"image/ood/ocp-home.jpg\" alt=\"楼层建的更高！走的更远！\"></p>\n<blockquote>\n<p>OCP</p>\n</blockquote>\n<p><img src=\"image/ood/ocp.png\" alt=\"OCP.png\"></p>\n<h2 id=\"啥是OCP？\"><a href=\"#啥是OCP？\" class=\"headerlink\" title=\"啥是OCP？\"></a>啥是OCP？</h2><ul>\n<li>全称：开闭原则(Open-Closed Principle)[^foot2]</li>\n<li>定义：软件实体（类、模块、函数等等）应该是可以扩展的</li>\n</ul>\n<h2 id=\"开-O-什么？关-C-什么？\"><a href=\"#开-O-什么？关-C-什么？\" class=\"headerlink\" title=\"开(O)什么？关(C)什么？\"></a>开(O)什么？关(C)什么？</h2><blockquote>\n<p>开(O)：对于扩展是开放的</p>\n</blockquote>\n<p>对于某个模块的功能是可以进行扩展的。当需求改变，我们只需对其进行扩展即可满足于新的需求。</p>\n<p>比如说：“砖”，我们不需要改变它的形态与结构，就可以根据需求来建高楼、建围墙、建厕所、建这样建那样(๑乛乛๑)。 - - 所以可以认为“砖”对于扩展的需求是开放的。又比如说电脑主板对于cpu、内存等是可扩展的。</p>\n<blockquote>\n<p>关(C)：对于更改是封闭的</p>\n</blockquote>\n<p>对模块进行扩展时，不必改动模块的源代码或者二进制代码。如果说这个模块已经明确的定义、稳定、有效的被多个其他模块使用，那么关闭这个模块，提供接口供其它模块使用。</p>\n<p>比如我们的电脑由“CPU”、“主板”、“内存”等构成，它们并不是紧紧耦合做成一块的。想想，要是紧紧的长一块，什么CUP、什么内存密密麻麻的小线、触角、身体的一部分和主板一体化。那么现在我的一个内存坏了，我表示我是渣渣得重新买一台电脑了，能内存修好的高手因该不多吧！就算内存能修好CPU又多少人能修好啊！但还好它们都是分离的，接口都是规定好了的，我需要买一个内存插上就好了。我们不需要知道知道内存里面、CPU里面是啥构造。要是坏了时，要是升级时，只需要更换这个模块而不需要更换整个硬件系统或修理这个硬件系统里的某个小模块。- - 原谅我废话了一大圈，就是想表达个封闭内部，能减少bug，方便扩展，能更好的分工合作（做主板的就做主板）</p>\n<h2 id=\"为何要提倡OCP？\"><a href=\"#为何要提倡OCP？\" class=\"headerlink\" title=\"为何要提倡OCP？\"></a>为何要提倡OCP？</h2><p>其实在上面大家因该已经明白一些了，“开放”是为了更好的扩展，适应更多的相应需求。“关闭”是为了降低耦合，降低了维护难度和制作成本。两者可以说本是互为一体，而又被分开说成两样。因为关闭时得留出口开放本就是处理的一个模块同时进行。</p>\n<blockquote>\n<p>在许多方面，OCP的面向对象的核心所在<br>注意：</p>\n<ul>\n<li>我们因该对频繁出现的变化进行封闭开放处理也就是进行抽象</li>\n<li>拒绝不成熟的抽象和抽象本身一样重要</li>\n</ul>\n</blockquote>\n<h2 id=\"比如说？-实际例子\"><a href=\"#比如说？-实际例子\" class=\"headerlink\" title=\"比如说？(实际例子)\"></a>比如说？(实际例子)</h2><ul>\n<li><p>违反OCP,既不开放又不封闭<br><img src=\"image/ood/ocp-no.png\" alt=\"既不开放又不封闭.png\"></p>\n<p>上图展示了一个没有遵循OCP的设计例子，电灯类和电源类是两个具体的类。要让电灯发光，需要电源这个属性。如果此时要将电灯接在另一个电源上面，就必须更换成另一个电源的属性（将电灯连线与另一个电源）。</p>\n</li>\n<li><p>遵循OCP,既开放又封闭<br><img src=\"image/ood/ocp-yes.png\" alt=\"既开放又封闭.png\"></p>\n<p>上图展示了一个解决上面问题的OCP设计，灯座是一个拥有抽象成员的接口（比如说与电源的连线）。电灯类使用这个抽象类（有插座的成员属性），而电灯的对象使用的是灯座接口的实现类电源。如果我们需要将电灯接到另一个电源，只需要接到另一插座。如果要更换电源，那么将插座接到另一个电源。这样双方的改变，被插座接口隔离而不会影响到具体的类。（我理解为隔离了变化的扩散）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>注意</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>只有当我们预测到这种变化，那么就可以设计一个抽象来进行隔离</td>\n</tr>\n<tr>\n<td>无论模块是多么的封闭都会存在一些无法对之封闭的变化（比如说我现在要让灯泡闪红光），没有对所有的情况都贴切的模型</td>\n</tr>\n<tr>\n<td>设计人员必须对设计的模块应该对哪种变化封闭做出选择</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"END\"><a href=\"#END\" class=\"headerlink\" title=\"END\"></a>END</h2><ul>\n<li><p>总的来说开闭原则也如锦上添花，在原有锦织物上增添鲜花，让美的东西更美。</p>\n</li>\n<li><p>在许多方面，OCP都是面向对象的核心所在。遵循这个原则可给面向对象技术带来巨大的好处（灵活性、可重用性以及可维护性）。然而，并不是说只要使用一种面向对象语言就是遵循了这个原则。</p>\n</li>\n<li><p>对于应用程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确地做法是开发人员应当仅仅对程序中频繁变化的那些部分做出抽象，拒绝不成熟的抽象和抽象本身一样重要。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2></li>\n<li>《敏捷软件开发：原则、模式与实践》第9章  开放-封闭原则</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener\">维基百科-开闭原则</a></li>\n<li>《面向对象软件构造》第二版 中英对照 第3章 3.3五项原则</li>\n</ul>\n","thumbnail":"image/ood/ocp-home.jpg","tags":["Java","面向对象设计"],"prev":{"title":"面向对象设计-里氏替换原则(LSP)","slug":"ood-lsp"},"next":{"title":"面向对象设计-单一职责原则(SRP)","slug":"ood-srp"}}