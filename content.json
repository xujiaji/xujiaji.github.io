{"meta":{"title":"徐佳吉的博客","subtitle":null,"description":null,"author":"xujiaji","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"HappyBubble-气泡对话框（根据被点击View位置显示、可定制）","slug":"happy-bubble","date":"2017-12-16T06:08:50.000Z","updated":"2017-12-16T07:39:44.992Z","comments":true,"path":"2017/12/16/happy-bubble/","link":"","permalink":"http://yoursite.com/2017/12/16/happy-bubble/","excerpt":"","text":"Github 气泡布局的形状可以改变，如四角弧度、气泡颜色、箭头大小和阴影。 气泡Dialog可以根据被点击的view的位置来确定自己展示的位置。 如何开始?在你模块中的build.gradle添加上HappyBubble依赖1compile &apos;com.github.xujiaji:happy-bubble:1.0.1&apos; 如何使用 HappyBubble-BubbleDialog? 方法参考表 方法名 参数 描述 addContentView View 添加填充在气泡中的视图 setClickedView View 被点击的View（触发Dialog出现的View） setPosition enum BubbleDialog.Position:LEFT, TOP, RIGHT, BOTTOM BubbleDialog相对于被点击的view的位置 calBar boolean 是否计算状态栏的高度（如果布局没有全屏，则需要计算） setOffsetX int 如果您对dialog所展示的x轴位置不满，需要调整x轴方向偏移 setOffsetY int 如果您对dialog所展示的y轴位置不满，需要调整y轴方向偏移 setBubbleLayout BubbleLayout 自定义dialog的气泡布局 setTransParentBackground - 背景透明 softShowUp - 当气泡dialog中有EditText时，软键盘弹出会遮挡EditText时，dialog随软键盘上移。 show - 显示 最简单的实现 需要提供：Context、填充的View、被点击的View。如果最外层布局没有全屏时，您需要计算状态栏的高度，否则会多向下偏移一个状态栏的高度。 12345new BubbleDialog(this) .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view3, null)) .setClickedView(mButton) .calBar(true) .show(); 向下偏移8dp1234567new BubbleDialog(this) .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view3, null)) .setClickedView(mButton4) .setPosition(mPosition) .setOffsetY(8) .calBar(true) .show(); 当想要输入框随软键盘上移时1234567new BubbleDialog(this) .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view, null)) .setClickedView(mButton12) .setPosition(mPosition) .calBar(true) .softShowUp() .show(); 自定义 BubbleLayout. 123456789101112BubbleLayout bl = new BubbleLayout(this);bl.setBubbleColor(Color.BLUE);bl.setShadowColor(Color.RED);bl.setLookLength(Util.dpToPx(this, 54));bl.setLookWidth(Util.dpToPx(this, 48));new BubbleDialog(this) .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view5, null)) .setClickedView(mButton8) .setPosition(mPosition) .calBar(true) .setBubbleLayout(bl) .show(); 自定义 BubbleDialog，可交互的 BubbleDialog. 1、布局 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"160dp\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;Button android:id=\"@+id/button13\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button1\" /&gt; &lt;Button android:id=\"@+id/button14\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button2\" /&gt; &lt;Button android:id=\"@+id/button15\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button3\" /&gt;&lt;/LinearLayout&gt; 2、自定义 BubbleDialog 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 自定义可操作性dialog * Created by JiajiXu on 17-12-11. */public class CustomOperateDialog extends BubbleDialog implements View.OnClickListener&#123; private ViewHolder mViewHolder; private OnClickCustomButtonListener mListener; public CustomOperateDialog(Context context) &#123; super(context); calBar(true); setTransParentBackground(); setPosition(Position.TOP); View rootView = LayoutInflater.from(context).inflate(R.layout.dialog_view4, null); mViewHolder = new ViewHolder(rootView); addContentView(rootView); mViewHolder.btn13.setOnClickListener(this); mViewHolder.btn14.setOnClickListener(this); mViewHolder.btn15.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (mListener != null) &#123; mListener.onClick(((Button)v).getText().toString()); &#125; &#125; private static class ViewHolder &#123; Button btn13, btn14, btn15; public ViewHolder(View rootView) &#123; btn13 = rootView.findViewById(R.id.button13); btn14 = rootView.findViewById(R.id.button14); btn15 = rootView.findViewById(R.id.button15); &#125; &#125; public void setClickListener(OnClickCustomButtonListener l) &#123; this.mListener = l; &#125; public interface OnClickCustomButtonListener &#123; void onClick(String str); &#125;&#125; 3、显示 123456789101112CustomOperateDialog codDialog = new CustomOperateDialog(this) .setPosition(mPosition) .setClickedView(mButton10);codDialog.setClickListener(new CustomOperateDialog.OnClickCustomButtonListener()&#123; @Override public void onClick(String str) &#123; mButton10.setText(\"点击了：\" + str); &#125;&#125;);codDialog.show(); 查看关于BappyDialog的使用代码TestDialogActivity 代码 如何使用 HappyBubble-BubbleLayout?在XML代码中设置属性值 属性参照表 属性 值 描述 lookAt left, top, right, bottom 箭头指向 lookLength dimension 箭头的长度 lookPosition dimension 箭头相对于x或y轴的位置 lookWidth dimension 箭头的宽度 bubbleColor color 气泡的颜色 bubbleRadius dimension 气泡四角的圆弧 bubblePadding dimension 气泡边缘到内容的距离 shadowRadius dimension 阴影的扩散大小 shadowX dimension 阴影在x轴方向的偏移 shadowY dimension 阴影在y轴方向的偏移 shadowColor color 阴影的颜色 xml 例子 12345678910&lt;com.xujiaji.happybubble.BubbleLayout xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/bubbleLayout\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:layout_margin=\"16dp\" app:lookAt=\"left\" app:lookLength=\"16dp\" app:lookPosition=\"20dp\" app:lookWidth=\"16dp\" /&gt; 在java代码中定义属性值。 BubbleLayout 通过“set属性名”方法和invalidate方法来更新BubbleLayout。 1mBubbleLayout.setLook(BubbleLayout.Look.LEFT); 查看更多 MainActivity 代码 demo 下载 License12345678910111213Copyright 2016 XuJiajiLicensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.","raw":null,"content":null,"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"}]},{"title":"Android开发中的bug清单","slug":"android-bug-list","date":"2017-12-12T07:34:41.000Z","updated":"2017-12-12T09:26:17.482Z","comments":true,"path":"2017/12/12/android-bug-list/","link":"","permalink":"http://yoursite.com/2017/12/12/android-bug-list/","excerpt":"","text":"java.lang.RuntimeException: Unable to get provider 解决地址：https://stackoverflow.com/questions/37312103/unable-to-get-provider-com-google-firebase-provider-firebaseinitprovider 原因：在SDK &lt;22的设备中遇到同样的问题，原因是MultiDex，MultiDex.install必须在attachBaseContext方法中 解决方法自定义Application中添加如下：12345678public class YourApplication extends Application &#123; @Override protected void attachBaseContext(Context context) &#123; super.attachBaseContext(context); MultiDex.install(this); &#125;&#125; build.gradle中添加如下：1compile &apos;com.android.support:multidex:1.0.1&apos;","raw":null,"content":null,"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"}]},{"title":"linux笔记","slug":"linux-notes","date":"2017-12-12T04:25:29.000Z","updated":"2017-12-20T14:02:54.647Z","comments":true,"path":"2017/12/12/linux-notes/","link":"","permalink":"http://yoursite.com/2017/12/12/linux-notes/","excerpt":"","text":"每次开机弹出软件崩溃反馈 解决：删除崩溃日志 1$ sudo rm /var/crash/* 更新软件源的索引1$ sudo apt-get update 升级软件1$ sudo apt-get upgrade 修复依赖关系 假如用户的系统上有某个package不满足依赖条件，这个命令就会自动修复，安装程序包所依赖的包 1$ sudo apt-get -f install","raw":null,"content":null,"categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Git笔记","slug":"git-notes","date":"2017-12-12T03:02:34.000Z","updated":"2017-12-17T05:50:29.504Z","comments":true,"path":"2017/12/12/git-notes/","link":"","permalink":"http://yoursite.com/2017/12/12/git-notes/","excerpt":"","text":"分支 查看本地分支 1$ git branch 查看远程分支 1$ git branch -a 创建分支1.1.2并切换到1.1.2分支 1$ git checkout -b 1.1.2 拆分写法 12$ git branch 1.1.2$ git checkout 1.1.2 删除本地分支 1$ git branch -d 1.1.2 推送本地分支到远程分支，远程分支不存在则创建 1$ git push origin 1.1.2:1.1.2 本地分支留空则是删除远程分支 1$ git push origin :1.1.2 本地分支推送到远程分支 1$ git push origin 1.1.2 合并work分支到当前分支 1$ git merge work git pull和本地冲突 冲突log 123456789101112$ git pullremote: Counting objects: 24, done.remote: Compressing objects: 100% (17/17), done.remote: Total 24 (delta 7), reused 23 (delta 6), pack-reused 0Unpacking objects: 100% (24/24), done.From https://github.com/elmorec/hexo-theme-inside a98e719..3b64c8a master -&gt; origin/mastererror: Your local changes to the following files would be overwritten by merge: _config.ymlPlease commit your changes or stash them before you merge.AbortingUpdating a98e719..3b64c8a 1、用 git stash本地暂时保存起来 12$ git stashSaved working directory and index state WIP on master: a98e719 update scripts 2、pull 3、还原git stash pop stash@{0} 1234$ git stash pop stash@&#123;0&#125;Auto-merging _config.ymlOn branch masterYour branch is up-to-date with 'origin/master'.","raw":null,"content":null,"categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"面向对象设计-依赖倒置原则（DIP）","slug":"ood-dip","date":"2016-05-29T04:08:00.000Z","updated":"2017-12-17T02:17:43.841Z","comments":true,"path":"2016/05/29/ood-dip/","link":"","permalink":"http://yoursite.com/2016/05/29/ood-dip/","excerpt":"","text":"简介 引入：高层的决定不能因为某一个低层次模块的变动而影响全局，导致整个系统的变动。 什么是DIP？ 全称：依赖倒置原则（Dependency inversion principle） 定义： 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口 抽象接口不应该依赖于具体实现，而具体实现则因该依赖于抽象接口。 我们如何理解DIP？ 知道依赖倒置的由来 由于过去传统软件开发方法倾向于高层依赖于低层 如今依赖倒置通过接口隔离，高层和底层都依赖于接口后 结论：从结构上相对于传统编程方式而言就是倒置了。 依赖倒置反面教材 结构如下：没有遵循依赖倒置 代码如下： 1234567891011121314151617181920212223/** * 高层 */class GaoCeng &#123; ZhongCeng mZhongCeng; public GaoCeng(ZhongCeng mZhongCeng) &#123; this.mZhongCeng = mZhongCeng; &#125;&#125;/** * 中层 */class ZhongCeng&#123; DiCeng mDiCeng; public ZhongCeng(DiCeng mDiCeng)&#123; this.mDiCeng = mDiCeng; &#125;&#125;/** * 底层 */class DiCeng&#123;&#125; 依赖倒置正面教材 结构如下： 代码如下： 123456789101112131415161718192021222324252627282930313233/** * 中层接口 */interface ZhongCengInterface&#123; &#125;/** * 高层接口 */interface GaoCengInterface&#123; &#125;/** * 高层 */class GaoCeng &#123; GaoCengInterface mGaoCengInterface; public GaoCeng(GaoCengInterface mGaoCengInterface) &#123; this.mGaoCengInterface = mGaoCengInterface; &#125;&#125;/** * 中层 */class ZhongCeng implements GaoCengInterface&#123; ZhongCengInterface mZhongCengInterface; public ZhongCeng(ZhongCengInterface mZhongCengInterface)&#123; this.mZhongCengInterface = mZhongCengInterface; &#125;&#125;/** * 底层 */class DiCeng implements ZhongCengInterface&#123;&#125; 结论 可以从结构图上明确看出两种方式依赖结构是相反的，所以叫依赖倒置 通过这种结构我们可以肆意的更改具体的接口实现类，而不会影响高层 遵循DIP有什么好处？既然我们理解了DIP，那么DIP的好处不言而喻。 通过依赖于接口，隔离了具体实现类 低一层的变动并不会导致高一层的变动 提高了代码的容错性、扩展性和易于维护 既然有好处，那么就必定有坏处：代码的增加，学习成本和代码思考时间的增加。（不过相对于后期的好处，这点我们还是能理解的） 例子其实理解DIP的例子就是一个很好的对比例子。现在来一个实际一点的例子：超重提价 需求：编写一个称重提价装置，物体2元/斤（物体重量 &lt;= 100）计算。当物体超过100kg提醒，然后超出部分以10元/斤（物体重量 &gt; 100）计算。 以传统方式编程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 称重器传统编程 */class Scales&#123; private double readValue;//获取到的物体的重量 private double highestValue; private double inPrice; private double outPrice; public Scales(double highestValue, double inPrice, double outPrice) &#123; this.highestValue = highestValue; this.inPrice = inPrice; this.outPrice = outPrice; &#125; /** * 当有物体放上去后称重 */ public void startScales() &#123; //...readValue = ？ （这里获取称重器计算的重量） showWeigh(readValue); double price = 0; double diff = readValue - highestValue; if (diff &gt; 0) &#123; outWeighWarn(diff); price += highestValue * inPrice; price += diff * outPrice; &#125; else &#123; price += readValue * inPrice; &#125; showPrice(price); &#125; /** * 显示重量 */ private void showWeigh(double weigh) &#123; &#125; /** * 超重提醒 */ private void outWeighWarn(double outWeigh) &#123;&#125; /** * 显示价格 */ private void showPrice(double price) &#123; &#125;&#125; 依赖倒置后 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** 称重接口*/interface Weigh &#123; double read();&#125;/** 最大重量、范围内价格、范围外价格的设置*/interface Value&#123; double highestValue(); double inPrice(); double outPrice();&#125;/** 显示器接口*/interface Show &#123; void outWeighWarn(double diff); void showWeigh(double weigh); void showPrice(double price);&#125;class Scales&#123; private Weigh mWeigh; private Show mShow; private Value mValue; public Scales(Weigh mWeigh, Show mShow, Value mValue) &#123; this.mShow = mShow; this.mWeigh = mWeigh; this.mValue = mValue; &#125; /** * 当有物体放上去后称重 */ public void startScales() &#123; mShow.showWeigh(mWeigh.read()); double price = 0; double diff = mWeigh.read() - mValue.highestValue(); if (diff &gt; 0) &#123; mShow.outWeighWarn(diff); price += mValue.highestValue() * mValue.inPrice(); price += diff * mValue.outPrice(); &#125; else &#123; price += mWeigh.read() * mValue.inPrice(); &#125; mShow.showPrice(price); &#125;&#125; 我们可以看出依赖倒置后使代码可复用，可以是任意的称重装置，可以是任意的显示装置，只要它们实现对应的接口即可。高层不必在意底层具体是什么东西。 总结 DIP的规则：依赖于抽象，不应该依赖于具体类。 任何变量都不应该持有一个指向具体类的指正或这引用 任何类都不应该从具体类派生 任何方法都不应该覆写它的任何基类中已经实现了的方法 每个程序都会有违反这些规则的情况，有时必须创建具体类的实例。此外，这些规则对于那些具体但却稳定的类来说似乎不太合理。如果一个具体类不太会改变，并且也不会创建其他类似的派生类，那么依赖于它并不会造成损害，比如说String类型。 然而，我们编写的大多数具体类都是不稳定的，我们将它们隐藏在抽象接口后面，隔离它们的不稳定性。 由于抽象将高层和细节彼此隔离，所以代码也非常容易维护 参考文献敏捷软件开发 第12章 依赖倒置原则（DIP）","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"面向对象设计-接口隔离(ISP)","slug":"ood-isp","date":"2016-05-07T02:12:00.000Z","updated":"2017-12-17T03:42:15.182Z","comments":true,"path":"2016/05/07/ood-isp/","link":"","permalink":"http://yoursite.com/2016/05/07/ood-isp/","excerpt":"","text":"引入： 老手机： 你们这些年轻手机光溜溜的，全身上下只有两个插孔几个按钮，为啥这么受欢迎？新手机：老前辈，您虽然占了一半都是按钮，可以快速的点到，但是多数情况下都没用呀！我虽然只有几个按钮，但都是经常用到滴。我也能达到和你一样的效果，而且更简洁。老手机：恩，人们只有打字的时候才用到那些按钮。新手机：所以在平常时候，我这几个按钮就可以满足大部分需要了。老手机：真是一代比一代强咯！ ISP 1.何为ISP？ 全称：接口隔离原则（Interface Segregation Principle） 定义：客户程序不应该被迫依赖于它们不使用的方法 2.如何理解ISP？ 比如图2-1.违反了ISP中的鸵鸟类不应该被迫依赖于不使用的飞翔方法 现在将2-1.满足ISP的例子中的接口鸟进行拆分，能飞的鸟类麻雀实现接口飞鸟，不能飞的鸟类鸵鸟实现接口鸟，如下图2-2所示。 可能到这里大家有个疑惑：接口变多了！对！就是接口变多了。不是上面还举例了手机的例子吗？阐明了减少接口的好处。 其实我们减少并不是接口，而是接口中的抽象方法。 通过分离来满足客户端的需求，使客户端程序中只存在需要的方法。 客户端的不同需求才是导致接口改变的原因。 3.遵循ISP有什么好处？ 不遵循ISP而导致的一些问题，在图2-1中，鸵鸟是不需要飞的，但保留了飞的方法。 现在接口中的飞()方法需要进行改动，假如改成：boolean fly()—可以理解为调用一次向上飞，再调用一次向下飞，依次循环。 现在不仅会飞的鸟需要改动，连鸵鸟这些不会飞的鸟都要莫名奇妙的跟着去改动。 显然这导致了程序之间的耦合增强，影响到了不应该影响的客户程序 现在正过来看遵循ISP接口，如图2-2所示的例子，分离了方法飞，使得更改时并不会影响到不相干的客户程序（鸵鸟类） 需要尽可能避免这种耦合，因此我们希望分离接口。 可以看出，分离接口有利于我们对需求变更时的快速高效的执行行动。 并且使之解构层次更加的分明 4.循序渐进的例子（来自敏捷软件开发[^foot1]） 以ATM用户界面为例 ATM的用户界面有不同的交易模式，现将从ATM的基类Transaction（交易类）中派生子类： DepositTransaction存款 WithdrawalTransaction取款 TransferTransaction转账 每一个子类交易都有一个界面，因此要依赖于UI，调用的不同方法，如：DepositTransaction会调用UI类中的RequestDepositAmount()方法，当前ATM结果如下图4-2-1.ATM操作解构所示。 这样做是ISP告诉我们应当避免的情形 每个操作使用的UI方法，其他的操作都不会使用 当每次Transaction子类的改动都会迫使对UI进行改动，从而影响到了其他所有Transaction子类及其他所有依赖于UI接口的类。 当要增加一个支付煤气费的交易时，为了处理该操作想要显示的特定消息，就需要在UI中加入新的方法。糟糕的是，由于Transaction的子类全部依赖于UI接口，所以它们都需要重新编译。 因此现在有一个办法，将UI接口分解成像DepositUI、WithdrawalUI以及TransferUI这样的单独接口，可以避免这种不合适的耦合，最终的UI接口可以去多重继承这些单独的接口。图5-3-1.分离的ATM接口和之后的代码展示了这个模型。 定义交易接口 12345678910111213141516171819/** 存款UI接口*/interface DepositUI &#123; void RequestDepositAmount();&#125;/** 取款UI接口*/interface WithdrawalUI &#123; void RequestWithdrawalAmount();&#125;/** 转账UI接口*/interface TransferUI &#123; void RequestTransferAmount();&#125;/** UI接口继承所有的交易接口*/interface UI extends DepositUI, WithdrawalUI, TransferUI&#123;&#125; 交易抽象类 1234/** 交易类*/abstract class Transaction &#123; public abstract void Execute();&#125; 交易派生类 123456789101112131415161718192021222324252627282930313233343536373839404142/** 存款交易类*/class DepositTransaction extends Transaction &#123; private DepositUI mDepositUI; public DepositTransaction(DepositUI mDepositUI) &#123; this.mDepositUI = mDepositUI; &#125; @Override public void Execute() &#123; //... mDepositUI.RequestDepositAmount(); //... &#125;&#125;/** 取款交易类*/class WithdrawalTransaction extends Transaction &#123; private WithdrawalUI mWithdrawalUI; public WithdrawalTransaction(WithdrawalUI mWithdrawalUI) &#123; this.mWithdrawalUI = mWithdrawalUI; &#125; @Override public void Execute() &#123; //... mWithdrawalUI.RequestWithdrawalAmount(); //... &#125;&#125;/** 转账交易类*/class TransferTransaction extends Transaction &#123; private TransferUI mTransferUI; public TransferTransaction(TransferUI mTransferUI) &#123; this.mTransferUI = mTransferUI; &#125; @Override public void Execute() &#123; //... mTransferUI.RequestTransferAmount(); //... &#125;&#125; 创建交易对象：由于每个操作都必须以特定的方式知晓UI版本，如TransferTransaction必须知道TransferUI。在程序中，使每个操作的构造时给它传入指向特定于它的UI的引用，从而解决这个问题。如下进行初始化 1234UI GUI;void fun() &#123; DepositTransaction mDepositTransaction = new DepositTransaction(GUI);&#125; 虽然这样很方便，但同样要求每个操作都有一个指向对应UI的引用成员。另外一种解决这个问题的方法是创建一组全局常量。全局变量并不总是意味着拙劣的设计，在这种情况下，它们有着明显的易于访问的有点。 1234567891011/** UI全局变量*/class UIGlobals &#123; public static DepositUI mDepositUI; public static WithdrawalUI mWithdrawalUI; public static TransferUI mTransferUI; public UIGlobals(UI lui) &#123; UIGlobals.mDepositUI = lui; UIGlobals.mWithdrawalUI = lui; UIGlobals.mTransferUI = lui; &#125;&#125; 123456789/** 转账交易类*/class TransferTransaction extends Transaction &#123; @Override public void Execute() &#123; //... UIGlobals.mTransferUI.RequestTransferAmount(); //... &#125;&#125; 1234567891011121314151617181920/** * UI的实现类 */class UIEntity implements UI &#123; @Override public void RequestDepositAmount() &#123; //... &#125; @Override public void RequestTransferAmount() &#123; //... &#125; @Override public void RequestWithdrawalAmount() &#123; //... &#125;&#125; 12345678910111213/** * 使用 */class A &#123; //初始化UI静态类 UIGlobals mUIGlobals = new UIGlobals(new UIEntity()); //调用姿势 void fun() &#123; Transaction mTransaction = new TransferTransaction(); mTransaction.Execute(); &#125;&#125; 由于敏捷软件开发举的例子是c++的，知识有限，表示很多看不懂，可能有些地方偏差较大，想了解更多建议亲自去看看( ¯▽¯；) 5.总结 胖类（fat class）：就是上边讲解的不满足ISP的类型 可以看出胖类增强了类之间的耦合，使得对该胖类进行改动会影响到所有其他类。 通过将胖类接口分解成多个特定类（客户端程序）的接口，使得强耦合得以解决 然后该胖类继承所有特定类的接口，并实现它们。就解除了这个特定类和它没有调用方法间的依赖关系，并使得这些特定类之间互不依赖。 6.参考文献 敏捷软件开发 第12章 接口隔离原则（ISP） 如何向妻子解释OOD","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"面向对象设计-里氏替换原则(LSP)","slug":"ood-lsp","date":"2016-04-23T03:02:00.000Z","updated":"2017-12-17T03:36:06.605Z","comments":true,"path":"2016/04/23/ood-lsp/","link":"","permalink":"http://yoursite.com/2016/04/23/ood-lsp/","excerpt":"","text":"引： 有一只小麻雀在大平原上，飞呀飞～。飞累了，看见前方一个大鸟…小麻雀：大鸟兄你好，本鸟叫麻雀！请问您怎么称呼？大鸵鸟：原来是麻雀小弟呀！本鸟叫鸵鸟！小麻雀：鸵鸟哥耶！小弟飞的累的不行！让兄弟在您雄伟的身躯上歇歇脚么？大鸵鸟：不行！本鸟还走累了呢！那我咋办？小麻雀：你飞呗！难道我还拖着你不成？大鸵鸟：前提是我要是能飞的起来呀！小麻雀：开什么玩笑！咱们都是鸟，你飞不起来？“飞”是咋们鸟类的特征，想到飞就想到咋们鸟～。 LSP 1. 何为LSP？ 全称：里氏替换原则（Liskov Substitution principle） 定义：派生类（子类）对象能够替换其基类（超类）对象被使用[^foot1] Barbara Liskov对LSP定义是这么说的：若对每个类型S的对象q1，都存在一个类型T的对象q2，使得在所有对T编写的程序P中，用q1替换q2后，程序P行为功能不变，则S是T的子类型。听着有些绕，我将它画一个类图便于理解： LSP定义理解dsf在类P中将T的对象q2，换成S的对象q1行为功能不变则S继承T，得如图所示的关系 2. 何为L？何为S？L:芭芭拉·利斯科夫（Barbara Liskov）因为提出这个原则的女士姓里S:替换（Substitution）父类能被子类替换 替换如上述定义所述，子类替换父类后不会影响其行为和功能。 3. 为何要有LSP？ ①首先谈谈要是违反LSP 来张违反LSP的类图 分析 现在我说天上飞着一只鸟。。。 子类麻雀替换父类：天上飞着一只麻雀。 子类鸵鸟替换父类：天上飞着一只鸵鸟。 由上因为违反了里氏替代原则，导致整个设计存在严重逻辑错误。 由于违反了里氏替代原则，间接的违反了OCP原则[^foot2]。因为明显可以看出飞翔对于鸵鸟因该是封闭的。 ②再来看一些代码（LSP的违反导致OCP的违反） 代码如下 有三个类：鸟、鸵鸟、麻雀。鸵鸟和麻雀都有要去北京的方法 1234567891011121314151617181920212223242526272829303132333435/** * 鸟 */class Bird&#123; public static final int IS_OSTRICH = 1;//是鸵鸟 public static final int IS_SPARROW = 2;//是麻雀 public int isType; public Bird(int isType) &#123; this.isType = isType; &#125;&#125;/** * 鸵鸟 */class Ostrich extends Bird&#123; public Ostrich() &#123; super(Bird.IS_OSTRICH); &#125; public void toBeiJing()&#123; System.out.print(\"跑着去北京！\"); &#125;&#125;/** * 麻雀 */class Sparrow extends Bird&#123; public Sparrow() &#123; super(Bird.IS_SPARROW); &#125; public void toBeiJing()&#123; System.out.print(\"飞着去北京！\"); &#125;&#125; 现在有一个方法birdLetGo，统一处理去北京的行为 123456789public void birdLetGo(Bird bird) &#123; if (bird.isType == Bird.IS_OSTRICH) &#123; Ostrich ostrich = (Ostrich) bird; ostrich.toBeiJing(); &#125; else if (bird.isType == Bird.IS_SPARROW) &#123; Sparrow sparrow = (Sparrow) bird; sparrow.toBeiJing(); &#125;&#125; 分析大家可以看出，birdLetGo方法明显的违反了开闭原则[^foot2]，它必须要知道所有Bird的子类。并且每次创建一个Bird子类就得修改它一次。 ③结论 由上面的分析可以大致的了解了遵守LSP的重要性了吧！ 如果不遵守，导致逻辑设计缺陷 如果不遵守，导致同时违反开闭原则 单个模型，孤立时并不具有设计意义。当多个模型出现时，抽象提取共同特征作为父类（基类），使之任何子类能替代于父类 如果试图预测所有假设，我们所得到的结果可能会充满很多不必要的复杂性。通常最好的办法是只预测那些最明显的LSP的违反状态，直到设计开始出现脆弱的状态，才去处理它们。[^foot3] 4. 基于契约设计能支持LSP？ 什么是契约设计？ 通过为每个方法声明的前置条件和后置条件[^foot4]来指定的。要是使一个方法得以执行，前置条件必须要为真。执行完毕后，该方法要保证后置条件为真。 一个例子 几个继承关系的类 1234567891011121314151617181920212223242526272829303132//动物public class Animal &#123; private String food; public Animal(String food) &#123; this.food = food; &#125; public String getFood() &#123; return food; &#125;&#125;//鸟class Bird extends Animal&#123; public Bird(String food) &#123; super(food); &#125;&#125;//鸵鸟class Ostrich extends Bird&#123; public Ostrich() &#123; super(\"草\"); &#125;&#125;//麻雀class Sparrow extends Bird&#123; public Sparrow() &#123; super(\"虫子\"); &#125;&#125; 在动物园对象中调用吃的方法 12345678class Zoo &#123; /** * 吃早餐 */ public String eatBreakfast(Animal animal) &#123; return animal.getFood(); &#125;&#125; 分析 这里的满足前置条件就是调用方需满足能接受String这个食物类型 满足后置条件可以看做是参数和返回类型 前置条件不能更强，只能更弱，比如可以这样调用： 1Object food = new Zoo().eatBreakfast(new Animal(\"肉\")); 后置条件可以更强，比如可以这样写： 1String food = new Zoo().eatBreakfast(new Ostrich()); 这样我们就可以说是前置条件和后置条件就都得以满足 5. 结论总结 如果LSP有效运用，程序会具有更多的可维护性、可重用性和健壮性 LSP是使OCP成为可能的主要原则之一 正是因为子类的可替换性，才使得父类模块无须修改的情况就得以扩展 6. 参考文章 里氏替换原则-维基百科 OCP 敏捷软件开发 第10章 里氏替换原则(LSP) 前置条件和后置条件是什么？","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"Android-UI事件传递就是这么个事儿","slug":"android-ui-event","date":"2016-04-16T07:31:00.000Z","updated":"2017-12-17T05:22:39.785Z","comments":true,"path":"2016/04/16/android-ui-event/","link":"","permalink":"http://yoursite.com/2016/04/16/android-ui-event/","excerpt":"","text":"我们寻找的，也只不过是内心世界的片刻安宁，以及，那样一场盛大的清欢。 聊聊UI事件传递 什么是UI事件？ 触摸屏幕中UI控件的那一刻即为事件发生 MotionEvent对象包含了所有的触摸事件，如触摸的位置、多指触摸等 MotionEvent描述了当前的操作类型，以下为常见类型(数字代表对应的值)： ACTION_DOWN = 0 按下 ACTION_UP = 1 抬起 ACTION_MOVE = 2 移动 ACTION_CANCEL = 3 动作取消 ACTION_OUTSIDE = 4 动作超出边界 ACTION_POINTER_DOWN = 5 已有一个点被按住，此时再按下一个点 ACTION_POINTER_UP = 6 多个点被按住，非最后放开的点都会调用 事件如何传递？ 自定义的父布局和子布局，用来观察事件的变化(View1和Button1为自定义View和自定义Button，默认以自定义View1举例 上图简略关系如下： × 之前一直以为事件是从子布局开始传递到父布，因为以直观的角度我们先碰到的是子布局得到错误的事件顺序：view1 --&gt; ViewGroup2 --&gt; ViewGroup1 √ 后来才知道事件是从父布局传递到子布局，是由父布局判断点击位置上面有子布局然后向子布局传递。如果事件向子布局传递没有被拦截和消费，那么事件又会向父布局传递。正确的没有被拦截和消费的事件顺序：Activity --&gt; ViewGroup1 --&gt; ViewGroup2 --&gt; View1 --&gt; ViewGroup2 --&gt; ViewGroup1 --&gt; Activity 以下的Log为当手指对view1点击、滑动、抬起时， 发生的一系列事件传递（0.按下；1.抬起； 2.移动）： -1234567891011121314151617181920E/MainActivity: ----------- dispatchTouchEvent = 0E/ViewGroup1: ------------- dispatchTouchEvent = 0E/ViewGroup1: ------------- onInterceptTouchEvent = 0E/ViewGroup2: ------------- dispatchTouchEvent = 0E/ViewGroup2: ------------- onInterceptTouchEvent = 0E/View1: ------------------ dispatchTouchEvent = 0E/View1: ------------------ onTouchEvent = 0E/ViewGroup2: ------------- onTouchEvent = 0E/ViewGroup1: ------------- onTouchEvent = 0E/MainActivity: ----------- onTouchEvent = 0E/MainActivity: ----------- dispatchTouchEvent = 2E/MainActivity: ----------- onTouchEvent = 2E/MainActivity: ----------- dispatchTouchEvent = 2E/MainActivity: ----------- onTouchEvent = 2E/MainActivity: ----------- dispatchTouchEvent = 2E/MainActivity: ----------- onTouchEvent = 2E/MainActivity: ----------- dispatchTouchEvent = 1E/MainActivity: ----------- onTouchEvent = 1E/MainActivity: ----------- dispatchTouchEvent = 1E/MainActivity: ----------- onTouchEvent = 1 观察 可以看出事件由外层大布局到内部子布局传进去，在从子布局传出去（Activity --&gt; ViewGroup1 --&gt; ViewGroup2 --&gt; View1 --&gt; ViewGroup2 --&gt; ViewGroup1 --&gt; Activity） 由此log还可以看出：当按下的事件没有被拦截，那么所有状态的事件都由Activity进行处理 没有拦截事件时 如何拦截？ 通过dispatchTouchEvent对事件进行拦截，当返回值为true的时候拦截事件 拦截后事件将不会传到子布局 现在以ViewGroup1为例： 让ViewGroup1中的dispatchTouchEvent直接返回true 当手指对View1点击、移动、抬起时 发生的一系列事件传递（0.按下；1.抬起； 2.移动） 12345678910E/MainActivity: ---------------- dispatchTouchEvent = 0E/ViewGroup1: ------------------ dispatchTouchEvent = 0E/MainActivity: ---------------- dispatchTouchEvent = 2E/ViewGroup1: ------------------ dispatchTouchEvent = 2E/MainActivity: ---------------- dispatchTouchEvent = 2E/ViewGroup1: ------------------ dispatchTouchEvent = 2E/MainActivity: ---------------- dispatchTouchEvent = 2E/ViewGroup1: ------------------ dispatchTouchEvent = 2E/MainActivity: ---------------- dispatchTouchEvent = 1E/ViewGroup1: ------------------ dispatchTouchEvent = 1 观察 可以看出事件传递到ViewGroup1后被拦截，没有被任何布局消费 也就是说事件还没被消费就被拦截会导致触摸无效 我们可以在dispatchTouchEvent判断哪些情况需要拦截，哪些不需要拦截就放事件过去（以上直接返回了true拦截了所有情况的事件） 拦截ViewGroup1的所有事件 如何获取？ 通过onInterceptTouchEvent获取事件，当返回值为true的时候获取事件 获取事件后会调用onTouchEvent方法，调用这个方法后，如果我们设置了OnTouchListener，那么触摸监听将会被调用。现在以ViewGroup2为例： 让ViewGroup2中的onInterceptTouchEvent直接返回true 当手指对View1点击、移动、抬起时 发生的一系列事件传递（0.按下；1.抬起； 2.移动） -12345678910111213141516E/MainActivity: ---------------- dispatchTouchEvent = 0E/ViewGroup1: ------------------ dispatchTouchEvent = 0E/ViewGroup1: ------------------ onInterceptTouchEvent = 0E/ViewGroup2: ------------------ dispatchTouchEvent = 0E/ViewGroup2: ------------------ onInterceptTouchEvent = 0E/ViewGroup2: ------------------ onTouchEvent = 0E/ViewGroup1: ------------------ onTouchEvent = 0E/MainActivity: ---------------- onTouchEvent = 0E/MainActivity: ---------------- dispatchTouchEvent = 2E/MainActivity: ---------------- onTouchEvent = 2E/MainActivity: ---------------- dispatchTouchEvent = 2E/MainActivity: ---------------- onTouchEvent = 2E/MainActivity: ---------------- dispatchTouchEvent = 2E/MainActivity: ---------------- onTouchEvent = 2E/MainActivity: ---------------- dispatchTouchEvent = 1E/MainActivity: ---------------- onTouchEvent = 1 观察问题 原因 解决 哎呀呀~！为啥我获取到了的事件之后，移动和抬起手指的事件被MainActivity吃了！愤怒！！ 原来onTouchEvent如果处理按下事件DOWN的时候没有返回true。如果onTouchEvent处理DOWN时候返回false，则表示没有消费事件，事件将会回到父布局，并且后续事件将不会再传递过来。 onTouchEvent方法中判断为按下DOWN事件的时候，返回true即下面要说的消费 当ViewGroup2事件获取到了，但没有消费 如何消费？ 上边已经提到过，就是获取事件遗留下来一个问题：获取到了按下事件，为啥没继续获取到后续的事件？就是因为按下时onTouchEvent没有返回true，导致事件从新回到父布局，也就是没有消费事件。 现在接着以ViewGroup2为例： 还是让ViewGroup2中的onInterceptTouchEvent直接返回true 添加：在onTouchEvent方法中添加判断if (event.getAction() == MotionEvent.ACTION_DOWN) {return true;} 当手指对View1点击、移动、抬起时 发生的一系列事件传递（0.按下；1.抬起； 2.移动） 123456789101112131415161718192021222324E/MainActivity: ---------------- dispatchTouchEvent = 0E/ViewGroup1: ------------------ dispatchTouchEvent = 0E/ViewGroup1: ------------------ onInterceptTouchEvent = 0E/ViewGroup2: ------------------ dispatchTouchEvent = 0E/ViewGroup2: ------------------ onInterceptTouchEvent = 0E/ViewGroup2: ------------------ onTouchEvent = 0E/MainActivity: ---------------- dispatchTouchEvent = 2E/ViewGroup1: ------------------ dispatchTouchEvent = 2E/ViewGroup1: ------------------ onInterceptTouchEvent = 2E/ViewGroup2: ------------------ dispatchTouchEvent = 2E/ViewGroup2: ------------------ onTouchEvent = 2E/MainActivity: ---------------- onTouchEvent = 2E/MainActivity: ---------------- dispatchTouchEvent = 2E/ViewGroup1: ------------------ dispatchTouchEvent = 2E/ViewGroup1: ------------------ onInterceptTouchEvent = 2E/ViewGroup2: ------------------ dispatchTouchEvent = 2E/ViewGroup2: ------------------ onTouchEvent = 2E/MainActivity: ---------------- onTouchEvent = 2E/MainActivity: ---------------- dispatchTouchEvent = 1E/ViewGroup1: ------------------ dispatchTouchEvent = 1E/ViewGroup1: ------------------ onInterceptTouchEvent = 1E/ViewGroup2: ------------------ dispatchTouchEvent = 1E/ViewGroup2: ------------------ onTouchEvent = 1E/MainActivity: ---------------- onTouchEvent = 1 观察 由上边log可以看出，现在在ViewGroup2中的onTouchEvent的按下事件返回一个true后，按下事件并没有在传递回父布局中，使得后续事件都将能得到 可以看出当后续事件传递过来时，ViewGroup2已经没有再次调用onInterceptTouchEvent方法 我们只是将按下DOWN的事件返回true，所以除了按下事件其他移动或抬起的事件activity都也能获取到。当onTouchEvent不管三七二十一直接返回一个true时，activity就不会获取到事件 当消费ViewGroup2的按下DOWN事件时 当ViewGroup2中onTouchEvent直接返回true时 Button获取事件是怎么回事？ 现在将View1换成Button1，其他的恢复最初状态，先来看看触摸的log 12345678910111213141516171819202122232425262728E/MainActivity: ------------- dispatchTouchEvent = 0E/ViewGroup1: --------------- dispatchTouchEvent = 0E/ViewGroup1: --------------- onInterceptTouchEvent = 0E/ViewGroup2: --------------- dispatchTouchEvent = 0E/ViewGroup2: --------------- onInterceptTouchEvent = 0E/Button1: ------------------ dispatchTouchEvent = 0E/Button1: ------------------ onTouchEvent = 0E/MainActivity: ------------- dispatchTouchEvent = 2E/ViewGroup1: --------------- dispatchTouchEvent = 2E/ViewGroup1: --------------- onInterceptTouchEvent = 2E/ViewGroup2: --------------- dispatchTouchEvent = 2E/ViewGroup2: --------------- onInterceptTouchEvent = 2E/Button1: ------------------ dispatchTouchEvent = 2E/Button1: ------------------ onTouchEvent = 2E/MainActivity: ------------- dispatchTouchEvent = 2E/ViewGroup1: --------------- dispatchTouchEvent = 2E/ViewGroup1: --------------- onInterceptTouchEvent = 2E/ViewGroup2: --------------- dispatchTouchEvent = 2E/ViewGroup2: --------------- onInterceptTouchEvent = 2E/Button1: ------------------ dispatchTouchEvent = 2E/Button1: ------------------ onTouchEvent = 2E/MainActivity: ------------- dispatchTouchEvent = 1E/ViewGroup1: --------------- dispatchTouchEvent = 1E/ViewGroup1: --------------- onInterceptTouchEvent = 1E/ViewGroup2: --------------- dispatchTouchEvent = 1E/ViewGroup2: --------------- onInterceptTouchEvent = 1E/Button1: ------------------ dispatchTouchEvent = 1E/Button1: ------------------ onTouchEvent = 1 在来看看序列图 Button获取触摸事件 这一看，这不是和上面那张图当ViewGroup2中onTouchEvent直接返回true时的效果一样的吗？也就是说button默认就是直接获取了事件，没有让事件返回主布局中。 等等还有一个！！！大家都知道布局有个属性clickable吧！当设置它的值为true时，使得这个布局事件如button所述！ 更深入的理解的话这里博客已经介绍的很详细了 Android事件分发机制完全解析，带你从源码的角度彻底理解(上) Android事件分发机制完全解析，带你从源码的角度彻底理解(下) 实际的应用-来一个简单的应用 xml布局1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:padding=\"10dp\"&gt; &lt;CheckBox android:id=\"@+id/checkbox_lock\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Lock Selection\" /&gt; &lt;RadioGroup android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;RadioButton android:id=\"@+id/selection_first\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"First\"/&gt; &lt;RadioButton android:id=\"@+id/selection_second\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"Second\"/&gt; &lt;RadioButton android:id=\"@+id/selection_third\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"Third\"/&gt; &lt;/RadioGroup&gt;&lt;/LinearLayout&gt; activity代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.examples.customtouch;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.widget.CheckBox;/** * Created by Dave Smith * Double Encore, Inc. * Date: 9/25/12 * TouchListenerActivity */public class TouchListenerActivity extends Activity implements View.OnTouchListener &#123; /* Views to display last seen touch event */ CheckBox mLockBox; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.touch_listener); mLockBox = (CheckBox) findViewById(R.id.checkbox_lock); findViewById(R.id.selection_first).setOnTouchListener(this); findViewById(R.id.selection_second).setOnTouchListener(this); findViewById(R.id.selection_third).setOnTouchListener(this); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; /* * Consume the events here so the buttons cannot process them * if the CheckBox in the UI is checked */ Log.e(\"TouchListenerActivity\", getNameForEvent(event)); return mLockBox.isChecked(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.e(\"onTouchEvent\", getNameForEvent(event)); return super.onTouchEvent(event); &#125; private String getNameForEvent(MotionEvent event) &#123; String action = \"\"; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: action = \"ACTION_DOWN\"; break; case MotionEvent.ACTION_CANCEL: action = \"ACTION_CANCEL\"; break; case MotionEvent.ACTION_MOVE: action = \"ACTION_MOVE\"; break; case MotionEvent.ACTION_UP: action = \"ACTION_UP\"; break; default: return null; &#125; return String.format(\"%s\\n%.1f, %.1f\", action, event.getX(), event.getY()); &#125;&#125; 状态 描述 当Lock Selection没有勾选时 下边的单选能正常选择 当Lock Selection勾选时 下边的单选无法点击 大家是否疑惑了，为什么复选框选中状态，ontouch返回了true反而不能点击了。为什么不是返回false无法点击，返回true时才能点击呢？其实这些控件默认可以点击的都是默认获取事件的，如上面说的button为什么获取事件一样，所以返回true和false和预想的结果相反。 所用知识和资料 Android studio插件plantUml画序列图和类图 PlantUML快速指南 和 PlantUML官网 Android事件分发机制完全解析，带你从源码的角度彻底理解(上)Android事件分发机制完全解析，带你从源码的角度彻底理解(下) 公共技术点之 View 事件传递 最后的那个例子来自于这儿","raw":null,"content":null,"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"view","slug":"view","permalink":"http://yoursite.com/tags/view/"}]},{"title":"面向对象设计-开闭原则(OCP)","slug":"ood-ocp","date":"2016-04-12T00:43:00.000Z","updated":"2017-12-17T03:31:10.428Z","comments":true,"path":"2016/04/12/ood-ocp/","link":"","permalink":"http://yoursite.com/2016/04/12/ood-ocp/","excerpt":"","text":"OCP 啥是OCP？ 全称：开闭原则(Open-Closed Principle)[^foot2] 定义：软件实体（类、模块、函数等等）应该是可以扩展的 开(O)什么？关(C)什么？ 开(O)：对于扩展是开放的 对于某个模块的功能是可以进行扩展的。当需求改变，我们只需对其进行扩展即可满足于新的需求。 比如说：“砖”，我们不需要改变它的形态与结构，就可以根据需求来建高楼、建围墙、建厕所、建这样建那样(๑乛乛๑)。 - - 所以可以认为“砖”对于扩展的需求是开放的。又比如说电脑主板对于cpu、内存等是可扩展的。 关(C)：对于更改是封闭的 对模块进行扩展时，不必改动模块的源代码或者二进制代码。如果说这个模块已经明确的定义、稳定、有效的被多个其他模块使用，那么关闭这个模块，提供接口供其它模块使用。 比如我们的电脑由“CPU”、“主板”、“内存”等构成，它们并不是紧紧耦合做成一块的。想想，要是紧紧的长一块，什么CUP、什么内存密密麻麻的小线、触角、身体的一部分和主板一体化。那么现在我的一个内存坏了，我表示我是渣渣得重新买一台电脑了，能内存修好的高手因该不多吧！就算内存能修好CPU又多少人能修好啊！但还好它们都是分离的，接口都是规定好了的，我需要买一个内存插上就好了。我们不需要知道知道内存里面、CPU里面是啥构造。要是坏了时，要是升级时，只需要更换这个模块而不需要更换整个硬件系统或修理这个硬件系统里的某个小模块。- - 原谅我废话了一大圈，就是想表达个封闭内部，能减少bug，方便扩展，能更好的分工合作（做主板的就做主板） 为何要提倡OCP？其实在上面大家因该已经明白一些了，“开放”是为了更好的扩展，适应更多的相应需求。“关闭”是为了降低耦合，降低了维护难度和制作成本。两者可以说本是互为一体，而又被分开说成两样。因为关闭时得留出口开放本就是处理的一个模块同时进行。 在许多方面，OCP的面向对象的核心所在注意： 我们因该对频繁出现的变化进行封闭开放处理也就是进行抽象 拒绝不成熟的抽象和抽象本身一样重要 比如说？(实际例子) 违反OCP,既不开放又不封闭 上图展示了一个没有遵循OCP的设计例子，电灯类和电源类是两个具体的类。要让电灯发光，需要电源这个属性。如果此时要将电灯接在另一个电源上面，就必须更换成另一个电源的属性（将电灯连线与另一个电源）。 遵循OCP,既开放又封闭 上图展示了一个解决上面问题的OCP设计，灯座是一个拥有抽象成员的接口（比如说与电源的连线）。电灯类使用这个抽象类（有插座的成员属性），而电灯的对象使用的是灯座接口的实现类电源。如果我们需要将电灯接到另一个电源，只需要接到另一插座。如果要更换电源，那么将插座接到另一个电源。这样双方的改变，被插座接口隔离而不会影响到具体的类。（我理解为隔离了变化的扩散） 注意 只有当我们预测到这种变化，那么就可以设计一个抽象来进行隔离 无论模块是多么的封闭都会存在一些无法对之封闭的变化（比如说我现在要让灯泡闪红光），没有对所有的情况都贴切的模型 设计人员必须对设计的模块应该对哪种变化封闭做出选择 END 总的来说开闭原则也如锦上添花，在原有锦织物上增添鲜花，让美的东西更美。 在许多方面，OCP都是面向对象的核心所在。遵循这个原则可给面向对象技术带来巨大的好处（灵活性、可重用性以及可维护性）。然而，并不是说只要使用一种面向对象语言就是遵循了这个原则。 对于应用程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确地做法是开发人员应当仅仅对程序中频繁变化的那些部分做出抽象，拒绝不成熟的抽象和抽象本身一样重要。 参考文章 《敏捷软件开发：原则、模式与实践》第9章 开放-封闭原则 维基百科-开闭原则 《面向对象软件构造》第二版 中英对照 第3章 3.3五项原则","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"面向对象设计-单一职责原则(SRP)","slug":"ood-srp","date":"2016-04-07T15:55:00.000Z","updated":"2017-12-17T02:33:28.951Z","comments":true,"path":"2016/04/07/ood-srp/","link":"","permalink":"http://yoursite.com/2016/04/07/ood-srp/","excerpt":"","text":"SRP 何为SRP？ 全称：单一职责原则(Single Responsibility Principle) 定义:该原则规定每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来 何为职责(R)? 既然是单一“职责”，那么职责即为被规定的因素。 概括：”功能(职责)”为改变的原因，一个类或者模块应该有且只有一个改变的原因。 如下图农活责任所示，耕菜地和耕水田即为牛和耕地机的职责，即为这个对象存在的原因（下面将来讨论这个关系图）。 农活责任 为何要提倡SRP？ 其思想简单，但却难以掌握。就是一个模块，一个类只能干一件事情。 看上图农活责任，晃眼一看我们会决定这是对的！但仔细一分析农活接口其中包含的耕菜地和耕水田两个责任。 牛耕水田，但它耕不动菜地，只能调用耕水田的接口，因此耕菜地的接口对于牛来说就是多余的。但耕地机即能耕菜地，也能耕水田。这就像是牛本来是耕田的，我们却说它还能去耕菜地，耕地机能做的事情，老牛表示无能为力！ 这样违反了SRP，导致了严重的问题。因为我们给牛保留了一个多余而不会完成的责任，这让我们每次提到牛不仅说它能耕水田还能耕菜地。这让我们对牛的描述更加的复杂而没有准确性。程序也时这样，当没用的责任增加，就会让相应的类都变得臃肿腐臭。当我们要添加牛要耕后要吃草，耕地机耕地后要加油时，继续往农活接口中添加，这样使得农活什么都能干，使得后期修改维护等难度太大。 如果不分离责任，在不断变化和添加的需求面前，责任之间耦合度强导致我们的程序更加的脆弱。比如说？（实际举例说明） 例子一 农活责任(改) 如上图将两个责任分离，牛实现耕水田的时候，不会知道也不会去在意耕菜地，分离了责任，该做的才做，不做的不用管。 例子二（来自敏捷软件开发第8章）[^foot]1234567//调制解调器interface Modem &#123; void dial(String pno);//拨号 void hangup();//挂断 void send(char c);//发送消息 void recv();//接收消息&#125; 这个接口中显示了两个职责，一个是连接管理，一个是数据通信。dial和hangup函数进行调制解调器的连接处理，而send和recv函数进行数据的通信。 这两个责任应该被分开吗？这决定于应用程序以何种方式变化。如果应用程序的变化会影响连接函数的部署，那么这个设计就具有僵化性的臭味。因为调用send和recv的类必须要重新编译连接处理函数，部署的次数常常会超过我们希望的次数。在这种情况下，这两个职责应该被分离。如图下图所示，这样避免了客户应用程序和这两个职责耦合在一起。 分离的Modem接口 注意 另一方面，如果应用程序的变化方式总是会导致两个职责同时变化，那么就不必分离他们，分离后会导致不必要的复杂性。 此外还有个推论：变化的曲线是仅当变化实际发生时才具有真正的意义。如果没有征兆，那么去应用SRP，或者其他原则都是不明智的。 结论总结 SRP为最简单的原则，也是最难运用好的原则 软件设计真正要做的其实就是发现责任并把那些责任分离 其他原则都将能追溯到SRP 大道至简，只有不断在代码中运用才能真正体会其中的奥妙 参考文章[1]《敏捷软件开发：原则、模式与实践》第8章 单一职责原则[2]维基百科[3]我是怎样向妻子解释OOD的","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"Ubuntu安装Android studio","slug":"install-android-studio-linux","date":"2016-03-26T23:13:00.000Z","updated":"2017-12-10T14:12:39.529Z","comments":true,"path":"2016/03/27/install-android-studio-linux/","link":"","permalink":"http://yoursite.com/2016/03/27/install-android-studio-linux/","excerpt":"","text":"1.安装jdk①由于linux自带openjdk因此我就将openjdk卸载了装jdk1.71$ sudo apt-get remove openjdk-* ②下载jdk1.7jdk1.7下载链接我下载的文件为：jdk-7u79-linux-x64.tar.gz ③解压 创建/usr/java目录 1$ sudo mkdir /usr/java 将当前目录下的jdk压缩包移/usr/java 1~/下载 $ sudo mv jdk-7u79-linux-x64.tar.gz /usr/java 解压到/usr/java，删除压缩包 123$ cd /usr/java$ sudo tar -zxvf /usr/java/jdk-7u79-linux-x64.tar.gz$ sudo rm jdk-7u79-linux-x64.tar.gz ④配置jdk环境变量 打开环境变量配置文件profile 1$ sudo gedit /etc/profile 在文本最后添加如下信息，注意改成自己的jdk版本 1234JAVA_HOME=/usr/java/jdk1.7.0_79PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH 保存、重启、java -version验证是否配置成功 2.安装android studio①下载linux android studio官网下载 ②解压将下载好的android studio压缩包移动到/usr/local目录，然后unzip命令解压1unzip android-studio-ide-141.2456560-linux.zip ③运行进入android-studio/bin,然后运行studio.sh12$ cd android-studio/bin$ sh studio.sh ④因为在linux mint第一天已经修改hosts翻墙，所以就自动下载sdk和更新，节省操作咯！3.安装Genymotion Genymotion被称为是速度最快的Android模拟器可不是盖的，手机也没有两，就打算安装一个模拟器。 Genymotion官网注册一个号，登录了就能下载免费版本的虚拟机。我下载版本的连接地址 安装步骤根据这篇教程Ubuntu下安装Genymotion安卓模拟器 Linux教程 将genymotion-2.6.0-ubuntu15_x64.bin移动到用户目录$ mv genymotion-2.6.0-ubuntu15_x64.bin /home/jiana 需要安装一个软件virtualbox才能使用Gecymotion,命令:sudo apt-get install virtualbox 进入/home/jiana运行genymotion文件 123$ cd /home/jiana/$ chmod +x genymotion-2.6.0-ubuntu15_x64.bin $ ./genymotion-2.6.0-ubuntu15_x64.bin 完成后进入该用户目录下的genymotion目录，双击运行genymotion。好了，接下来就可以下载genymotion虚拟机来体验快感了。","raw":null,"content":null,"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}