{"meta":{"title":"徐佳吉的博客","subtitle":null,"description":null,"author":"xujiaji","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"HappyBubble-气泡对话框（根据被点击View位置显示、可定制）","slug":"happy-bubble","date":"2017-12-16T06:08:50.000Z","updated":"2017-12-16T06:30:59.900Z","comments":true,"path":"2017/12/16/happy-bubble/","link":"","permalink":"http://yoursite.com/2017/12/16/happy-bubble/","excerpt":"","text":"Github 气泡布局的形状可以改变，如四角弧度、气泡颜色、箭头大小和阴影。 气泡Dialog可以根据被点击的view的位置来确定自己展示的位置。 如何开始?在你模块中的build.gradle添加上HappyBubble依赖1compile &apos;com.github.xujiaji:happy-bubble:1.0.1&apos; 如何使用 HappyBubble-BubbleDialog? 方法参考表 方法名 参数 描述 addContentView View 添加填充在气泡中的视图 setClickedView View 被点击的View（触发Dialog出现的View） setPosition enum BubbleDialog.Position:LEFT, TOP, RIGHT, BOTTOM BubbleDialog相对于被点击的view的位置 calBar boolean 是否计算状态栏的高度（如果布局没有全屏，则需要计算） setOffsetX int 如果您对dialog所展示的x轴位置不满，需要调整x轴方向偏移 setOffsetY int 如果您对dialog所展示的y轴位置不满，需要调整y轴方向偏移 setBubbleLayout BubbleLayout 自定义dialog的气泡布局 setTransParentBackground - 背景透明 softShowUp - 当气泡dialog中有EditText时，软键盘弹出会遮挡EditText时，dialog随软键盘上移。 show - 显示 最简单的实现 需要提供：Context、填充的View、被点击的View。如果最外层布局没有全屏时，您需要计算状态栏的高度，否则会多向下偏移一个状态栏的高度。 12345new BubbleDialog(this) .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view3, null)) .setClickedView(mButton) .calBar(true) .show(); 向下偏移8dp1234567new BubbleDialog(this) .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view3, null)) .setClickedView(mButton4) .setPosition(mPosition) .setOffsetY(8) .calBar(true) .show(); 当想要输入框随软键盘上移时1234567new BubbleDialog(this) .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view, null)) .setClickedView(mButton12) .setPosition(mPosition) .calBar(true) .softShowUp() .show(); 自定义 BubbleLayout. 123456789101112BubbleLayout bl = new BubbleLayout(this);bl.setBubbleColor(Color.BLUE);bl.setShadowColor(Color.RED);bl.setLookLength(Util.dpToPx(this, 54));bl.setLookWidth(Util.dpToPx(this, 48));new BubbleDialog(this) .addContentView(LayoutInflater.from(this).inflate(R.layout.dialog_view5, null)) .setClickedView(mButton8) .setPosition(mPosition) .calBar(true) .setBubbleLayout(bl) .show(); 自定义 BubbleDialog，可交互的 BubbleDialog. 1、布局 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"160dp\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;Button android:id=\"@+id/button13\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button1\" /&gt; &lt;Button android:id=\"@+id/button14\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button2\" /&gt; &lt;Button android:id=\"@+id/button15\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button3\" /&gt;&lt;/LinearLayout&gt; 2、自定义 BubbleDialog 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 自定义可操作性dialog * Created by JiajiXu on 17-12-11. */public class CustomOperateDialog extends BubbleDialog implements View.OnClickListener&#123; private ViewHolder mViewHolder; private OnClickCustomButtonListener mListener; public CustomOperateDialog(Context context) &#123; super(context); calBar(true); setTransParentBackground(); setPosition(Position.TOP); View rootView = LayoutInflater.from(context).inflate(R.layout.dialog_view4, null); mViewHolder = new ViewHolder(rootView); addContentView(rootView); mViewHolder.btn13.setOnClickListener(this); mViewHolder.btn14.setOnClickListener(this); mViewHolder.btn15.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (mListener != null) &#123; mListener.onClick(((Button)v).getText().toString()); &#125; &#125; private static class ViewHolder &#123; Button btn13, btn14, btn15; public ViewHolder(View rootView) &#123; btn13 = rootView.findViewById(R.id.button13); btn14 = rootView.findViewById(R.id.button14); btn15 = rootView.findViewById(R.id.button15); &#125; &#125; public void setClickListener(OnClickCustomButtonListener l) &#123; this.mListener = l; &#125; public interface OnClickCustomButtonListener &#123; void onClick(String str); &#125;&#125; 3、显示 123456789101112CustomOperateDialog codDialog = new CustomOperateDialog(this) .setPosition(mPosition) .setClickedView(mButton10);codDialog.setClickListener(new CustomOperateDialog.OnClickCustomButtonListener()&#123; @Override public void onClick(String str) &#123; mButton10.setText(\"点击了：\" + str); &#125;&#125;);codDialog.show(); 查看关于BappyDialog的使用代码TestDialogActivity 代码 如何使用 HappyBubble-BubbleLayout?在XML代码中设置属性值 属性参照表 属性 值 描述 lookAt left, top, right, bottom 箭头指向 lookLength dimension 箭头的长度 lookPosition dimension 箭头相对于x或y轴的位置 lookWidth dimension 箭头的宽度 bubbleColor color 气泡的颜色 bubbleRadius dimension 气泡四角的圆弧 bubblePadding dimension 气泡边缘到内容的距离 shadowRadius dimension 阴影的扩散大小 shadowX dimension 阴影在x轴方向的偏移 shadowY dimension 阴影在y轴方向的偏移 shadowColor color 阴影的颜色 xml 例子 12345678910&lt;com.xujiaji.happybubble.BubbleLayout xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/bubbleLayout\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:layout_margin=\"16dp\" app:lookAt=\"left\" app:lookLength=\"16dp\" app:lookPosition=\"20dp\" app:lookWidth=\"16dp\" /&gt; 在java代码中定义属性值。 BubbleLayout 通过“set属性名”方法和invalidate方法来更新BubbleLayout。 1mBubbleLayout.setLook(BubbleLayout.Look.LEFT); 查看更多 MainActivity 代码 demo 下载 License12345678910111213Copyright 2016 XuJiajiLicensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.","raw":null,"content":null,"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"library","slug":"library","permalink":"http://yoursite.com/tags/library/"}]},{"title":"Android开发中的bug清单","slug":"android-bug-list","date":"2017-12-12T07:34:41.000Z","updated":"2017-12-12T09:26:17.482Z","comments":true,"path":"2017/12/12/android-bug-list/","link":"","permalink":"http://yoursite.com/2017/12/12/android-bug-list/","excerpt":"","text":"java.lang.RuntimeException: Unable to get provider 解决地址：https://stackoverflow.com/questions/37312103/unable-to-get-provider-com-google-firebase-provider-firebaseinitprovider 原因：在SDK &lt;22的设备中遇到同样的问题，原因是MultiDex，MultiDex.install必须在attachBaseContext方法中 解决方法自定义Application中添加如下：12345678public class YourApplication extends Application &#123; @Override protected void attachBaseContext(Context context) &#123; super.attachBaseContext(context); MultiDex.install(this); &#125;&#125; build.gradle中添加如下：1compile &apos;com.android.support:multidex:1.0.1&apos;","raw":null,"content":null,"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"}]},{"title":"linux笔记","slug":"linux-notes","date":"2017-12-12T04:25:29.000Z","updated":"2017-12-12T04:41:30.606Z","comments":true,"path":"2017/12/12/linux-notes/","link":"","permalink":"http://yoursite.com/2017/12/12/linux-notes/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Git笔记","slug":"git-notes","date":"2017-12-12T03:02:34.000Z","updated":"2017-12-12T09:40:01.873Z","comments":true,"path":"2017/12/12/git-notes/","link":"","permalink":"http://yoursite.com/2017/12/12/git-notes/","excerpt":"","text":"分支 查看本地分支 1$ git branch 查看远程分支 1$ git branch -a 创建分支1.1.2并切换到1.1.2分支 1$ git checkout -b 1.1.2 拆分写法 12$ git branch 1.1.2$ git checkout 1.1.2 删除本地分支 1$ git branch -d 1.1.2 推送本地分支到远程分支，远程分支不存在则创建 1$ git push origin 1.1.2:1.1.2 本地分支留空则是删除远程分支 1$ git push origin :1.1.2 本地分支推送到远程分支 1$ git push origin 1.1.2 合并work分支到当前分支 1$ git merge work","raw":null,"content":null,"categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"面向对象设计-接口隔离(ISP)","slug":"ood-isp","date":"2016-05-07T02:12:00.000Z","updated":"2017-12-13T10:56:57.747Z","comments":true,"path":"2016/05/07/ood-isp/","link":"","permalink":"http://yoursite.com/2016/05/07/ood-isp/","excerpt":"","text":"主目录：一个面向对象设计(OOD)的学习思路设计 引入： 老手机： 你们这些年轻手机光溜溜的，全身上下只有两个插孔几个按钮，为啥这么受欢迎？新手机：老前辈，您虽然占了一半都是按钮，可以快速的点到，但是多数情况下都没用呀！我虽然只有几个按钮，但都是经常用到滴。我也能达到和你一样的效果，而且更简洁。老手机：恩，人们只有打字的时候才用到那些按钮。新手机：所以在平常时候，我这几个按钮就可以满足大部分需要了。老手机：真是一代比一代强咯！ 1.何为ISP？ 全称：接口隔离原则（Interface Segregation Principle） 定义：客户程序不应该被迫依赖于它们不使用的方法 2.如何理解ISP？ 比如图2-1.违反了ISP中的鸵鸟类不应该被迫依赖于不使用的飞翔方法 现在将2-1.满足ISP的例子中的接口鸟进行拆分，能飞的鸟类麻雀实现接口飞鸟，不能飞的鸟类鸵鸟实现接口鸟，如下图2-2所示。 可能到这里大家有个疑惑：接口变多了！对！就是接口变多了。不是上面还举例了手机的例子吗？阐明了减少接口的好处。 其实我们减少并不是接口，而是接口中的抽象方法。 通过分离来满足客户端的需求，使客户端程序中只存在需要的方法。 客户端的不同需求才是导致接口改变的原因。 3.遵循ISP有什么好处？ 不遵循ISP而导致的一些问题，在图2-1中，鸵鸟是不需要飞的，但保留了飞的方法。 现在接口中的飞()方法需要进行改动，假如改成：boolean fly()—可以理解为调用一次向上飞，再调用一次向下飞，依次循环。 现在不仅会飞的鸟需要改动，连鸵鸟这些不会飞的鸟都要莫名奇妙的跟着去改动。 显然这导致了程序之间的耦合增强，影响到了不应该影响的客户程序 现在正过来看遵循ISP接口，如图2-2所示的例子，分离了方法飞，使得更改时并不会影响到不相干的客户程序（鸵鸟类） 需要尽可能避免这种耦合，因此我们希望分离接口。 可以看出，分离接口有利于我们对需求变更时的快速高效的执行行动。 并且使之解构层次更加的分明 4.循序渐进的例子（来自敏捷软件开发[^foot1]） 以ATM用户界面为例 ATM的用户界面有不同的交易模式，现将从ATM的基类Transaction（交易类）中派生子类： DepositTransaction存款 WithdrawalTransaction取款 TransferTransaction转账 每一个子类交易都有一个界面，因此要依赖于UI，调用的不同方法，如：DepositTransaction会调用UI类中的RequestDepositAmount()方法，当前ATM结果如下图4-2-1.ATM操作解构所示。 这样做是ISP告诉我们应当避免的情形 每个操作使用的UI方法，其他的操作都不会使用 当每次Transaction子类的改动都会迫使对UI进行改动，从而影响到了其他所有Transaction子类及其他所有依赖于UI接口的类。 当要增加一个支付煤气费的交易时，为了处理该操作想要显示的特定消息，就需要在UI中加入新的方法。糟糕的是，由于Transaction的子类全部依赖于UI接口，所以它们都需要重新编译。 因此现在有一个办法，将UI接口分解成像DepositUI、WithdrawalUI以及TransferUI这样的单独接口，可以避免这种不合适的耦合，最终的UI接口可以去多重继承这些单独的接口。图5-3-1.分离的ATM接口和之后的代码展示了这个模型。 定义交易接口 12345678910111213141516171819/** 存款UI接口*/interface DepositUI &#123; void RequestDepositAmount();&#125;/** 取款UI接口*/interface WithdrawalUI &#123; void RequestWithdrawalAmount();&#125;/** 转账UI接口*/interface TransferUI &#123; void RequestTransferAmount();&#125;/** UI接口继承所有的交易接口*/interface UI extends DepositUI, WithdrawalUI, TransferUI&#123;&#125; 交易抽象类 1234/** 交易类*/abstract class Transaction &#123; public abstract void Execute();&#125; 交易派生类 123456789101112131415161718192021222324252627282930313233343536373839404142/** 存款交易类*/class DepositTransaction extends Transaction &#123; private DepositUI mDepositUI; public DepositTransaction(DepositUI mDepositUI) &#123; this.mDepositUI = mDepositUI; &#125; @Override public void Execute() &#123; //... mDepositUI.RequestDepositAmount(); //... &#125;&#125;/** 取款交易类*/class WithdrawalTransaction extends Transaction &#123; private WithdrawalUI mWithdrawalUI; public WithdrawalTransaction(WithdrawalUI mWithdrawalUI) &#123; this.mWithdrawalUI = mWithdrawalUI; &#125; @Override public void Execute() &#123; //... mWithdrawalUI.RequestWithdrawalAmount(); //... &#125;&#125;/** 转账交易类*/class TransferTransaction extends Transaction &#123; private TransferUI mTransferUI; public TransferTransaction(TransferUI mTransferUI) &#123; this.mTransferUI = mTransferUI; &#125; @Override public void Execute() &#123; //... mTransferUI.RequestTransferAmount(); //... &#125;&#125; 创建交易对象：由于每个操作都必须以特定的方式知晓UI版本，如TransferTransaction必须知道TransferUI。在程序中，使每个操作的构造时给它传入指向特定于它的UI的引用，从而解决这个问题。如下进行初始化 1234UI GUI;void fun() &#123; DepositTransaction mDepositTransaction = new DepositTransaction(GUI);&#125; 虽然这样很方便，但同样要求每个操作都有一个指向对应UI的引用成员。另外一种解决这个问题的方法是创建一组全局常量。全局变量并不总是意味着拙劣的设计，在这种情况下，它们有着明显的易于访问的有点。 1234567891011/** UI全局变量*/class UIGlobals &#123; public static DepositUI mDepositUI; public static WithdrawalUI mWithdrawalUI; public static TransferUI mTransferUI; public UIGlobals(UI lui) &#123; UIGlobals.mDepositUI = lui; UIGlobals.mWithdrawalUI = lui; UIGlobals.mTransferUI = lui; &#125;&#125; 123456789/** 转账交易类*/class TransferTransaction extends Transaction &#123; @Override public void Execute() &#123; //... UIGlobals.mTransferUI.RequestTransferAmount(); //... &#125;&#125; 1234567891011121314151617181920/** * UI的实现类 */class UIEntity implements UI &#123; @Override public void RequestDepositAmount() &#123; //... &#125; @Override public void RequestTransferAmount() &#123; //... &#125; @Override public void RequestWithdrawalAmount() &#123; //... &#125;&#125; 12345678910111213/** * 使用 */class A &#123; //初始化UI静态类 UIGlobals mUIGlobals = new UIGlobals(new UIEntity()); //调用姿势 void fun() &#123; Transaction mTransaction = new TransferTransaction(); mTransaction.Execute(); &#125;&#125; 由于敏捷软件开发举的例子是c++的，知识有限，表示很多看不懂，可能有些地方偏差较大，想了解更多建议亲自去看看( ¯▽¯；) 5.总结 胖类（fat class）：就是上边讲解的不满足ISP的类型 可以看出胖类增强了类之间的耦合，使得对该胖类进行改动会影响到所有其他类。 通过将胖类接口分解成多个特定类（客户端程序）的接口，使得强耦合得以解决 然后该胖类继承所有特定类的接口，并实现它们。就解除了这个特定类和它没有调用方法间的依赖关系，并使得这些特定类之间互不依赖。 6.参考文献 敏捷软件开发 第12章 接口隔离原则（ISP） 如何向妻子解释OOD","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"面向对象设计-里氏替换原则(LSP)","slug":"ood-lsp","date":"2016-04-23T03:02:00.000Z","updated":"2017-12-13T10:56:53.248Z","comments":true,"path":"2016/04/23/ood-lsp/","link":"","permalink":"http://yoursite.com/2016/04/23/ood-lsp/","excerpt":"","text":"主目录：一个面向对象设计(OOD)的学习思路设计 引子： 有一只小麻雀在大平原上，飞呀飞～。飞累了，看见前方一个大鸟…小麻雀：大鸟兄你好，本鸟叫麻雀！请问您怎么称呼？大鸵鸟：原来是麻雀小弟呀！本鸟叫鸵鸟！小麻雀：鸵鸟哥耶！小弟飞的累的不行！让兄弟在您雄伟的身躯上歇歇脚么？大鸵鸟：不行！本鸟还走累了呢！那我咋办？小麻雀：你飞呗！难道我还拖着你不成？大鸵鸟：前提是我要是能飞的起来呀！小麻雀：开什么玩笑！咱们都是鸟，你飞不起来？“飞”是咋们鸟类的特征，想到飞就想到咋们鸟～。 1. 何为LSP？ 全称：里氏替换原则（Liskov Substitution principle） 定义：派生类（子类）对象能够替换其基类（超类）对象被使用[^foot1] Barbara Liskov对LSP定义是这么说的：若对每个类型S的对象q1，都存在一个类型T的对象q2，使得在所有对T编写的程序P中，用q1替换q2后，程序P行为功能不变，则S是T的子类型。听着有些绕，我将它画一个类图便于理解： 2. 何为L？何为S？L:芭芭拉·利斯科夫（Barbara Liskov）因为提出这个原则的女士姓里S:替换（Substitution）父类能被子类替换 替换如上述定义所述，子类替换父类后不会影响其行为和功能。 3. 为何要有LSP？ ①首先谈谈要是违反LSP 来张违反LSP的类图 分析 现在我说天上飞着一只鸟。。。 子类麻雀替换父类：天上飞着一只麻雀。 子类鸵鸟替换父类：天上飞着一只鸵鸟。 由上因为违反了里氏替代原则，导致整个设计存在严重逻辑错误。 由于违反了里氏替代原则，间接的违反了OCP原则[^foot2]。因为明显可以看出飞翔对于鸵鸟因该是封闭的。 ②再来看一些代码（LSP的违反导致OCP的违反） 代码如下 有三个类：鸟、鸵鸟、麻雀。鸵鸟和麻雀都有要去北京的方法 1234567891011121314151617181920212223242526272829303132333435/** * 鸟 */class Bird&#123; public static final int IS_OSTRICH = 1;//是鸵鸟 public static final int IS_SPARROW = 2;//是麻雀 public int isType; public Bird(int isType) &#123; this.isType = isType; &#125;&#125;/** * 鸵鸟 */class Ostrich extends Bird&#123; public Ostrich() &#123; super(Bird.IS_OSTRICH); &#125; public void toBeiJing()&#123; System.out.print(\"跑着去北京！\"); &#125;&#125;/** * 麻雀 */class Sparrow extends Bird&#123; public Sparrow() &#123; super(Bird.IS_SPARROW); &#125; public void toBeiJing()&#123; System.out.print(\"飞着去北京！\"); &#125;&#125; 现在有一个方法birdLetGo，统一处理去北京的行为 123456789public void birdLetGo(Bird bird) &#123; if (bird.isType == Bird.IS_OSTRICH) &#123; Ostrich ostrich = (Ostrich) bird; ostrich.toBeiJing(); &#125; else if (bird.isType == Bird.IS_SPARROW) &#123; Sparrow sparrow = (Sparrow) bird; sparrow.toBeiJing(); &#125;&#125; 分析大家可以看出，birdLetGo方法明显的违反了开闭原则[^foot2]，它必须要知道所有Bird的子类。并且每次创建一个Bird子类就得修改它一次。 ③结论 由上面的分析可以大致的了解了遵守LSP的重要性了吧！ 如果不遵守，导致逻辑设计缺陷 如果不遵守，导致同时违反开闭原则 单个模型，孤立时并不具有设计意义。当多个模型出现时，抽象提取共同特征作为父类（基类），使之任何子类能替代于父类 如果试图预测所有假设，我们所得到的结果可能会充满很多不必要的复杂性。通常最好的办法是只预测那些最明显的LSP的违反状态，直到设计开始出现脆弱的状态，才去处理它们。[^foot3] 4. 基于契约设计能支持LSP？ 什么是契约设计？ 通过为每个方法声明的前置条件和后置条件[^foot4]来指定的。要是使一个方法得以执行，前置条件必须要为真。执行完毕后，该方法要保证后置条件为真。 一个例子 几个继承关系的类 1234567891011121314151617181920212223242526272829303132//动物public class Animal &#123; private String food; public Animal(String food) &#123; this.food = food; &#125; public String getFood() &#123; return food; &#125;&#125;//鸟class Bird extends Animal&#123; public Bird(String food) &#123; super(food); &#125;&#125;//鸵鸟class Ostrich extends Bird&#123; public Ostrich() &#123; super(\"草\"); &#125;&#125;//麻雀class Sparrow extends Bird&#123; public Sparrow() &#123; super(\"虫子\"); &#125;&#125; 在动物园对象中调用吃的方法 12345678class Zoo &#123; /** * 吃早餐 */ public String eatBreakfast(Animal animal) &#123; return animal.getFood(); &#125;&#125; 分析 这里的满足前置条件就是调用方需满足能接受String这个食物类型 满足后置条件可以看做是参数和返回类型 前置条件不能更强，只能更弱，比如可以这样调用： 1Object food = new Zoo().eatBreakfast(new Animal(\"肉\")); 后置条件可以更强，比如可以这样写： 1String food = new Zoo().eatBreakfast(new Ostrich()); 这样我们就可以说是前置条件和后置条件就都得以满足 5. 结论总结 如果LSP有效运用，程序会具有更多的可维护性、可重用性和健壮性 LSP是使OCP成为可能的主要原则之一 正是因为子类的可替换性，才使得父类模块无须修改的情况就得以扩展 6. 参考文章 里氏替换原则-维基百科 OCP 敏捷软件开发 第10章 里氏替换原则(LSP) 前置条件和后置条件是什么？","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"面向对象设计-开闭原则(OCP)","slug":"ood-ocp","date":"2016-04-12T00:43:00.000Z","updated":"2017-12-11T13:18:31.398Z","comments":true,"path":"2016/04/12/ood-ocp/","link":"","permalink":"http://yoursite.com/2016/04/12/ood-ocp/","excerpt":"","text":"主目录：一个面向对象设计(OOD)的学习思路设计 啥是OCP？ 全称：开闭原则(Open-Closed Principle)[^foot2] 定义：软件实体（类、模块、函数等等）应该是可以扩展的 开(O)什么？关(C)什么？ 开(O)：对于扩展是开放的 对于某个模块的功能是可以进行扩展的。当需求改变，我们只需对其进行扩展即可满足于新的需求。 比如说：“砖”，我们不需要改变它的形态与结构，就可以根据需求来建高楼、建围墙、建厕所、建这样建那样(๑乛乛๑)。 - - 所以可以认为“砖”对于扩展的需求是开放的。又比如说电脑主板对于cpu、内存等是可扩展的。 关(C)：对于更改是封闭的 对模块进行扩展时，不必改动模块的源代码或者二进制代码。如果说这个模块已经明确的定义、稳定、有效的被多个其他模块使用，那么关闭这个模块，提供接口供其它模块使用。 比如我们的电脑由“CPU”、“主板”、“内存”等构成，它们并不是紧紧耦合做成一块的。想想，要是紧紧的长一块，什么CUP、什么内存密密麻麻的小线、触角、身体的一部分和主板一体化。那么现在我的一个内存坏了，我表示我是渣渣得重新买一台电脑了，能内存修好的高手因该不多吧！就算内存能修好CPU又多少人能修好啊！但还好它们都是分离的，接口都是规定好了的，我需要买一个内存插上就好了。我们不需要知道知道内存里面、CPU里面是啥构造。要是坏了时，要是升级时，只需要更换这个模块而不需要更换整个硬件系统或修理这个硬件系统里的某个小模块。- - 原谅我废话了一大圈，就是想表达个封闭内部，能减少bug，方便扩展，能更好的分工合作（做主板的就做主板） 为何要提倡OCP？其实在上面大家因该已经明白一些了，“开放”是为了更好的扩展，适应更多的相应需求。“关闭”是为了降低耦合，降低了维护难度和制作成本。两者可以说本是互为一体，而又被分开说成两样。因为关闭时得留出口开放本就是处理的一个模块同时进行。 在许多方面，OCP的面向对象的核心所在注意： 我们因该对频繁出现的变化进行封闭开放处理也就是进行抽象 拒绝不成熟的抽象和抽象本身一样重要 比如说？(实际例子) 违反OCP 上图展示了一个没有遵循OCP的设计例子，电灯类和电源类是两个具体的类。要让电灯发光，需要电源这个属性。如果此时要将电灯接在另一个电源上面，就必须更换成另一个电源的属性（将电灯连线与另一个电源）。 遵循OCP 上图展示了一个解决上面问题的OCP设计，灯座是一个拥有抽象成员的接口（比如说与电源的连线）。电灯类使用这个抽象类（有插座的成员属性），而电灯的对象使用的是灯座接口的实现类电源。如果我们需要将电灯接到另一个电源，只需要接到另一插座。如果要更换电源，那么将插座接到另一个电源。这样双方的改变，被插座接口隔离而不会影响到具体的类。（我理解为隔离了变化的扩散） 注意 只有当我们预测到这种变化，那么就可以设计一个抽象来进行隔离 无论模块是多么的封闭都会存在一些无法对之封闭的变化（比如说我现在要让灯泡闪红光），没有对所有的情况都贴切的模型 设计人员必须对设计的模块应该对哪种变化封闭做出选择 END 总的来说开闭原则也如锦上添花，在原有锦织物上增添鲜花，让美的东西更美。 在许多方面，OCP都是面向对象的核心所在。遵循这个原则可给面向对象技术带来巨大的好处（灵活性、可重用性以及可维护性）。然而，并不是说只要使用一种面向对象语言就是遵循了这个原则。 对于应用程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确地做法是开发人员应当仅仅对程序中频繁变化的那些部分做出抽象，拒绝不成熟的抽象和抽象本身一样重要。 参考文章 《敏捷软件开发：原则、模式与实践》第9章 开放-封闭原则 维基百科-开闭原则 《面向对象软件构造》第二版 中英对照 第3章 3.3五项原则","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"面向对象设计-单一职责原则(SRP)","slug":"ood-srp","date":"2016-04-07T15:55:00.000Z","updated":"2017-12-10T14:06:15.768Z","comments":true,"path":"2016/04/07/ood-srp/","link":"","permalink":"http://yoursite.com/2016/04/07/ood-srp/","excerpt":"","text":"主目录：一个面向对象设计(OOD)的学习思路设计 何为SRP？ 全称：单一职责原则(Single Responsibility Principle) 定义:该原则规定每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来 何为职责(R)? 既然是单一“职责”，那么职责即为被规定的因素。 概括：”功能(职责)”为改变的原因，一个类或者模块应该有且只有一个改变的原因。 如下图农活责任所示，耕菜地和耕水田即为牛和耕地机的职责，即为这个对象存在的原因（下面将来讨论这个关系图）。 为何要提倡SRP？ 其思想简单，但却难以掌握。就是一个模块，一个类只能干一件事情。 看上图农活责任，晃眼一看我们会决定这是对的！但仔细一分析农活接口其中包含的耕菜地和耕水田两个责任。 牛耕水田，但它耕不动菜地，只能调用耕水田的接口，因此耕菜地的接口对于牛来说就是多余的。但耕地机即能耕菜地，也能耕水田。这就像是牛本来是耕田的，我们却说它还能去耕菜地，耕地机能做的事情，老牛表示无能为力！ 这样违反了SRP，导致了严重的问题。因为我们给牛保留了一个多余而不会完成的责任，这让我们每次提到牛不仅说它能耕水田还能耕菜地。这让我们对牛的描述更加的复杂而没有准确性。程序也时这样，当没用的责任增加，就会让相应的类都变得臃肿腐臭。当我们要添加牛要耕后要吃草，耕地机耕地后要加油时，继续往农活接口中添加，这样使得农活什么都能干，使得后期修改维护等难度太大。 如果不分离责任，在不断变化和添加的需求面前，责任之间耦合度强导致我们的程序更加的脆弱。比如说？（实际举例说明） 例子一 如上图将两个责任分离，牛实现耕水田的时候，不会知道也不会去在意耕菜地，分离了责任，该做的才做，不做的不用管。 例子二（来自敏捷软件开发第8章）^foot1234567//调制解调器interface Modem &#123; void dial(String pno);//拨号 void hangup();//挂断 void send(char c);//发送消息 void recv();//接收消息&#125; 这个接口中显示了两个职责，一个是连接管理，一个是数据通信。dial和hangup函数进行调制解调器的连接处理，而send和recv函数进行数据的通信。 这两个责任应该被分开吗？这决定于应用程序以何种方式变化。如果应用程序的变化会影响连接函数的部署，那么这个设计就具有僵化性的臭味。因为调用send和recv的类必须要重新编译连接处理函数，部署的次数常常会超过我们希望的次数。在这种情况下，这两个职责应该被分离。如图下图所示，这样避免了客户应用程序和这两个职责耦合在一起。 注意 另一方面，如果应用程序的变化方式总是会导致两个职责同时变化，那么就不必分离他们，分离后会导致不必要的复杂性。 此外还有个推论：变化的曲线是仅当变化实际发生时才具有真正的意义。如果没有征兆，那么去应用SRP，或者其他原则都是不明智的。 结论总结 SRP为最简单的原则，也是最难运用好的原则 软件设计真正要做的其实就是发现责任并把那些责任分离 其他原则都将能追溯到SRP 大道至简，只有不断在代码中运用才能真正体会其中的奥妙 参考文章[1]《敏捷软件开发：原则、模式与实践》第8章 单一职责原则[2]维基百科[3]我是怎样向妻子解释OOD的","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"Ubuntu安装Android studio","slug":"install-android-studio-linux","date":"2016-03-26T23:13:00.000Z","updated":"2017-12-10T14:12:39.529Z","comments":true,"path":"2016/03/27/install-android-studio-linux/","link":"","permalink":"http://yoursite.com/2016/03/27/install-android-studio-linux/","excerpt":"","text":"1.安装jdk①由于linux自带openjdk因此我就将openjdk卸载了装jdk1.71$ sudo apt-get remove openjdk-* ②下载jdk1.7jdk1.7下载链接我下载的文件为：jdk-7u79-linux-x64.tar.gz ③解压 创建/usr/java目录 1$ sudo mkdir /usr/java 将当前目录下的jdk压缩包移/usr/java 1~/下载 $ sudo mv jdk-7u79-linux-x64.tar.gz /usr/java 解压到/usr/java，删除压缩包 123$ cd /usr/java$ sudo tar -zxvf /usr/java/jdk-7u79-linux-x64.tar.gz$ sudo rm jdk-7u79-linux-x64.tar.gz ④配置jdk环境变量 打开环境变量配置文件profile 1$ sudo gedit /etc/profile 在文本最后添加如下信息，注意改成自己的jdk版本 1234JAVA_HOME=/usr/java/jdk1.7.0_79PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH 保存、重启、java -version验证是否配置成功 2.安装android studio①下载linux android studio官网下载 ②解压将下载好的android studio压缩包移动到/usr/local目录，然后unzip命令解压1unzip android-studio-ide-141.2456560-linux.zip ③运行进入android-studio/bin,然后运行studio.sh12$ cd android-studio/bin$ sh studio.sh ④因为在linux mint第一天已经修改hosts翻墙，所以就自动下载sdk和更新，节省操作咯！3.安装Genymotion Genymotion被称为是速度最快的Android模拟器可不是盖的，手机也没有两，就打算安装一个模拟器。 Genymotion官网注册一个号，登录了就能下载免费版本的虚拟机。我下载版本的连接地址 安装步骤根据这篇教程Ubuntu下安装Genymotion安卓模拟器 Linux教程 将genymotion-2.6.0-ubuntu15_x64.bin移动到用户目录$ mv genymotion-2.6.0-ubuntu15_x64.bin /home/jiana 需要安装一个软件virtualbox才能使用Gecymotion,命令:sudo apt-get install virtualbox 进入/home/jiana运行genymotion文件 123$ cd /home/jiana/$ chmod +x genymotion-2.6.0-ubuntu15_x64.bin $ ./genymotion-2.6.0-ubuntu15_x64.bin 完成后进入该用户目录下的genymotion目录，双击运行genymotion。好了，接下来就可以下载genymotion虚拟机来体验快感了。","raw":null,"content":null,"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}