{"meta":{"title":"徐佳吉的博客","subtitle":null,"description":null,"author":"xujiaji","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Android开发中的bug清单","slug":"android-bug-list","date":"2017-12-12T07:34:41.000Z","updated":"2017-12-12T09:26:17.482Z","comments":true,"path":"2017/12/12/android-bug-list/","link":"","permalink":"http://yoursite.com/2017/12/12/android-bug-list/","excerpt":"","text":"java.lang.RuntimeException: Unable to get provider 解决地址：https://stackoverflow.com/questions/37312103/unable-to-get-provider-com-google-firebase-provider-firebaseinitprovider 原因：在SDK &lt;22的设备中遇到同样的问题，原因是MultiDex，MultiDex.install必须在attachBaseContext方法中 解决方法自定义Application中添加如下：12345678public class YourApplication extends Application &#123; @Override protected void attachBaseContext(Context context) &#123; super.attachBaseContext(context); MultiDex.install(this); &#125;&#125; build.gradle中添加如下：1compile &apos;com.android.support:multidex:1.0.1&apos;","raw":null,"content":null,"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"}]},{"title":"linux笔记","slug":"linux-notes","date":"2017-12-12T04:25:29.000Z","updated":"2017-12-12T04:41:30.606Z","comments":true,"path":"2017/12/12/linux-notes/","link":"","permalink":"http://yoursite.com/2017/12/12/linux-notes/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Git笔记","slug":"git-notes","date":"2017-12-12T03:02:34.000Z","updated":"2017-12-12T09:24:11.117Z","comments":true,"path":"2017/12/12/git-notes/","link":"","permalink":"http://yoursite.com/2017/12/12/git-notes/","excerpt":"","text":"分支 查看本地分支 1$ git branch 查看远程分支 1$ git branch -a 创建分支1.1. `2并切换到1.1.2分支 1$ git checkout -b 1.1.2 拆分写法 12$ git branch 1.1.2$ git checkout 1.1.2 删除本地分支 1$ git branch -d 1.1.2 推送本地分支到远程分支，远程分支不存在则创建 1$ git push origin 1.1.2:1.1.2 本地分支留空则是删除远程分支 1$ git push origin :1.1.2 本地分支推送到远程分支 1$ git push origin 1.1.2 合并work分支到当前分支 1$ git merge work","raw":null,"content":null,"categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"面向对象设计-里氏替换原则(LSP)","slug":"ood-lsp","date":"2016-04-23T03:02:00.000Z","updated":"2017-12-11T13:49:59.300Z","comments":true,"path":"2016/04/23/ood-lsp/","link":"","permalink":"http://yoursite.com/2016/04/23/ood-lsp/","excerpt":"","text":"主目录：一个面向对象设计(OOD)的学习思路设计 引子： 有一只小麻雀在大平原上，飞呀飞～。飞累了，看见前方一个大鸟…小麻雀：大鸟兄你好，本鸟叫麻雀！请问您怎么称呼？大鸵鸟：原来是麻雀小弟呀！本鸟叫鸵鸟！小麻雀：鸵鸟哥耶！小弟飞的累的不行！让兄弟在您雄伟的身躯上歇歇脚么？大鸵鸟：不行！本鸟还走累了呢！那我咋办？小麻雀：你飞呗！难道我还拖着你不成？大鸵鸟：前提是我要是能飞的起来呀！小麻雀：开什么玩笑！咱们都是鸟，你飞不起来？“飞”是咋们鸟类的特征，想到飞就想到咋们鸟～。 1. 何为LSP？ 全称：里氏替换原则（Liskov Substitution principle） 定义：派生类（子类）对象能够替换其基类（超类）对象被使用[^foot1] Barbara Liskov对LSP定义是这么说的：若对每个类型S的对象q1，都存在一个类型T的对象q2，使得在所有对T编写的程序P中，用q1替换q2后，程序P行为功能不变，则S是T的子类型。听着有些绕，我将它画一个类图便于理解： 2. 何为L？何为S？L:芭芭拉·利斯科夫（Barbara Liskov）因为提出这个原则的女士姓里S:替换（Substitution）父类能被子类替换 替换如上述定义所述，子类替换父类后不会影响其行为和功能。 3. 为何要有LSP？ ①首先谈谈要是违反LSP 来张违反LSP的类图 分析 现在我说天上飞着一只鸟。。。 子类麻雀替换父类：天上飞着一只麻雀。 子类鸵鸟替换父类：天上飞着一只鸵鸟。 由上因为违反了里氏替代原则，导致整个设计存在严重逻辑错误。 由于违反了里氏替代原则，间接的违反了OCP原则[^foot2]。因为明显可以看出飞翔对于鸵鸟因该是封闭的。 ②再来看一些代码（LSP的违反导致OCP的违反） 代码如下 有三个类：鸟、鸵鸟、麻雀。鸵鸟和麻雀都有要去北京的方法 1234567891011121314151617181920212223242526272829303132333435/** * 鸟 */class Bird&#123; public static final int IS_OSTRICH = 1;//是鸵鸟 public static final int IS_SPARROW = 2;//是麻雀 public int isType; public Bird(int isType) &#123; this.isType = isType; &#125;&#125;/** * 鸵鸟 */class Ostrich extends Bird&#123; public Ostrich() &#123; super(Bird.IS_OSTRICH); &#125; public void toBeiJing()&#123; System.out.print(\"跑着去北京！\"); &#125;&#125;/** * 麻雀 */class Sparrow extends Bird&#123; public Sparrow() &#123; super(Bird.IS_SPARROW); &#125; public void toBeiJing()&#123; System.out.print(\"飞着去北京！\"); &#125;&#125; 现在有一个方法birdLetGo，统一处理去北京的行为 123456789public void birdLetGo(Bird bird) &#123; if (bird.isType == Bird.IS_OSTRICH) &#123; Ostrich ostrich = (Ostrich) bird; ostrich.toBeiJing(); &#125; else if (bird.isType == Bird.IS_SPARROW) &#123; Sparrow sparrow = (Sparrow) bird; sparrow.toBeiJing(); &#125;&#125; 分析大家可以看出，birdLetGo方法明显的违反了开闭原则[^foot2]，它必须要知道所有Bird的子类。并且每次创建一个Bird子类就得修改它一次。 ③结论 由上面的分析可以大致的了解了遵守LSP的重要性了吧！ 如果不遵守，导致逻辑设计缺陷 如果不遵守，导致同时违反开闭原则 单个模型，孤立时并不具有设计意义。当多个模型出现时，抽象提取共同特征作为父类（基类），使之任何子类能替代于父类 如果试图预测所有假设，我们所得到的结果可能会充满很多不必要的复杂性。通常最好的办法是只预测那些最明显的LSP的违反状态，直到设计开始出现脆弱的状态，才去处理它们。[^foot3] 4. 基于契约设计能支持LSP？ 什么是契约设计？ 通过为每个方法声明的前置条件和后置条件[^foot4]来指定的。要是使一个方法得以执行，前置条件必须要为真。执行完毕后，该方法要保证后置条件为真。 一个例子 几个继承关系的类 1234567891011121314151617181920212223242526272829303132//动物public class Animal &#123; private String food; public Animal(String food) &#123; this.food = food; &#125; public String getFood() &#123; return food; &#125;&#125;//鸟class Bird extends Animal&#123; public Bird(String food) &#123; super(food); &#125;&#125;//鸵鸟class Ostrich extends Bird&#123; public Ostrich() &#123; super(\"草\"); &#125;&#125;//麻雀class Sparrow extends Bird&#123; public Sparrow() &#123; super(\"虫子\"); &#125;&#125; 在动物园对象中调用吃的方法 12345678class Zoo &#123; /** * 吃早餐 */ public String eatBreakfast(Animal animal) &#123; return animal.getFood(); &#125;&#125; 分析 这里的满足前置条件就是调用方需满足能接受String这个食物类型 满足后置条件可以看做是参数和返回类型 前置条件不能更强，只能更弱，比如可以这样调用： 1Object food = new Zoo().eatBreakfast(new Animal(\"肉\")); 后置条件可以更强，比如可以这样写： 1String food = new Zoo().eatBreakfast(new Ostrich()); 这样我们就可以说是前置条件和后置条件就都得以满足 5. 结论总结 如果LSP有效运用，程序会具有更多的可维护性、可重用性和健壮性 LSP是使OCP成为可能的主要原则之一 正是因为子类的可替换性，才使得父类模块无须修改的情况就得以扩展 6. 参考文章 里氏替换原则-维基百科 OCP 敏捷软件开发 第10章 里氏替换原则(LSP) 前置条件和后置条件是什么？","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"面向对象设计-开闭原则(OCP)","slug":"ood-ocp","date":"2016-04-12T00:43:00.000Z","updated":"2017-12-11T13:18:31.398Z","comments":true,"path":"2016/04/12/ood-ocp/","link":"","permalink":"http://yoursite.com/2016/04/12/ood-ocp/","excerpt":"","text":"主目录：一个面向对象设计(OOD)的学习思路设计 啥是OCP？ 全称：开闭原则(Open-Closed Principle)[^foot2] 定义：软件实体（类、模块、函数等等）应该是可以扩展的 开(O)什么？关(C)什么？ 开(O)：对于扩展是开放的 对于某个模块的功能是可以进行扩展的。当需求改变，我们只需对其进行扩展即可满足于新的需求。 比如说：“砖”，我们不需要改变它的形态与结构，就可以根据需求来建高楼、建围墙、建厕所、建这样建那样(๑乛乛๑)。 - - 所以可以认为“砖”对于扩展的需求是开放的。又比如说电脑主板对于cpu、内存等是可扩展的。 关(C)：对于更改是封闭的 对模块进行扩展时，不必改动模块的源代码或者二进制代码。如果说这个模块已经明确的定义、稳定、有效的被多个其他模块使用，那么关闭这个模块，提供接口供其它模块使用。 比如我们的电脑由“CPU”、“主板”、“内存”等构成，它们并不是紧紧耦合做成一块的。想想，要是紧紧的长一块，什么CUP、什么内存密密麻麻的小线、触角、身体的一部分和主板一体化。那么现在我的一个内存坏了，我表示我是渣渣得重新买一台电脑了，能内存修好的高手因该不多吧！就算内存能修好CPU又多少人能修好啊！但还好它们都是分离的，接口都是规定好了的，我需要买一个内存插上就好了。我们不需要知道知道内存里面、CPU里面是啥构造。要是坏了时，要是升级时，只需要更换这个模块而不需要更换整个硬件系统或修理这个硬件系统里的某个小模块。- - 原谅我废话了一大圈，就是想表达个封闭内部，能减少bug，方便扩展，能更好的分工合作（做主板的就做主板） 为何要提倡OCP？其实在上面大家因该已经明白一些了，“开放”是为了更好的扩展，适应更多的相应需求。“关闭”是为了降低耦合，降低了维护难度和制作成本。两者可以说本是互为一体，而又被分开说成两样。因为关闭时得留出口开放本就是处理的一个模块同时进行。 在许多方面，OCP的面向对象的核心所在注意： 我们因该对频繁出现的变化进行封闭开放处理也就是进行抽象 拒绝不成熟的抽象和抽象本身一样重要 比如说？(实际例子) 违反OCP 上图展示了一个没有遵循OCP的设计例子，电灯类和电源类是两个具体的类。要让电灯发光，需要电源这个属性。如果此时要将电灯接在另一个电源上面，就必须更换成另一个电源的属性（将电灯连线与另一个电源）。 遵循OCP 上图展示了一个解决上面问题的OCP设计，灯座是一个拥有抽象成员的接口（比如说与电源的连线）。电灯类使用这个抽象类（有插座的成员属性），而电灯的对象使用的是灯座接口的实现类电源。如果我们需要将电灯接到另一个电源，只需要接到另一插座。如果要更换电源，那么将插座接到另一个电源。这样双方的改变，被插座接口隔离而不会影响到具体的类。（我理解为隔离了变化的扩散） 注意 只有当我们预测到这种变化，那么就可以设计一个抽象来进行隔离 无论模块是多么的封闭都会存在一些无法对之封闭的变化（比如说我现在要让灯泡闪红光），没有对所有的情况都贴切的模型 设计人员必须对设计的模块应该对哪种变化封闭做出选择 END 总的来说开闭原则也如锦上添花，在原有锦织物上增添鲜花，让美的东西更美。 在许多方面，OCP都是面向对象的核心所在。遵循这个原则可给面向对象技术带来巨大的好处（灵活性、可重用性以及可维护性）。然而，并不是说只要使用一种面向对象语言就是遵循了这个原则。 对于应用程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确地做法是开发人员应当仅仅对程序中频繁变化的那些部分做出抽象，拒绝不成熟的抽象和抽象本身一样重要。 参考文章 《敏捷软件开发：原则、模式与实践》第9章 开放-封闭原则 维基百科-开闭原则 《面向对象软件构造》第二版 中英对照 第3章 3.3五项原则","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"面向对象设计-单一职责原则(SRP)","slug":"ood-srp","date":"2016-04-07T15:55:00.000Z","updated":"2017-12-10T14:06:15.768Z","comments":true,"path":"2016/04/07/ood-srp/","link":"","permalink":"http://yoursite.com/2016/04/07/ood-srp/","excerpt":"","text":"主目录：一个面向对象设计(OOD)的学习思路设计 何为SRP？ 全称：单一职责原则(Single Responsibility Principle) 定义:该原则规定每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来 何为职责(R)? 既然是单一“职责”，那么职责即为被规定的因素。 概括：”功能(职责)”为改变的原因，一个类或者模块应该有且只有一个改变的原因。 如下图农活责任所示，耕菜地和耕水田即为牛和耕地机的职责，即为这个对象存在的原因（下面将来讨论这个关系图）。 为何要提倡SRP？ 其思想简单，但却难以掌握。就是一个模块，一个类只能干一件事情。 看上图农活责任，晃眼一看我们会决定这是对的！但仔细一分析农活接口其中包含的耕菜地和耕水田两个责任。 牛耕水田，但它耕不动菜地，只能调用耕水田的接口，因此耕菜地的接口对于牛来说就是多余的。但耕地机即能耕菜地，也能耕水田。这就像是牛本来是耕田的，我们却说它还能去耕菜地，耕地机能做的事情，老牛表示无能为力！ 这样违反了SRP，导致了严重的问题。因为我们给牛保留了一个多余而不会完成的责任，这让我们每次提到牛不仅说它能耕水田还能耕菜地。这让我们对牛的描述更加的复杂而没有准确性。程序也时这样，当没用的责任增加，就会让相应的类都变得臃肿腐臭。当我们要添加牛要耕后要吃草，耕地机耕地后要加油时，继续往农活接口中添加，这样使得农活什么都能干，使得后期修改维护等难度太大。 如果不分离责任，在不断变化和添加的需求面前，责任之间耦合度强导致我们的程序更加的脆弱。比如说？（实际举例说明） 例子一 如上图将两个责任分离，牛实现耕水田的时候，不会知道也不会去在意耕菜地，分离了责任，该做的才做，不做的不用管。 例子二（来自敏捷软件开发第8章）^foot1234567//调制解调器interface Modem &#123; void dial(String pno);//拨号 void hangup();//挂断 void send(char c);//发送消息 void recv();//接收消息&#125; 这个接口中显示了两个职责，一个是连接管理，一个是数据通信。dial和hangup函数进行调制解调器的连接处理，而send和recv函数进行数据的通信。 这两个责任应该被分开吗？这决定于应用程序以何种方式变化。如果应用程序的变化会影响连接函数的部署，那么这个设计就具有僵化性的臭味。因为调用send和recv的类必须要重新编译连接处理函数，部署的次数常常会超过我们希望的次数。在这种情况下，这两个职责应该被分离。如图下图所示，这样避免了客户应用程序和这两个职责耦合在一起。 注意 另一方面，如果应用程序的变化方式总是会导致两个职责同时变化，那么就不必分离他们，分离后会导致不必要的复杂性。 此外还有个推论：变化的曲线是仅当变化实际发生时才具有真正的意义。如果没有征兆，那么去应用SRP，或者其他原则都是不明智的。 结论总结 SRP为最简单的原则，也是最难运用好的原则 软件设计真正要做的其实就是发现责任并把那些责任分离 其他原则都将能追溯到SRP 大道至简，只有不断在代码中运用才能真正体会其中的奥妙 参考文章[1]《敏捷软件开发：原则、模式与实践》第8章 单一职责原则[2]维基百科[3]我是怎样向妻子解释OOD的","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"Ubuntu安装Android studio","slug":"install-android-studio-linux","date":"2016-03-26T23:13:00.000Z","updated":"2017-12-10T14:12:39.529Z","comments":true,"path":"2016/03/27/install-android-studio-linux/","link":"","permalink":"http://yoursite.com/2016/03/27/install-android-studio-linux/","excerpt":"","text":"1.安装jdk①由于linux自带openjdk因此我就将openjdk卸载了装jdk1.71$ sudo apt-get remove openjdk-* ②下载jdk1.7jdk1.7下载链接我下载的文件为：jdk-7u79-linux-x64.tar.gz ③解压 创建/usr/java目录 1$ sudo mkdir /usr/java 将当前目录下的jdk压缩包移/usr/java 1~/下载 $ sudo mv jdk-7u79-linux-x64.tar.gz /usr/java 解压到/usr/java，删除压缩包 123$ cd /usr/java$ sudo tar -zxvf /usr/java/jdk-7u79-linux-x64.tar.gz$ sudo rm jdk-7u79-linux-x64.tar.gz ④配置jdk环境变量 打开环境变量配置文件profile 1$ sudo gedit /etc/profile 在文本最后添加如下信息，注意改成自己的jdk版本 1234JAVA_HOME=/usr/java/jdk1.7.0_79PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH 保存、重启、java -version验证是否配置成功 2.安装android studio①下载linux android studio官网下载 ②解压将下载好的android studio压缩包移动到/usr/local目录，然后unzip命令解压1unzip android-studio-ide-141.2456560-linux.zip ③运行进入android-studio/bin,然后运行studio.sh12$ cd android-studio/bin$ sh studio.sh ④因为在linux mint第一天已经修改hosts翻墙，所以就自动下载sdk和更新，节省操作咯！3.安装Genymotion Genymotion被称为是速度最快的Android模拟器可不是盖的，手机也没有两，就打算安装一个模拟器。 Genymotion官网注册一个号，登录了就能下载免费版本的虚拟机。我下载版本的连接地址 安装步骤根据这篇教程Ubuntu下安装Genymotion安卓模拟器 Linux教程 将genymotion-2.6.0-ubuntu15_x64.bin移动到用户目录$ mv genymotion-2.6.0-ubuntu15_x64.bin /home/jiana 需要安装一个软件virtualbox才能使用Gecymotion,命令:sudo apt-get install virtualbox 进入/home/jiana运行genymotion文件 123$ cd /home/jiana/$ chmod +x genymotion-2.6.0-ubuntu15_x64.bin $ ./genymotion-2.6.0-ubuntu15_x64.bin 完成后进入该用户目录下的genymotion目录，双击运行genymotion。好了，接下来就可以下载genymotion虚拟机来体验快感了。","raw":null,"content":null,"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}