{"meta":{"title":"徐佳吉的博客","subtitle":null,"description":null,"author":"xujiaji","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"面向对象设计-单一职责原则(SRP)","slug":"ood-srp","date":"2016-04-07T15:55:00.000Z","updated":"2017-12-10T14:06:15.768Z","comments":true,"path":"2016/04/07/ood-srp/","link":"","permalink":"http://yoursite.com/2016/04/07/ood-srp/","excerpt":"","text":"主目录：一个面向对象设计(OOD)的学习思路设计 何为SRP？ 全称：单一职责原则(Single Responsibility Principle) 定义:该原则规定每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来 何为职责(R)? 既然是单一“职责”，那么职责即为被规定的因素。 概括：”功能(职责)”为改变的原因，一个类或者模块应该有且只有一个改变的原因。 如下图农活责任所示，耕菜地和耕水田即为牛和耕地机的职责，即为这个对象存在的原因（下面将来讨论这个关系图）。 为何要提倡SRP？ 其思想简单，但却难以掌握。就是一个模块，一个类只能干一件事情。 看上图农活责任，晃眼一看我们会决定这是对的！但仔细一分析农活接口其中包含的耕菜地和耕水田两个责任。 牛耕水田，但它耕不动菜地，只能调用耕水田的接口，因此耕菜地的接口对于牛来说就是多余的。但耕地机即能耕菜地，也能耕水田。这就像是牛本来是耕田的，我们却说它还能去耕菜地，耕地机能做的事情，老牛表示无能为力！ 这样违反了SRP，导致了严重的问题。因为我们给牛保留了一个多余而不会完成的责任，这让我们每次提到牛不仅说它能耕水田还能耕菜地。这让我们对牛的描述更加的复杂而没有准确性。程序也时这样，当没用的责任增加，就会让相应的类都变得臃肿腐臭。当我们要添加牛要耕后要吃草，耕地机耕地后要加油时，继续往农活接口中添加，这样使得农活什么都能干，使得后期修改维护等难度太大。 如果不分离责任，在不断变化和添加的需求面前，责任之间耦合度强导致我们的程序更加的脆弱。比如说？（实际举例说明） 例子一 如上图将两个责任分离，牛实现耕水田的时候，不会知道也不会去在意耕菜地，分离了责任，该做的才做，不做的不用管。 例子二（来自敏捷软件开发第8章）^foot1234567//调制解调器interface Modem &#123; void dial(String pno);//拨号 void hangup();//挂断 void send(char c);//发送消息 void recv();//接收消息&#125; 这个接口中显示了两个职责，一个是连接管理，一个是数据通信。dial和hangup函数进行调制解调器的连接处理，而send和recv函数进行数据的通信。 这两个责任应该被分开吗？这决定于应用程序以何种方式变化。如果应用程序的变化会影响连接函数的部署，那么这个设计就具有僵化性的臭味。因为调用send和recv的类必须要重新编译连接处理函数，部署的次数常常会超过我们希望的次数。在这种情况下，这两个职责应该被分离。如图下图所示，这样避免了客户应用程序和这两个职责耦合在一起。 注意 另一方面，如果应用程序的变化方式总是会导致两个职责同时变化，那么就不必分离他们，分离后会导致不必要的复杂性。 此外还有个推论：变化的曲线是仅当变化实际发生时才具有真正的意义。如果没有征兆，那么去应用SRP，或者其他原则都是不明智的。 结论总结 SRP为最简单的原则，也是最难运用好的原则 软件设计真正要做的其实就是发现责任并把那些责任分离 其他原则都将能追溯到SRP 大道至简，只有不断在代码中运用才能真正体会其中的奥妙 参考文章[1]《敏捷软件开发：原则、模式与实践》第8章 单一职责原则[2]维基百科[3]我是怎样向妻子解释OOD的","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"面向对象设计","slug":"面向对象设计","permalink":"http://yoursite.com/tags/面向对象设计/"}]},{"title":"Ubuntu安装Android studio","slug":"install-android-studio-linux","date":"2016-03-26T23:13:00.000Z","updated":"2017-12-10T14:12:39.529Z","comments":true,"path":"2016/03/27/install-android-studio-linux/","link":"","permalink":"http://yoursite.com/2016/03/27/install-android-studio-linux/","excerpt":"","text":"1.安装jdk①由于linux自带openjdk因此我就将openjdk卸载了装jdk1.71$ sudo apt-get remove openjdk-* ②下载jdk1.7jdk1.7下载链接我下载的文件为：jdk-7u79-linux-x64.tar.gz ③解压 创建/usr/java目录 1$ sudo mkdir /usr/java 将当前目录下的jdk压缩包移/usr/java 1~/下载 $ sudo mv jdk-7u79-linux-x64.tar.gz /usr/java 解压到/usr/java，删除压缩包 123$ cd /usr/java$ sudo tar -zxvf /usr/java/jdk-7u79-linux-x64.tar.gz$ sudo rm jdk-7u79-linux-x64.tar.gz ④配置jdk环境变量 打开环境变量配置文件profile 1$ sudo gedit /etc/profile 在文本最后添加如下信息，注意改成自己的jdk版本 1234JAVA_HOME=/usr/java/jdk1.7.0_79PATH=$JAVA_HOME/bin:$PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH 保存、重启、java -version验证是否配置成功 2.安装android studio①下载linux android studio官网下载 ②解压将下载好的android studio压缩包移动到/usr/local目录，然后unzip命令解压1unzip android-studio-ide-141.2456560-linux.zip ③运行进入android-studio/bin,然后运行studio.sh12$ cd android-studio/bin$ sh studio.sh ④因为在linux mint第一天已经修改hosts翻墙，所以就自动下载sdk和更新，节省操作咯！3.安装Genymotion Genymotion被称为是速度最快的Android模拟器可不是盖的，手机也没有两，就打算安装一个模拟器。 Genymotion官网注册一个号，登录了就能下载免费版本的虚拟机。我下载版本的连接地址 安装步骤根据这篇教程Ubuntu下安装Genymotion安卓模拟器 Linux教程 将genymotion-2.6.0-ubuntu15_x64.bin移动到用户目录$ mv genymotion-2.6.0-ubuntu15_x64.bin /home/jiana 需要安装一个软件virtualbox才能使用Gecymotion,命令:sudo apt-get install virtualbox 进入/home/jiana运行genymotion文件 123$ cd /home/jiana/$ chmod +x genymotion-2.6.0-ubuntu15_x64.bin $ ./genymotion-2.6.0-ubuntu15_x64.bin 完成后进入该用户目录下的genymotion目录，双击运行genymotion。好了，接下来就可以下载genymotion虚拟机来体验快感了。","raw":null,"content":null,"categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}