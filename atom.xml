<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐佳吉的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-11T13:18:31.398Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xujiaji</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象设计-开闭原则(OCP)</title>
    <link href="http://yoursite.com/2016/04/12/ood-ocp/"/>
    <id>http://yoursite.com/2016/04/12/ood-ocp/</id>
    <published>2016-04-12T00:43:00.000Z</published>
    <updated>2017-12-11T13:18:31.398Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1552955-75dbeefc5b02750c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="楼层建的更高！走的更远！"><br>主目录：<a href="http://www.jianshu.com/p/fab09d064846" target="_blank" rel="noopener">一个面向对象设计(OOD)的学习思路设计</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1552955-0cb6f8191b2737c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OCP.png"></p><h2 id="啥是OCP？"><a href="#啥是OCP？" class="headerlink" title="啥是OCP？"></a>啥是OCP？</h2><ul><li>全称：开闭原则(Open-Closed Principle)[^foot2]</li><li>定义：软件实体（类、模块、函数等等）应该是可以扩展的</li></ul><h2 id="开-O-什么？关-C-什么？"><a href="#开-O-什么？关-C-什么？" class="headerlink" title="开(O)什么？关(C)什么？"></a>开(O)什么？关(C)什么？</h2><blockquote><p>开(O)：对于扩展是开放的</p></blockquote><p>对于某个模块的功能是可以进行扩展的。当需求改变，我们只需对其进行扩展即可满足于新的需求。</p><p>比如说：“砖”，我们不需要改变它的形态与结构，就可以根据需求来建高楼、建围墙、建厕所、建这样建那样(๑乛乛๑)。 - - 所以可以认为“砖”对于扩展的需求是开放的。又比如说电脑主板对于cpu、内存等是可扩展的。 </p><blockquote><p>关(C)：对于更改是封闭的</p></blockquote><p>对模块进行扩展时，不必改动模块的源代码或者二进制代码。如果说这个模块已经明确的定义、稳定、有效的被多个其他模块使用，那么关闭这个模块，提供接口供其它模块使用。</p><p>比如我们的电脑由“CPU”、“主板”、“内存”等构成，它们并不是紧紧耦合做成一块的。想想，要是紧紧的长一块，什么CUP、什么内存密密麻麻的小线、触角、身体的一部分和主板一体化。那么现在我的一个内存坏了，我表示我是渣渣得重新买一台电脑了，能内存修好的高手因该不多吧！就算内存能修好CPU又多少人能修好啊！但还好它们都是分离的，接口都是规定好了的，我需要买一个内存插上就好了。我们不需要知道知道内存里面、CPU里面是啥构造。要是坏了时，要是升级时，只需要更换这个模块而不需要更换整个硬件系统或修理这个硬件系统里的某个小模块。- - 原谅我废话了一大圈，就是想表达个封闭内部，能减少bug，方便扩展，能更好的分工合作（做主板的就做主板）</p><h2 id="为何要提倡OCP？"><a href="#为何要提倡OCP？" class="headerlink" title="为何要提倡OCP？"></a>为何要提倡OCP？</h2><p>其实在上面大家因该已经明白一些了，“开放”是为了更好的扩展，适应更多的相应需求。“关闭”是为了降低耦合，降低了维护难度和制作成本。两者可以说本是互为一体，而又被分开说成两样。因为关闭时得留出口开放本就是处理的一个模块同时进行。</p><blockquote><p>在许多方面，OCP的面向对象的核心所在<br>注意： </p><ul><li>我们因该对频繁出现的变化进行封闭开放处理也就是进行抽象</li><li>拒绝不成熟的抽象和抽象本身一样重要</li></ul></blockquote><h2 id="比如说？-实际例子"><a href="#比如说？-实际例子" class="headerlink" title="比如说？(实际例子)"></a>比如说？(实际例子)</h2><ul><li><p>违反OCP<br><img src="http://upload-images.jianshu.io/upload_images/1552955-d7cbc0df8b002c01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="既不开放又不封闭.png"></p><p>上图展示了一个没有遵循OCP的设计例子，电灯类和电源类是两个具体的类。要让电灯发光，需要电源这个属性。如果此时要将电灯接在另一个电源上面，就必须更换成另一个电源的属性（将电灯连线与另一个电源）。</p></li><li><p>遵循OCP<br><img src="http://upload-images.jianshu.io/upload_images/1552955-075510555b25af7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="既开放又封闭.png"></p><p>上图展示了一个解决上面问题的OCP设计，灯座是一个拥有抽象成员的接口（比如说与电源的连线）。电灯类使用这个抽象类（有插座的成员属性），而电灯的对象使用的是灯座接口的实现类电源。如果我们需要将电灯接到另一个电源，只需要接到另一插座。如果要更换电源，那么将插座接到另一个电源。这样双方的改变，被插座接口隔离而不会影响到具体的类。（我理解为隔离了变化的扩散）</p></li></ul><table><thead><tr><th>注意</th></tr></thead><tbody><tr><td>只有当我们预测到这种变化，那么就可以设计一个抽象来进行隔离</td></tr><tr><td>无论模块是多么的封闭都会存在一些无法对之封闭的变化（比如说我现在要让灯泡闪红光），没有对所有的情况都贴切的模型</td></tr><tr><td>设计人员必须对设计的模块应该对哪种变化封闭做出选择</td></tr></tbody></table><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><ul><li><p>总的来说开闭原则也如锦上添花，在原有锦织物上增添鲜花，让美的东西更美。</p></li><li><p>在许多方面，OCP都是面向对象的核心所在。遵循这个原则可给面向对象技术带来巨大的好处（灵活性、可重用性以及可维护性）。然而，并不是说只要使用一种面向对象语言就是遵循了这个原则。</p></li><li><p>对于应用程序中的每个部分都肆意地进行抽象同样不是一个好主意。正确地做法是开发人员应当仅仅对程序中频繁变化的那些部分做出抽象，拒绝不成熟的抽象和抽象本身一样重要。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2></li><li>《敏捷软件开发：原则、模式与实践》第9章  开放-封闭原则</li><li><a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">维基百科-开闭原则</a></li><li>《面向对象软件构造》第二版 中英对照 第3章 3.3五项原则</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1552955-75dbeefc5b02750c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面向对象设计" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计-单一职责原则(SRP)</title>
    <link href="http://yoursite.com/2016/04/07/ood-srp/"/>
    <id>http://yoursite.com/2016/04/07/ood-srp/</id>
    <published>2016-04-07T15:55:00.000Z</published>
    <updated>2017-12-10T14:06:15.768Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1552955-f8fcbe790d7f8cd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只有佛自己才应该担负起公布玄妙秘密的职责"><br>主目录：<a href="http://www.jianshu.com/p/fab09d064846" target="_blank" rel="noopener">一个面向对象设计(OOD)的学习思路设计</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1552955-0fc1b3477d1f956e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SRP.png"></p><h2 id="何为SRP？"><a href="#何为SRP？" class="headerlink" title="何为SRP？"></a>何为SRP？</h2><ul><li>全称：单一职责原则(Single Responsibility Principle)</li><li>定义:该原则规定每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来</li></ul><h2 id="何为职责-R"><a href="#何为职责-R" class="headerlink" title="何为职责(R)?"></a>何为职责(R)?</h2><blockquote><p>既然是单一“职责”，那么职责即为被规定的因素。</p></blockquote><ul><li><p>概括：”功能(职责)”为改变的原因，一个类或者模块应该有且只有一个改变的原因。</p></li><li><p>如下图农活责任所示，耕菜地和耕水田即为牛和耕地机的职责，即为这个对象存在的原因（下面将来讨论这个关系图）。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1552955-aae094029d977f3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="农活责任"></p><h2 id="为何要提倡SRP？"><a href="#为何要提倡SRP？" class="headerlink" title="为何要提倡SRP？"></a>为何要提倡SRP？</h2><blockquote><p>其思想简单，但却难以掌握。就是一个模块，一个类只能干一件事情。</p></blockquote><p>看上图农活责任，晃眼一看我们会决定这是对的！但仔细一分析农活接口其中包含的耕菜地和耕水田两个责任。</p><ul><li><p>牛耕水田，但它耕不动菜地，只能调用耕水田的接口，因此耕菜地的接口对于牛来说就是多余的。但耕地机即能耕菜地，也能耕水田。这就像是牛本来是耕田的，我们却说它还能去耕菜地，耕地机能做的事情，老牛表示无能为力！</p></li><li><p>这样违反了SRP，导致了严重的问题。因为我们给牛保留了一个多余而不会完成的责任，这让我们每次提到牛不仅说它能耕水田还能耕菜地。这让我们对牛的描述更加的复杂而没有准确性。程序也时这样，当没用的责任增加，就会让相应的类都变得臃肿腐臭。当我们要添加牛要耕后要吃草，耕地机耕地后要加油时，继续往农活接口中添加，这样使得农活什么都能干，使得后期修改维护等难度太大。</p></li><li>如果不分离责任，在不断变化和添加的需求面前，责任之间耦合度强导致我们的程序更加的脆弱。<h2 id="比如说？（实际举例说明）"><a href="#比如说？（实际举例说明）" class="headerlink" title="比如说？（实际举例说明）"></a>比如说？（实际举例说明）</h2></li><li>例子一<br><img src="http://upload-images.jianshu.io/upload_images/1552955-75ef45d419f1dce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="农活责任(改).png"></li></ul><p>如上图将两个责任分离，牛实现耕水田的时候，不会知道也不会去在意耕菜地，分离了责任，该做的才做，不做的不用管。</p><ul><li>例子二（来自敏捷软件开发第8章）<a href="结尾">^foot</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//调制解调器</span><br><span class="line">interface Modem &#123;</span><br><span class="line">    void dial(String pno);//拨号</span><br><span class="line">    void hangup();//挂断</span><br><span class="line">    void send(char c);//发送消息</span><br><span class="line">    void recv();//接收消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这个接口中显示了两个职责，一个是连接管理，一个是数据通信。dial和hangup函数进行调制解调器的连接处理，而send和recv函数进行数据的通信。</p></blockquote><p>这两个责任应该被分开吗？这决定于应用程序以何种方式变化。如果应用程序的变化会影响连接函数的部署，那么这个设计就具有僵化性的臭味。因为调用send和recv的类必须要重新编译连接处理函数，部署的次数常常会超过我们希望的次数。在这种情况下，这两个职责应该被分离。如图下图所示，这样避免了客户应用程序和这两个职责耦合在一起。</p><p><img src="http://upload-images.jianshu.io/upload_images/1552955-9b698d76a5b9cabe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分离的Modem接口"></p><table><thead><tr><th style="text-align:center">注意</th></tr></thead><tbody><tr><td style="text-align:center">另一方面，如果应用程序的变化方式总是会导致两个职责同时变化，那么就不必分离他们，分离后会导致不必要的复杂性。</td></tr><tr><td style="text-align:center">此外还有个推论：变化的曲线是仅当变化实际发生时才具有真正的意义。如果没有征兆，那么去应用SRP，或者其他原则都是不明智的。</td></tr></tbody></table><h2 id="结论总结"><a href="#结论总结" class="headerlink" title="结论总结"></a>结论总结</h2><ul><li>SRP为最简单的原则，也是最难运用好的原则</li><li>软件设计真正要做的其实就是发现责任并把那些责任分离</li><li>其他原则都将能追溯到SRP</li><li>大道至简，只有不断在代码中运用才能真正体会其中的奥妙</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1]《敏捷软件开发：原则、模式与实践》第8章 单一职责原则<br>[2]<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">维基百科</a><br>[3]<a href="http://www.oschina.net/translate/how-i-explained-ood-to-my-wife?lang=chs&amp;page=1#" target="_blank" rel="noopener">我是怎样向妻子解释OOD的</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1552955-f8fcbe790d7f8cd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="面向对象设计" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Android studio</title>
    <link href="http://yoursite.com/2016/03/27/install-android-studio-linux/"/>
    <id>http://yoursite.com/2016/03/27/install-android-studio-linux/</id>
    <published>2016-03-26T23:13:00.000Z</published>
    <updated>2017-12-10T14:12:39.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装jdk"><a href="#1-安装jdk" class="headerlink" title="1.安装jdk"></a>1.安装jdk</h2><h3 id="①由于linux自带openjdk因此我就将openjdk卸载了装jdk1-7"><a href="#①由于linux自带openjdk因此我就将openjdk卸载了装jdk1-7" class="headerlink" title="①由于linux自带openjdk因此我就将openjdk卸载了装jdk1.7"></a>①由于linux自带openjdk因此我就将openjdk卸载了装jdk1.7</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove openjdk-*</span><br></pre></td></tr></table></figure><h3 id="②下载jdk1-7"><a href="#②下载jdk1-7" class="headerlink" title="②下载jdk1.7"></a>②下载jdk1.7</h3><p><a href="http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="noopener">jdk1.7下载链接</a><br>我下载的文件为：jdk-7u79-linux-x64.tar.gz</p><h3 id="③解压"><a href="#③解压" class="headerlink" title="③解压"></a>③解压</h3><ul><li><p>创建/usr/java目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /usr/java</span><br></pre></td></tr></table></figure></li><li><p>将当前目录下的jdk压缩包移/usr/java</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/下载 $ sudo mv jdk-7u79-linux-x64.tar.gz /usr/java</span><br></pre></td></tr></table></figure></li><li><p>解压到/usr/java，删除压缩包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/java</span><br><span class="line">$ sudo tar -zxvf /usr/java/jdk-7u79-linux-x64.tar.gz</span><br><span class="line">$ sudo rm jdk-7u79-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li></ul><h3 id="④配置jdk环境变量"><a href="#④配置jdk环境变量" class="headerlink" title="④配置jdk环境变量"></a>④配置jdk环境变量</h3><ul><li><p>打开环境变量配置文件profile</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gedit /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>在文本最后添加如下信息，注意改成自己的jdk版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/java/jdk1.7.0_79</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure></li><li><p>保存、重启、java -version验证是否配置成功</p></li></ul><h2 id="2-安装android-studio"><a href="#2-安装android-studio" class="headerlink" title="2.安装android studio"></a>2.安装android studio</h2><h3 id="①下载linux-android-studio"><a href="#①下载linux-android-studio" class="headerlink" title="①下载linux android studio"></a>①下载linux android studio</h3><p><a href="http://developer.android.com/intl/zh-cn/sdk/index.html" target="_blank" rel="noopener">官网下载</a></p><h3 id="②解压"><a href="#②解压" class="headerlink" title="②解压"></a>②解压</h3><p>将下载好的android studio压缩包移动到/usr/local目录，然后unzip命令解压<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip android-studio-ide-141.2456560-linux.zip</span><br></pre></td></tr></table></figure></p><h3 id="③运行"><a href="#③运行" class="headerlink" title="③运行"></a>③运行</h3><p>进入android-studio/bin,然后运行studio.sh<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> android-studio/bin</span><br><span class="line">$ sh studio.sh</span><br></pre></td></tr></table></figure></p><h3 id="④因为在linux-mint第一天已经修改hosts翻墙，所以就自动下载sdk和更新，节省操作咯！"><a href="#④因为在linux-mint第一天已经修改hosts翻墙，所以就自动下载sdk和更新，节省操作咯！" class="headerlink" title="④因为在linux mint第一天已经修改hosts翻墙，所以就自动下载sdk和更新，节省操作咯！"></a>④因为在linux mint第一天已经修改hosts翻墙，所以就自动下载sdk和更新，节省操作咯！</h3><h2 id="3-安装Genymotion"><a href="#3-安装Genymotion" class="headerlink" title="3.安装Genymotion"></a>3.安装Genymotion</h2><blockquote><p>Genymotion被称为是速度最快的Android模拟器可不是盖的，手机也没有两，就打算安装一个模拟器。</p></blockquote><h3 id="Genymotion官网"><a href="#Genymotion官网" class="headerlink" title="Genymotion官网"></a><a href="https://www.genymotion.com/" target="_blank" rel="noopener">Genymotion官网</a></h3><p>注册一个号，登录了就能下载免费版本的虚拟机。<a href="http://files2.genymotion.com/genymotion/genymotion-2.6.0/genymotion-2.6.0-linux_x64.bin" target="_blank" rel="noopener">我下载版本的连接地址</a></p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>根据这篇教程<a href="http://www.lihuan.com.cn/2015/02/15/521.html" target="_blank" rel="noopener">Ubuntu下安装Genymotion安卓模拟器 Linux教程</a></p><ul><li>将genymotion-2.6.0-ubuntu15_x64.bin移动到用户目录<code>$ mv genymotion-2.6.0-ubuntu15_x64.bin /home/jiana</code></li><li>需要安装一个软件virtualbox才能使用Gecymotion,命令:<code>sudo apt-get install virtualbox</code></li><li><p>进入/home/jiana运行genymotion文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/jiana/</span><br><span class="line">$ chmod +x genymotion-2.6.0-ubuntu15_x64.bin </span><br><span class="line">$ ./genymotion-2.6.0-ubuntu15_x64.bin</span><br></pre></td></tr></table></figure></li><li><p>完成后进入该用户目录下的genymotion目录，双击运行genymotion。好了，接下来就可以下载genymotion虚拟机来体验快感了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-安装jdk&quot;&gt;&lt;a href=&quot;#1-安装jdk&quot; class=&quot;headerlink&quot; title=&quot;1.安装jdk&quot;&gt;&lt;/a&gt;1.安装jdk&lt;/h2&gt;&lt;h3 id=&quot;①由于linux自带openjdk因此我就将openjdk卸载了装jdk1-7&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
