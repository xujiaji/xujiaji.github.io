<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐佳吉的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xujiaji.com/"/>
  <updated>2019-12-17T17:36:39.831Z</updated>
  <id>https://blog.xujiaji.com/</id>
  
  <author>
    <name>XuJiaji</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电大自考真题练习</title>
    <link href="https://blog.xujiaji.com/post/self-study-one/index.html"/>
    <id>https://blog.xujiaji.com/post/self-study-one/index.html</id>
    <published>2019-12-14T16:51:08.000Z</published>
    <updated>2019-12-17T17:36:39.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自考真题">自考真题<a href="post/self-study-one#自考真题"></a></h1><blockquote><p>历年真题完成进度表<br>有错误的地方各位小伙伴可以在该页面下方留言，或在QQ群联系我修改~</p></blockquote><div class="article-bounded"><div class="article-table"><table><thead><tr><th>试卷名</th><th>跳转浏览</th><th style="text-align:center">2016</th><th style="text-align:center">2017</th><th style="text-align:center">2018</th><th style="text-align:center">2019</th></tr></thead><tbody><tr><td>Java语言程序设计</td><td><a href="https://gitee.com/xujiaji/Source/raw/master/JAVA%E8%AF%AD%E8%A8%802016-2019%E7%9C%9F%E9%A2%98.pdf" target="_blank" rel="noopener">浏览文件&gt;&gt;</a></td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td></tr><tr><td>互联网及其应用</td><td><a href="https://gitee.com/xujiaji/Source/raw/master/%E4%BA%92%E8%81%94%E7%BD%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A82016-2019%20%E7%9C%9F%E9%A2%98.pdf" target="_blank" rel="noopener">浏览文件&gt;&gt;</a></td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✖️</td><td style="text-align:center">✖️</td></tr><tr><td>软件工程</td><td><a href="https://gitee.com/xujiaji/Source/raw/master/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B2016-2019%20%E7%9C%9F%E9%A2%98.pdf" target="_blank" rel="noopener">浏览文件&gt;&gt;</a></td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✖️</td><td style="text-align:center">✖️</td></tr><tr><td>网页设计与制作</td><td><a href="https://gitee.com/xujiaji/Source/raw/master/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%B6%E4%BD%9C2016-2019%E7%9C%9F%E9%A2%98.pdf" target="_blank" rel="noopener">浏览文件&gt;&gt;</a></td><td style="text-align:center">✔️</td><td style="text-align:center">✖️</td><td style="text-align:center">✖️</td><td style="text-align:center">✖️</td></tr><tr><td>C++程序设计</td><td><a href="https://gitee.com/xujiaji/Source/raw/master/C%2B%2B%E7%A8%8B%E5%BA%8F2016-2019%E7%9C%9F%E9%A2%98.pdf" target="_blank" rel="noopener">浏览文件&gt;&gt;</a></td><td style="text-align:center">✔️</td><td style="text-align:center">✖️</td><td style="text-align:center">✖️</td><td style="text-align:center">✖️</td></tr></tbody></table></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自考真题&quot;&gt;自考真题&lt;a href=&quot;post/self-study-one#自考真题&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;历年真题完成进度表&lt;br&gt;有错误的地方各位小伙伴可以在该页面下方留言，或在QQ群联系我修改~&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="自考" scheme="https://blog.xujiaji.com/categories/%E8%87%AA%E8%80%83/"/>
    
    
      <category term="自考" scheme="https://blog.xujiaji.com/tags/%E8%87%AA%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Flutter资源自动生成配置脚本</title>
    <link href="https://blog.xujiaji.com/post/flutter-assets-sync/index.html"/>
    <id>https://blog.xujiaji.com/post/flutter-assets-sync/index.html</id>
    <published>2019-11-27T09:36:09.000Z</published>
    <updated>2019-11-27T16:18:15.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter资源自动生成配置">Flutter资源自动生成配置<a href="post/flutter-assets-sync#Flutter资源自动生成配置"></a></h1><p>项目地址：<a href="https://github.com/xujiaji/FlutterAssetsSync/" target="_blank" rel="noopener">https://github.com/xujiaji/FlutterAssetsSync/</a></p><h2 id="简介">简介<a href="post/flutter-assets-sync#简介"></a></h2><p>各位小伙伴都知道flutter的资源配置需要在<code>pubspec.yaml</code>中配置资源路径。</p><p>我想吧！这么麻烦的事情因该有做贡献的同学提供插件吧！果不其然我找到一个叫<a href="https://github.com/Leo0618/flutter-img-sync" target="_blank" rel="noopener">flutter-img-sync</a>的插件，可以快速添加到配置中，并且生成一个类似android的R文件，方便快速准确的调用。</p><p>爽了几天，发现这个框架并不能满足了，首先每次生成资源会重新排序导致git版本合并代码都需要手动合并，其次生成的2.0x和3.0x是用的包含2.0x和3.0x的全路径名。</p><p>由于大佬插件代码不是开源的，于是想了想还是自己用python快速搞一个一样功能的出来吧，可以自己自定义，并且可以全方位满足自己需求！</p><h2 id="视频演示">视频演示<a href="post/flutter-assets-sync#视频演示"></a></h2><div style="width: 100%; display: inline-block; position: relative; padding-top: 70%; display: block; content: '';"><br>    <div style="position: absolute; top: 0; bottom: 0; right: 0; left: 0;"><br>    <iframe src="//player.bilibili.com/player.html?aid=77259024&cid=132151550&page=1" width="100%" height="100%" frameborder="0" allowfullscreen></iframe><br>    </div><br></div><h2 id="环境">环境<a href="post/flutter-assets-sync#环境"></a></h2><blockquote><p>安装了Python3.0+就行了</p></blockquote><h2 id="配置">配置<a href="post/flutter-assets-sync#配置"></a></h2><ol><li>在<code>pubspec.yaml</code>的<code>assets</code>处添加自动自动构建的位置区间</li></ol><blockquote><p>这个区间内不可添加其他资源，因为每次构建都会替换<code># assets-generator-begin</code>和<code># assets-generator-end</code>之间的内容</p></blockquote><figure class="highlight yaml"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">assets:</span></span><br><span class="line"><span class="comment"># assets-generator-begin</span></span><br><span class="line"><span class="comment"># assets-generator-end</span></span><br></pre></td></tr></table></div></figure><ol start="2"><li>接下了就是配置资源的目录了</li></ol><p>首先，在项目中假如说你的资源目录就如下所示是<code>assets</code><br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/flutter_pubspec/55813610-18E1-478F-BBFD-C24D4307F949.png" alt=""><br>那么，你需要在<code>assets_generator.py</code>（顶部进入项目地址下载哦）中配置对应的位置，如下所示：<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/flutter_pubspec/B8358DF2-32C5-4D24-B7DC-D6062B42AA31.png" alt=""></p><ol start="3"><li>把脚本<code>assets_generator.py</code>拷贝到您的项目根目录</li></ol><h2 id="使用">使用<a href="post/flutter-assets-sync#使用"></a></h2><p>在项目目录下打开命令行，运行<code>./assets_generator.py</code><br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/flutter_pubspec/1F3A4EDA-47F3-4236-9ED6-39076479FF7F.png" alt=""></p><p>此时会在<code>pubspec.yaml</code>配置的区域添加上路径<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/flutter_pubspec/21218262-4206-424D-A578-DE1A968BAE4B.png" alt=""></p><p>同时会生成一个<code>r.dart</code>的文件，内容如下：（篇幅原因就粘贴部分了）<br><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// ![](http://127.0.0.1:3333/assets/fonts/fzxz300.ttf)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> assetsFontsFzxz300 = <span class="string">'assets/fonts/fzxz300.ttf'</span>;</span><br><span class="line">  <span class="comment">/// ![](http://127.0.0.1:3333/assets/h5/index.html)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> assetsH5Index = <span class="string">'assets/h5/index.html'</span>;</span><br><span class="line">  <span class="comment">/// ![](http://127.0.0.1:3333/assets/h5/relationship.js)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> assetsH5Relationship = <span class="string">'assets/h5/relationship.js'</span>;</span><br><span class="line">  <span class="comment">/// ![](http://127.0.0.1:3333/assets/image/add_ico.png)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">String</span> assetsImageAddIco = <span class="string">'assets/image/add_ico.png'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p><p>在代码中使用非常方便只需要向下面这样，当然需要先导入<code>r.dart</code></p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image.asset(R.assetsImageMan)</span><br></pre></td></tr></table></div></figure><p>同时在选对应的图片时，也可以进行图片预览（如果你把那个python脚本终止了那就不能预览了）</p><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/flutter_pubspec/241D6239-21E2-4651-9840-576E094997C8.png" alt="" class="article-img"></p><blockquote><p>如果添加了新的图片，重新运行一下这个脚本就可以了</p></blockquote><h2 id="功能">功能<a href="post/flutter-assets-sync#功能"></a></h2><ol><li>自动在yaml文件中生成资源路径配置</li><li>自动在lib目录创建一个<code>r.dart</code>来管理资源调用</li><li>生成名字有序</li><li>通过<code>R.</code>对应资源可以进行预览</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter资源自动生成配置&quot;&gt;Flutter资源自动生成配置&lt;a href=&quot;post/flutter-assets-sync#Flutter资源自动生成配置&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/xuji
      
    
    </summary>
    
      <category term="Flutter" scheme="https://blog.xujiaji.com/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://blog.xujiaji.com/tags/Flutter/"/>
    
      <category term="工具" scheme="https://blog.xujiaji.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Python" scheme="https://blog.xujiaji.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>好用的iOS网络请求调试工具Bagel</title>
    <link href="https://blog.xujiaji.com/post/ios-bagel-use/index.html"/>
    <id>https://blog.xujiaji.com/post/ios-bagel-use/index.html</id>
    <published>2019-10-24T15:24:42.000Z</published>
    <updated>2019-10-27T05:50:26.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS网络请求调试神器使用">iOS网络请求调试神器使用<a href="post/ios-bagel-use#iOS网络请求调试神器使用"></a></h1><p>这是一个方便调试api的工具，只需要简单的配置即可方便的看到App中数据的请求</p><p>Bagel: <a href="https://github.com/yagiz/Bagel/" target="_blank" rel="noopener">https://github.com/yagiz/Bagel/</a></p><h2 id="视频演示">视频演示<a href="post/ios-bagel-use#视频演示"></a></h2><div style="width: 100%; display: inline-block; position: relative; padding-top: 70%; display: block; content: '';"><br>    <div style="position: absolute; top: 0; bottom: 0; right: 0; left: 0;"><br>    <iframe src="//player.bilibili.com/player.html?aid=73544560&cid=125799021&page=1" width="100%" height="100%" frameborder="0" allowfullscreen></iframe><br>    </div><br></div><h2 id="安装Mac应用">安装Mac应用<a href="post/ios-bagel-use#安装Mac应用"></a></h2><p>通过下载源码运行得到一个mac上面运行的程序</p><ol><li><p>下载源码</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yagiz/Bagel.git</span><br></pre></td></tr></table></div></figure></li><li><p>安装对应的依赖库<code>pod install</code></p></li><li>编译运行项目</li></ol><h2 id="配置项目">配置项目<a href="post/ios-bagel-use#配置项目"></a></h2><ol><li><p>为项目添加依赖，这里展示的是podfile的配置方式。在Podfile中添加</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod 'Bagel', '~&gt;  1.3.2'</span><br></pre></td></tr></table></div></figure></li><li><p>下载Bagel库<code>pod install</code></p></li></ol><h2 id="使用">使用<a href="post/ios-bagel-use#使用"></a></h2><ol><li>导入Bagel模块<code>import Bagel</code></li><li>开启Bagel<code>Bagel.start()</code><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只在debug的模式下才开启网络监听</span></span><br><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"><span class="type">Bagel</span>.start()</span><br><span class="line">#endif</span><br></pre></td></tr></table></div></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS网络请求调试神器使用&quot;&gt;iOS网络请求调试神器使用&lt;a href=&quot;post/ios-bagel-use#iOS网络请求调试神器使用&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;这是一个方便调试api的工具，只需要简单的配置即可方便的看到App中数据的请求&lt;/p&gt;
&lt;p&gt;Ba
      
    
    </summary>
    
      <category term="工具" scheme="https://blog.xujiaji.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://blog.xujiaji.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="iOS" scheme="https://blog.xujiaji.com/tags/iOS/"/>
    
      <category term="Debug" scheme="https://blog.xujiaji.com/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg 使用小记</title>
    <link href="https://blog.xujiaji.com/post/ffmpeg-note/index.html"/>
    <id>https://blog.xujiaji.com/post/ffmpeg-note/index.html</id>
    <published>2019-10-16T14:54:28.000Z</published>
    <updated>2019-10-27T05:49:28.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ffmpeg-使用小记">ffmpeg 使用小记<a href="post/ffmpeg-note#ffmpeg-使用小记"></a></h1><h2 id="合并两个视屏文件">合并两个视屏文件<a href="post/ffmpeg-note#合并两个视屏文件"></a></h2><p>合并<code>1.mp4</code>和<code>2.mp4</code></p><blockquote><p>将mp4转化为同样编码形式的ts溜，因为ts是可以concate的<br>然后concate ts流<br>最后再把ts流转为mp4</p></blockquote><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 1.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 1.ts</span><br><span class="line">ffmpeg -i 2.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 2.ts</span><br><span class="line">ffmpeg -i "concat:1.ts|2.ts" -acodec copy -vcodec copy -absf aac_adtstoasc output.mp4</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ffmpeg-使用小记&quot;&gt;ffmpeg 使用小记&lt;a href=&quot;post/ffmpeg-note#ffmpeg-使用小记&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;合并两个视屏文件&quot;&gt;合并两个视屏文件&lt;a href=&quot;post/ffmpeg-note#合并两个视屏文件
      
    
    </summary>
    
      <category term="工具" scheme="https://blog.xujiaji.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="笔记" scheme="https://blog.xujiaji.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="FFMPEG" scheme="https://blog.xujiaji.com/tags/FFMPEG/"/>
    
  </entry>
  
  <entry>
    <title>好用的iOS调试工具PonyDebugger</title>
    <link href="https://blog.xujiaji.com/post/ios-ponydebuger/index.html"/>
    <id>https://blog.xujiaji.com/post/ios-ponydebuger/index.html</id>
    <published>2019-10-15T15:38:02.000Z</published>
    <updated>2019-11-27T16:26:36.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="好用的iOS调试工具PonyDebugger">好用的iOS调试工具PonyDebugger<a href="post/ios-ponydebuger#好用的iOS调试工具PonyDebugger"></a></h1><p>PonyDebugger：<a href="https://github.com/square/PonyDebugger/" target="_blank" rel="noopener">https://github.com/square/PonyDebugger/</a></p><h2 id="简介">简介<a href="post/ios-ponydebuger#简介"></a></h2><p>PoneyDebugger是一个很给力的调试工具，它能通过浏览器调试App。</p><p>需要电脑上配置服务环境，在iOS项目添加sdk的配置。便可以对App进行网络请求监控、Core Data数据查看、查看当前界面UI层级等。</p><h3 id="网络请求调试">网络请求调试<a href="post/ios-ponydebuger#网络请求调试"></a></h3><p>我们的请求会通过PonyDebugger的代理服务<a href="https://github.com/square/PonyDebugger/tree/master/ponyd" target="_blank" rel="noopener">ponyd</a>，可以直观的像在浏览器上调试网页请求一样，调试App的请求。</p><blockquote><p>我就直接把官方的图搬运过来用了<code>^_^</code></p></blockquote><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/poneydebugger/NetworkDebugging.png" alt="NetworkDebugging" class="article-img"></p><h3 id="Core-Data-浏览">Core Data 浏览<a href="post/ios-ponydebuger#Core-Data-浏览"></a></h3><p>Core Data浏览，只需要通过在应用程序的代码中启用就可以了<code>ponyDebugger?.enableCoreDataDebugging()</code></p><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/poneydebugger/CoreDataBrowser.png" alt="CoreDataBrowser" class="article-img"></p><h3 id="视图层次调试">视图层次调试<a href="post/ios-ponydebuger#视图层次调试"></a></h3><p>PonyDebugger会在浏览器中以XML的方式展示应用视图层次结构，并且可以在其中看到视图元素的属性。在面板中选中一个元素时，对应手机上也会被选中。当删除一个时也对应删除，可调整视图大小。</p><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/poneydebugger/ViewHierarchyDebugging.png" alt="ViewHierarchyDebugging" class="article-img"></p><h2 id="远程日志">远程日志<a href="post/ios-ponydebuger#远程日志"></a></h2><p>PonyDebuggert通过PDLog和PDLogObjects函数远程记录日志查看对象数据</p><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/poneydebugger/RemoteLogging.png" alt="RemoteLogging" class="article-img"></p><h2 id="安装视频演示">安装视频演示<a href="post/ios-ponydebuger#安装视频演示"></a></h2><div style="width: 100%; display: inline-block; position: relative; padding-top: 70%; display: block; content: '';"><br>    <div style="position: absolute; top: 0; bottom: 0; right: 0; left: 0;"><br>    <iframe src="//player.bilibili.com/player.html?aid=71370834&cid=123663162&page=1" width="100%" height="100%" frameborder="0" allowfullscreen></iframe><br>    </div><br></div><h2 id="创建一个目录ponyd，并进去该目录">创建一个目录<code>ponyd</code>，并进去该目录<a href="post/ios-ponydebuger#创建一个目录ponyd，并进去该目录"></a></h2><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ponyd</span><br><span class="line">cd ponyd</span><br></pre></td></tr></table></div></figure><h2 id="将必要的依赖下载这个目录中ponyd">将必要的依赖下载这个目录中<code>ponyd</code><a href="post/ios-ponydebuger#将必要的依赖下载这个目录中ponyd"></a></h2><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -O -L https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz</span><br><span class="line"></span><br><span class="line">curl -O -L https://pypi.python.org/packages/25/5d/cc55d39ac39383dd6e04ae80501b9af3cc455be64740ad68a4e12ec81b00/setuptools-0.6c11-py2.7.egg</span><br><span class="line"></span><br><span class="line">curl -O -L https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/pybonjour/pybonjour-1.1.1.tar.gz</span><br><span class="line"></span><br><span class="line">tar xvf pybonjour-1.1.1.tar.gz</span><br><span class="line">mv pybonjour-1.1.1 pybonjour</span><br></pre></td></tr></table></div></figure><h2 id="下载bootstrap-ponyd-py">下载<code>bootstrap-ponyd.py</code><a href="post/ios-ponydebuger#下载bootstrap-ponyd-py"></a></h2><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O -L https://github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py</span><br></pre></td></tr></table></div></figure><h2 id="在bootstrap-ponyd-py添加安装pybonjour的命令">在<code>bootstrap-ponyd.py</code>添加安装<code>pybonjour</code>的命令<a href="post/ios-ponydebuger#在bootstrap-ponyd-py添加安装pybonjour的命令"></a></h2><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.check_call([join(home_dir, 'bin', 'python'),  join('pybonjour', 'setup.py'), 'install'])</span><br></pre></td></tr></table></div></figure><blockquote><p>添加在如下的位置上</p></blockquote><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def after_install(options, home_dir):</span><br><span class="line">    subprocess.check_call([join(home_dir, 'bin', 'python'),  join('pybonjour', 'setup.py'), 'install'])</span><br><span class="line"></span><br><span class="line">    subprocess.check_call([join(home_dir, 'bin', 'pip'),</span><br><span class="line">                     'install', '-U', '-e', 'git+https://github.com/square/PonyDebugger.git#egg=ponydebugger'])</span><br></pre></td></tr></table></div></figure><h2 id="通过运行bootstrap安装">通过运行bootstrap安装<a href="post/ios-ponydebuger#通过运行bootstrap安装"></a></h2><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ./bootstrap-ponyd.py | python - --never-download --ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger</span><br></pre></td></tr></table></div></figure><h2 id="上面的安装会出错，因为一些包无法找到，我们通过下面的命令去修复">上面的安装会出错，因为一些包无法找到，我们通过下面的命令去修复<a href="post/ios-ponydebuger#上面的安装会出错，因为一些包无法找到，我们通过下面的命令去修复"></a></h2><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/Library/PonyDebugger/bin/easy_install --find-links https://pypi.python.org/simple/singledispatch/ -U singledispatch</span><br><span class="line">~/Library/PonyDebugger/bin/easy_install --find-links https://pypi.python.org/simple/backports-abc/ -U backports_abc</span><br><span class="line">~/Library/PonyDebugger/bin/easy_install --find-links https://pypi.python.org/simple/certifi -U certifi</span><br><span class="line">~/Library/PonyDebugger/bin/easy_install --find-links https://pypi.python.org/simple/six/ -U six</span><br><span class="line">~/Library/PonyDebugger/bin/easy_install --find-links https://pypi.python.org/simple/futures -U futures</span><br><span class="line">sudo ~/Library/PonyDebugger/bin/easy_install -U pybonjour</span><br></pre></td></tr></table></div></figure><h2 id="安装devtools">安装devtools<a href="post/ios-ponydebuger#安装devtools"></a></h2><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ponyd update-devtools</span><br></pre></td></tr></table></div></figure><h2 id="运行">运行<a href="post/ios-ponydebuger#运行"></a></h2><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ponyd serve --listen-interface=127.0.0.1</span><br></pre></td></tr></table></div></figure><h2 id="配置iOS-sdk">配置iOS sdk<a href="post/ios-ponydebuger#配置iOS-sdk"></a></h2><blockquote><p>下面演示的是通过pod安装的</p></blockquote><ol><li>在项目Podfile中引入<code>pod &#39;PonyDebugger&#39;</code></li><li>打开一个在项目目录的命令窗口，运行<code>pod install</code></li><li>swift项目，需要在连接桥文件中导入头文件，<code>#import &lt;PonyDebugger/PonyDebugger.h&gt;</code></li><li>添加sdk配置：<figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ponyDebugger = <span class="type">PDDebugger</span>.defaultInstance()</span><br><span class="line">ponyDebugger?.enableNetworkTrafficDebugging()</span><br><span class="line">ponyDebugger?.enableViewHierarchyDebugging()</span><br><span class="line">ponyDebugger?.setDisplayedViewAttributeKeyPaths([<span class="string">"frame"</span>, <span class="string">"hidden"</span>, <span class="string">"alpha"</span>])</span><br><span class="line">ponyDebugger?.forwardAllNetworkTraffic()</span><br><span class="line">ponyDebugger?.enableCoreDataDebugging()</span><br><span class="line">ponyDebugger?.enableRemoteLogging()</span><br><span class="line">ponyDebugger?.connect(to: <span class="type">URL</span>(string: <span class="string">"ws://localhost:9000/device"</span>))</span><br></pre></td></tr></table></div></figure></li></ol><h2 id="打开调试网页">打开调试网页<a href="post/ios-ponydebuger#打开调试网页"></a></h2><p><a href="http://localhost:9000/" target="_blank" rel="noopener">http://localhost:9000/</a></p><h2 id="结束">结束<a href="post/ios-ponydebuger#结束"></a></h2><p>这里主要还是演示了一些怎么安装配置的PonyDebugger，因为在这里遇到些问题所以在此记录一波。谢谢观看！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;好用的iOS调试工具PonyDebugger&quot;&gt;好用的iOS调试工具PonyDebugger&lt;a href=&quot;post/ios-ponydebuger#好用的iOS调试工具PonyDebugger&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;PonyDebugger：&lt;a href
      
    
    </summary>
    
      <category term="工具" scheme="https://blog.xujiaji.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="iOS" scheme="https://blog.xujiaji.com/tags/iOS/"/>
    
      <category term="Debug" scheme="https://blog.xujiaji.com/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>安装Gitlab小记</title>
    <link href="https://blog.xujiaji.com/post/linux-gitlab/index.html"/>
    <id>https://blog.xujiaji.com/post/linux-gitlab/index.html</id>
    <published>2019-09-24T12:49:42.000Z</published>
    <updated>2019-11-27T13:40:17.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Gitlab小记">安装Gitlab小记<a href="post/linux-gitlab#安装Gitlab小记"></a></h1><blockquote><p>环境：CentOS7.6、外部Nginx</p></blockquote><h2 id="做了些什么？">做了些什么？<a href="post/linux-gitlab#做了些什么？"></a></h2><ol><li>安装gitlab</li><li>配置发送邮箱（用来验证账号修改密码）</li><li>外置nginx配置（https）</li><li>汉化</li><li>CI Pipelines安装</li></ol><h2 id="安装Gitlab">安装Gitlab<a href="post/linux-gitlab#安装Gitlab"></a></h2><p>安装配合依赖（其实这里都是官网的安装说文档，我就直接搬运过来了）</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y curl policycoreutils-python openssh-server</span><br><span class="line">sudo systemctl enable sshd</span><br><span class="line">sudo systemctl start sshd</span><br><span class="line"></span><br><span class="line">sudo firewall-cmd --permanent --add-service=http</span><br><span class="line">sudo firewall-cmd --permanent --add-service=https</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></div></figure><p>添加Gitlab仓库</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></div></figure><p>安装Gitlab，这里的<code>EXTERNAL_URL</code>换成自己的域名</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo EXTERNAL_URL="https://gitlab.example.com" yum install -y gitlab-ee</span><br></pre></td></tr></table></div></figure><h2 id="配置邮箱（不配置可以跳过这个步骤）">配置邮箱（不配置可以跳过这个步骤）<a href="post/linux-gitlab#配置邮箱（不配置可以跳过这个步骤）"></a></h2><p>打开配置文件，添加邮箱配置。</p><p>这里以qq邮箱来举栗子（因为我配置的qq邮箱😆），其他都差不多类似。</p><p>注意需要在邮箱设置中开启smtp服务</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></div></figure><blockquote><p>直接在文件中添加下方配置</p></blockquote><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails['smtp_enable'] = true</span><br><span class="line">gitlab_rails['smtp_address'] = "smtp.qq.com"</span><br><span class="line">gitlab_rails['smtp_port'] = 465</span><br><span class="line">gitlab_rails['smtp_user_name'] = "邮箱名@qq.com"</span><br><span class="line">gitlab_rails['smtp_password'] = "dtjhinszpsasdhi"</span><br><span class="line">gitlab_rails['smtp_domain'] = "smtp.qq.com"</span><br><span class="line">gitlab_rails['smtp_authentication'] = "login"</span><br><span class="line">gitlab_rails['smtp_enable_starttls_auto'] = true</span><br><span class="line">gitlab_rails['smtp_tls'] = true</span><br></pre></td></tr></table></div></figure><div class="article-bounded"><div class="article-table"><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><code>smtp_enable</code></td><td>启用smtp</td></tr><tr><td><code>smtp_address</code></td><td>smtp.qq.com是qq的smtp服务器，根据自己的情况更换</td></tr><tr><td><code>smtp_user_name</code></td><td>是你要用来让gitlab发送的邮箱</td></tr><tr><td><code>smtp_password</code></td><td>是邮箱的登录密码（QQ的是在设置中生成的第三方登录密码）</td></tr><tr><td><code>smtp_tls</code></td><td>开启tls加密</td></tr></tbody></table></div></div><p>配置邮箱来源，与展示的名称</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails['gitlab_email_enabled'] = true</span><br><span class="line">gitlab_rails['gitlab_email_from'] = '邮箱名@qq.com'</span><br><span class="line">gitlab_rails['gitlab_email_display_name'] = '发送邮件的默认标题'</span><br></pre></td></tr></table></div></figure><h2 id="外置nginx配置">外置nginx配置<a href="post/linux-gitlab#外置nginx配置"></a></h2><h3 id="关闭Gilab内部nginx和一些其他配置">关闭Gilab内部nginx和一些其他配置<a href="post/linux-gitlab#关闭Gilab内部nginx和一些其他配置"></a></h3><p>打开配置文件</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></div></figure><p>添加如下配置</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">external_url 'https://git.longpuji.com'</span><br><span class="line"></span><br><span class="line">gitlab_workhorse['enable'] = true</span><br><span class="line">gitlab_workhorse['listen_network'] = "tcp"</span><br><span class="line">gitlab_workhorse['listen_addr'] = "127.0.0.1:8181"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This example renews every 7th day at 12:30</span></span><br><span class="line">letsencrypt['auto_renew_hour'] = "12"</span><br><span class="line">letsencrypt['auto_renew_minute'] = "30"</span><br><span class="line">letsencrypt['auto_renew_day_of_month'] = "*/7"</span><br><span class="line"></span><br><span class="line">nginx['enable'] = false</span><br></pre></td></tr></table></div></figure><div class="article-bounded"><div class="article-table"><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><code>external_url</code></td><td>外部的url使用的url，如果不配置会导致有些链接不正常</td></tr><tr><td><code>gitlab_workhorse[&#39;enable&#39;]</code></td><td>开启gitlab工作空间配置</td></tr><tr><td><code>gitlab_workhorse[&#39;listen_network&#39;]</code></td><td>tcp网络协议</td></tr><tr><td><code>gitlab_workhorse[&#39;listen_addr&#39;]</code></td><td><code>127.0.0.1:8181</code>（一会儿nginx反向代理的时候就用这个端口号）</td></tr><tr><td><code>nginx[&#39;enable&#39;]</code></td><td>关闭Gitlab内部nginx</td></tr></tbody></table></div></div><h3 id="为外部nginx反向代理配置">为外部nginx反向代理配置<a href="post/linux-gitlab#为外部nginx反向代理配置"></a></h3><p>配置如下</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">location /</span><br><span class="line">&#123;</span><br><span class="line">    expires 12h;</span><br><span class="line">    if ($request_uri ~* "(php|jsp|cgi|asp|aspx)")</span><br><span class="line">    &#123;</span><br><span class="line">         expires 0;</span><br><span class="line">    &#125;</span><br><span class="line">    # 这个就是上面设置的gitlab_workhorse['listen_addr']</span><br><span class="line">    proxy_pass http://127.0.0.1:8181;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">    # 注意如果是域名配置了ssl，那么则必须加上这个配置，不然gitlab会在重置密码的时候报错422</span><br><span class="line">    proxy_set_header X-Forwarded-Proto https;</span><br><span class="line">    proxy_set_header X-Forwarded-Ssl on;</span><br><span class="line"></span><br><span class="line">    proxy_read_timeout                  900;</span><br><span class="line">    proxy_cache off;</span><br><span class="line">    proxy_buffering off;</span><br><span class="line">    proxy_request_buffering off;</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line"></span><br><span class="line">    add_header X-Cache $upstream_cache_status;</span><br><span class="line">    add_header Cache-Control no-cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="启动">启动<a href="post/linux-gitlab#启动"></a></h2><blockquote><p>上面的那些基本上Gitlab就已经配置好啦，现在需要对Gitlab重新加载配置和重启</p></blockquote><p>重载配置</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></div></figure><p>重启服务</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></div></figure><p>到这里可以打开域名链接去看看，没有啥问题就可以正常使用，第一次进入的时候需要设置初始密码。<br>初始的账号是<code>root</code><br>去登陆试试吧</p><h2 id="汉化">汉化<a href="post/linux-gitlab#汉化"></a></h2><p>查看当前版本</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</span><br></pre></td></tr></table></div></figure><p>输出</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12.3.0-ee</span><br></pre></td></tr></table></div></figure><blockquote><p>由于汉化现在还没有支持到这么高的版本，于是这里以v12.2.4的版本汉化的。（大部分都没有被汉化😅，之后如果该仓库更新的对应版本可以再次尝试）</p></blockquote><p>clone汉化项目</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.com/xhang/gitlab.git</span><br></pre></td></tr></table></div></figure><p>进入仓库</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd gitlab</span><br></pre></td></tr></table></div></figure><p>备份<code>gitlab-rails</code>到当前目录（如果之后出现问题，方便恢复）</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rf /opt/gitlab/embedded/service/gitlab-rails/ .</span><br></pre></td></tr></table></div></figure><p>生成12.2.4版本的汉化补丁</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff v12.2.4 v12.2.4-zh &gt; ./12.2.4-zh.diff</span><br></pre></td></tr></table></div></figure><p>关闭gitlab服务</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop</span><br></pre></td></tr></table></div></figure><p>打汉化补丁</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -d /opt/gitlab/embedded/service/gitlab-rails/ -p1 &lt; ./12.2.4-zh.diff</span><br></pre></td></tr></table></div></figure><blockquote><p>这里有些汉化文件没有对应到的文件，直接回车，yes跳过就可以了</p></blockquote><p>启动服务</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl start</span><br></pre></td></tr></table></div></figure><h2 id="CI-Pipelines安装">CI Pipelines安装<a href="post/linux-gitlab#CI-Pipelines安装"></a></h2><p>这篇文件不错，我就不啰嗦了哈哈</p><p><a href="https://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/" target="_blank" rel="noopener">https://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/</a></p><h2 id="命令文件整理">命令文件整理<a href="post/linux-gitlab#命令文件整理"></a></h2><blockquote><p>命令整理</p></blockquote><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>gitlab-ctl reconfigure</code></td><td>重载gitlab配置</td></tr><tr><td><code>gitlab-ctl restart</code></td><td>重启gitlab</td></tr><tr><td><code>gitlab-ctl stop</code></td><td>停止gitlab服务</td></tr><tr><td><code>gitlab-ctl start</code></td><td>启动gitlab服务</td></tr></tbody></table></div></div><blockquote><p>文件说明</p></blockquote><div class="article-bounded"><div class="article-table"><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td><code>/etc/gitlab/gitlab.rb</code></td><td>gitlab配置文件</td></tr><tr><td><code>/var/log/gitlab/gitlab-rails/production.log</code></td><td>gitlab-rails日志文件</td></tr></tbody></table></div></div><h2 id="备份">备份<a href="post/linux-gitlab#备份"></a></h2><p>备份命令</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></div></figure><p>安装同版本gitlab</p><p>从其他服务器拷贝到当前服务器</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp root@172.28.17.155:/var/opt/gitlab/backups/1502357536_2017_08_10_9.4.3_gitlab_backup.tar /var/opt/gitlab/backups/</span><br></pre></td></tr></table></div></figure><p>余下步骤参阅：<a href="https://blog.csdn.net/ouyang_peng/article/details/77070977" target="_blank" rel="noopener">https://blog.csdn.net/ouyang_peng/article/details/77070977</a></p><h3 id="恢复备份后ci-500错误问题">恢复备份后ci 500错误问题<a href="post/linux-gitlab#恢复备份后ci-500错误问题"></a></h3><p>Rails console</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-rails console</span><br></pre></td></tr></table></div></figure><p>重置token</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Project.find_by_full_path('root/my-project').update(runners_token: nil, runners_token_encrypted:nil)</span><br><span class="line">ApplicationSetting.current.reset_runners_registration_token!</span><br></pre></td></tr></table></div></figure><p>DB Console</p><figure class="highlight shell"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-psql -d gitlabhq_production</span><br></pre></td></tr></table></div></figure><p>查看数据库信息</p><figure class="highlight sql"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,runners_token,runners_token_encrypted <span class="keyword">from</span> projects;</span><br></pre></td></tr></table></div></figure><p>重置数据token</p><figure class="highlight sql"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> projects <span class="keyword">SET</span> runners_token = <span class="literal">null</span>, runners_token_encrypted = <span class="literal">null</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">28</span>;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装Gitlab小记&quot;&gt;安装Gitlab小记&lt;a href=&quot;post/linux-gitlab#安装Gitlab小记&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;环境：CentOS7.6、外部Nginx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=
      
    
    </summary>
    
    
      <category term="Git" scheme="https://blog.xujiaji.com/tags/Git/"/>
    
      <category term="Linux" scheme="https://blog.xujiaji.com/tags/Linux/"/>
    
      <category term="CentOS" scheme="https://blog.xujiaji.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Dart学习笔记</title>
    <link href="https://blog.xujiaji.com/post/Note-Learn-Dart/index.html"/>
    <id>https://blog.xujiaji.com/post/Note-Learn-Dart/index.html</id>
    <published>2019-03-29T08:45:28.000Z</published>
    <updated>2019-10-27T05:51:23.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dart笔记">Dart笔记<a href="post/Note-Learn-Dart#Dart笔记"></a></h1><h2 id="变量">变量<a href="post/Note-Learn-Dart#变量"></a></h2><p>初始化一个变量</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></div></figure><p><code>name</code>将自动判断为<code>String</code>类型，如果不想让其限制为了一个类型可以使用<code>Object</code>或<code>dynamic</code>类型。<code>Object</code>类型和java中差不多是一个道理。</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> name = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></div></figure><p>如果想明确显示声明类型：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></div></figure><h2 id="默认值">默认值<a href="post/Note-Learn-Dart#默认值"></a></h2><p>dart中未初始化的值都是null，即使是数字也是一个对象。</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> lineCount;</span><br><span class="line"><span class="built_in">print</span>(lineCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">//: null</span></span><br></pre></td></tr></table></div></figure><h2 id="fianl-和-const">fianl 和 const<a href="post/Note-Learn-Dart#fianl-和-const"></a></h2><p>当你不想让变量可以再次改变的时候用<code>final</code>或<code>const</code>修饰，如下：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>; <span class="comment">// 或者： final String name = 'Bob'; const name = 'Bob';</span></span><br></pre></td></tr></table></div></figure><p>此时name的值不可以在修改！</p><p>二者的区别是，<code>const</code>是编译时期常量，意思是说在编译后就有确切的值。</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下表达式可以正常运行，但是将bar变量前面的修饰词const换掉，那么就会报错。去掉就代表了bar的值在编译时的不确定性。</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="number">1000000</span>;</span><br><span class="line"><span class="comment">// 如果atm前面的修饰const换成final后，即使bar是变量也是无所谓了</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> atm = <span class="number">1.01325</span> * bar;</span><br></pre></td></tr></table></div></figure><p><code>const</code>关键字还可以用来修饰值</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> [];</span><br><span class="line"><span class="keyword">final</span> bar = [];</span><br><span class="line"><span class="keyword">const</span> baz = [];</span><br></pre></td></tr></table></div></figure><p>此时<code>foo</code>是变量，值是常量。意思是<code>foo</code>还可以引用其他同类型的值，<code>foo = [1, 2, 3];</code>是莫得问题的。但是如果让值<code>const []</code>改变就不行了<del><code>foo.add(1);</code></del></p><p><code>bar</code>变量虽然无法改变引用，但是值是可以改变的。<code>bar.add(1);</code>是OK的，但是 <del><code>bar = [1];</code></del> 是NO。</p><p><code>baz</code>，上面两样都没得玩！</p><p>如果<code>const</code>的变量是类一个级别的，这样声明：<code>static const</code></p><h2 id="内置类型">内置类型<a href="post/Note-Learn-Dart#内置类型"></a></h2><p>以下类型是<code>Dart</code>中特殊支持的类型</p><ul><li><code>数字 numbers</code></li><li><code>字符串 strings</code></li><li><code>布尔 booleans</code></li><li><code>列表 lists</code>(也称为数组)</li><li><code>集合 sets</code></li><li><code>映射 maps</code></li><li><code>符文 runes</code>(用于在字符串中表示Unicode字符)</li><li><code>符号 symbols</code></li></ul><p>您可以使用字面文字初始化一些特别的类型对象，例如<code>&#39;this is a string&#39;</code>是一个string对象，<code>true</code>是一个boolean对象。</p><p>因为在Dart中每个变量都引用了一个对象（一个类的实例），您可以使用构造方法初始化变量，有些内置类型有它们自己的构造函数。例如，您可以使用<code>Map()</code>构造来创建一个map实例。</p><h3 id="数字-Numbers">数字 Numbers<a href="post/Note-Learn-Dart#数字-Numbers"></a></h3><p>Dart有两种方式表示数字</p><p><strong><a href="https://api.dartlang.org/stable/2.2.0/dart-core/int-class.html" target="_blank" rel="noopener">int</a></strong></p><p>整型最大不超过64bit，并依赖于平台。在Dart虚拟机上，值取值范围<code>[-2^63,2^63 - 1]</code>。编译为JavaScript时使用<a href="https://stackoverflow.com/questions/2802957/number-of-bits-in-javascript-numbers/2803010#2803010" target="_blank" rel="noopener">JavaScript数字</a>，区间范围为<code>[-2^53,2^53-1]</code>。</p><p><strong><a href="https://stackoverflow.com/questions/2802957/number-of-bits-in-javascript-numbers/2803010#2803010" target="_blank" rel="noopener">double</a></strong></p><p>64bit（双精度）浮点数由IEEE 754标准规定</p><p><code>int</code>和<code>double</code>都是<a href="https://api.dartlang.org/stable/dart-core/num-class.html" target="_blank" rel="noopener">num</a>的子类型，在<code>num</code>类型中包含了<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>基本运算符，在其他方法中您也可以找到<code>abs()</code>,<code>ceil()</code>,<code>floor()</code>。（位运算符，如<code>&gt;&gt;</code>，定义在<code>int</code>类）如果<code>num</code>和其子类没有您想要的，<a href="https://api.dartlang.org/stable/dart-math" target="_blank" rel="noopener">dart:math</a>类库中可能有。</p><p>字符串和数字互转</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="built_in">int</span>.parse(<span class="string">'1'</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="built_in">double</span>.parse(<span class="string">'1.1'</span>); <span class="comment">// 1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="number">1.</span>toString(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// double -&gt; String 保留两位小数，四舍五入</span></span><br><span class="line"><span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>); <span class="comment">// 1.14</span></span><br></pre></td></tr></table></div></figure><h3 id="字符串-Strings">字符串 Strings<a href="post/Note-Learn-Dart#字符串-Strings"></a></h3><p>Dart字符串是一系列UTF-16代码单元，您可以使用单引号或双引号创建一个字符串：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单引号可以表示</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">'single quotes string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双引号也可以表示</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"double quotes strings"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单引号表示时，里面有单引号需要转义</span></span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">'i\'m a cool boy'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双引号表示时，里面有单引号不需要转义</span></span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">"i'm a cool boy"</span>;</span><br></pre></td></tr></table></div></figure><p>可以将表达式放在字符串里面通过<code>${expression}</code>的形式，表达式只是变量时，您可以不要<code>{}</code>。如果是一个对象时Dart会通过调用<code>toString()</code>方法获取这对象的字符串。</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="string">'bc'</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'a<span class="subst">$v<span class="string">'); // abc</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">print('</span></span>A<span class="subst">$&#123;v.toUpperCase()&#125;</span>'</span>); <span class="comment">// ABC</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$Set</span>()'</span>); <span class="comment">// Set&lt;dynamic&gt;()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;Set().toString()&#125;</span>'</span>); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></div></figure><p>相邻的字符串会自己拼接或通过<code>+</code>号拼接</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'1'</span></span><br><span class="line">  <span class="string">'2'</span></span><br><span class="line">  <span class="string">"3"</span></span><br><span class="line">  <span class="string">'4'</span>;</span><br><span class="line"><span class="built_in">print</span>(a); <span class="comment">// 1234</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'1'</span> + <span class="string">'2'</span> + <span class="string">"3"</span>;</span><br><span class="line"><span class="built_in">print</span>(b); <span class="comment">// 123</span></span><br></pre></td></tr></table></div></figure><p>可以使用三倍的单引号或双引号创建多行字符串：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 =</span><br><span class="line">  <span class="string">'''</span></span><br><span class="line"><span class="string">  1</span></span><br><span class="line"><span class="string">    2\n3</span></span><br><span class="line"><span class="string">  '''</span>;</span><br><span class="line"><span class="built_in">print</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是输出，试了下双引号单引号效果一样</span></span><br><span class="line"><span class="comment">//    1</span></span><br><span class="line"><span class="comment">//      2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></div></figure><p>您可以在引号前面加<code>r</code>表示字符串是原始(raw)类型：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r'a\nb'</span>); <span class="comment">// a\nb</span></span><br></pre></td></tr></table></div></figure><p>是什么就输出什么，不需要转义，单引号双引号三倍引号都可以用。</p><p>有关字符串中表达Unicode字符的详细信息，请参阅<a href="https://www.dartlang.org/guides/language/language-tour#runes" target="_blank" rel="noopener">字符 Runes</a></p><p>字符串文字是一个编译期常量</p><p>更多字符串使用信息，请参阅<a href="https://www.dartlang.org/guides/libraries/library-tour#strings-and-regular-expressions" target="_blank" rel="noopener">字符串和正则表达式</a></p><h3 id="布尔-Booleans">布尔 Booleans<a href="post/Note-Learn-Dart#布尔-Booleans"></a></h3><p>Dart用类型<code>bool</code>表示布尔值。只有两个对象表示<code>bool</code>类型：<code>true</code>和<code>false</code>，它们的文字表达都是编译时期常量。</p><p>Dart是类型安全的，意味着您不能使用像<code>if (非布尔值)</code>或<code>assert(非布尔值)</code>的代码。取而代之的是明确指出布尔值，如下：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查空字符串</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">assert</span>(fullName.isEmpty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查0</span></span><br><span class="line"><span class="keyword">var</span> hitPoints = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(hitPoints &lt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查null</span></span><br><span class="line"><span class="keyword">var</span> unicorn;</span><br><span class="line"><span class="keyword">assert</span>(unicorn == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 NaN （Not a Number 不是一个数）</span></span><br><span class="line"><span class="keyword">var</span> iMeantToDoThis = <span class="number">0</span> / <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(iMeantToDoThis.isNaN);</span><br></pre></td></tr></table></div></figure><h3 id="列表-Lists">列表 Lists<a href="post/Note-Learn-Dart#列表-Lists"></a></h3><p>也许几乎所有编程语言中最常见的集合是数组，或有序的对象组。在Dart中数组就是<a href="https://api.dartlang.org/stable/2.2.0/dart-core/List-class.html" target="_blank" rel="noopener">List</a>对象，因此大多数人叫他们列表。</p><p>Dart的列表写法看起来就是其他语言数组的写法。下面是一个Dart列表的示例：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></div></figure><p>上面的类型为<code>List&lt;int&gt;</code></p><p>更多关于列表的信息，请参阅<a href="https://www.dartlang.org/guides/language/language-tour#generics" target="_blank" rel="noopener">泛型</a>和<a href="https://www.dartlang.org/guides/libraries/library-tour#collections" target="_blank" rel="noopener">集合</a></p><h3 id="集合-Sets">集合 Sets<a href="post/Note-Learn-Dart#集合-Sets"></a></h3><p>set 在Dart中是一个无序集合，Dart支持通过文字表达和<a href="https://api.dartlang.org/stable/2.2.0/dart-core/Set-class.html" target="_blank" rel="noopener">Set</a>来创建集合。</p><p>简单的通过文字表达</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> halogens = &#123;<span class="string">'fluorine'</span>, <span class="string">'chlorine'</span>, <span class="string">'bromine'</span>, <span class="string">'iodine'</span>, <span class="string">'astatine'</span>&#125;;</span><br></pre></td></tr></table></div></figure><p>上面类型为：<code>Set&lt;String&gt;</code></p><p>创建一个空集合：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names1 = &lt;<span class="built_in">String</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; names2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var names3 = &#123;&#125;; //注意这样创建的不是一个Set，而是一个Map，具体来说是一个 Map&lt;dynamic, dynamic&gt;</span></span><br></pre></td></tr></table></div></figure><h3 id="映射-Maps">映射 Maps<a href="post/Note-Learn-Dart#映射-Maps"></a></h3><p>通常，一个map有key和value。key和value可以是任何对象，key只能出现一个，但值可以对应多个key。Dart创建映射也可以通过直接表达和<a href="https://api.dartlang.org/stable/dart-core/Map-class.html" target="_blank" rel="noopener">Set</a>类型表达。</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = &#123;</span><br><span class="line">  <span class="string">'a'</span>: <span class="string">'1'</span>,</span><br><span class="line">  <span class="string">'b'</span>: <span class="string">'2'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bb = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'b'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>上面，第一个<code>aa</code>是<code>Map&lt;String, String&gt;</code>类型，第二个<code>bb</code>是<code>Map&lt;int, String&gt;</code>类型。</p><p>通过Map构造也可以创建同样的效果：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aa = <span class="built_in">Map</span>();</span><br><span class="line">aa[<span class="string">'a'</span>] = <span class="string">'1'</span>;</span><br><span class="line">aa[<span class="string">'b'</span>] = <span class="string">'2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bb = <span class="built_in">Map</span>();</span><br><span class="line">bb[<span class="number">1</span>] = <span class="string">'a'</span>;</span><br><span class="line">bb[<span class="number">2</span>] = <span class="string">'b'</span>;</span><br></pre></td></tr></table></div></figure><h3 id="Runes">Runes<a href="post/Note-Learn-Dart#Runes"></a></h3><p>Dart中Runes是UTF-32字符集的字符串对象</p><p>Unicode为世界上的所有文字系统都定义了一个唯一数字代表文字、数字和符号。因为一个Dart字符串是一个UTF-16字符集序列，在字符串中表示32位Unicode值需要特殊语法。</p><p>常用来表达一个Unicode字符的方式是<code>\uXXXX</code>，这儿的<code>XXXX</code>是一个4位16进制值。例如，心字符（♥）是<code>\u2665</code>。如果是多余或少于4个16进制数字的，将值放进大括号里面。例如笑的emoji（😆）是<code>\u{1f600}</code>。</p><p><a href="https://api.dartlang.org/stable/2.2.0/dart-core/String-class.html" target="_blank" rel="noopener">String</a>类有几个属性使您可以将字符串转为符文runes。<code>codeUnitAt</code>和<code>codeUnits</code>返回16位字符集（数字编码）。使用<code>runes</code>返回一个字符串符文</p><p>下面说明了符文，16位和32位字符集之间的关系</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clapping = <span class="string">'\u&#123;1f44f&#125;ab'</span>;</span><br><span class="line"><span class="built_in">print</span>(clapping); <span class="comment">// 👏ab</span></span><br><span class="line"><span class="built_in">print</span>(clapping.codeUnitAt(<span class="number">0</span>)); <span class="comment">// 55357</span></span><br><span class="line"><span class="built_in">print</span>(clapping.codeUnits); <span class="comment">// [55357, 56399, 97, 98]</span></span><br><span class="line"><span class="built_in">print</span>(clapping.runes.toList()); <span class="comment">// [128079, 97, 98]</span></span><br><span class="line"></span><br><span class="line">Runes input = <span class="keyword">new</span> Runes(</span><br><span class="line">    <span class="string">'\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">String</span>.fromCharCodes(input)); <span class="comment">// ♥  😅  😎  👻  🖖  👍</span></span><br></pre></td></tr></table></div></figure><h3 id="符号-Symbols">符号 Symbols<a href="post/Note-Learn-Dart#符号-Symbols"></a></h3><p>在Dart程序中，<a href="https://api.dartlang.org/stable/2.2.0/dart-core/Symbol-class.html" target="_blank" rel="noopener">Symbol</a>对象表示声明运算符或标识符。您可能从来不会使用到Symbol，但是它们在按名字引用标识符的API非常有用，因为缩小到改变标识符名称而不更改标识符。</p><p>获取标识符的symbol，使用sybol表达式，只需<code>#</code>号后跟标识符：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">Map</span>();</span><br><span class="line">map[#foo] = <span class="string">"foo's value"</span>;</span><br><span class="line"><span class="built_in">print</span>(map[#foo]); <span class="comment">// foo's value</span></span><br><span class="line"><span class="built_in">print</span>(#foo); <span class="comment">// Symbol("foo")</span></span><br></pre></td></tr></table></div></figure><p>Symbol是编译器常量。</p><h2 id="方法-Functions">方法 Functions<a href="post/Note-Learn-Dart#方法-Functions"></a></h2><p>Dart是一个真正的面向对象语言，因此甚至函数也是一个对象有一个类型，<a href="https://api.dartlang.org/stable/dart-core/Function-class.html" target="_blank" rel="noopener">Function</a>。这意味着方法能分配给变量或传入其他方法，你也可以好像调用一个函数一样，调用Dart类的实例。详情，请参阅<a href="https://www.dartlang.org/guides/language/language-tour#callable-classes" target="_blank" rel="noopener">可调用的类</a>。</p><p>这儿有个实现方法的例子：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>尽管<a href="https://www.dartlang.org/guides/language/effective-dart/design#prefer-type-annotating-public-fields-and-top-level-variables-if-the-type-isnt-obvious" target="_blank" rel="noopener">Effective Dart建议写上返回类型</a>，但是如果你不写也可以正常工作：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNoble(atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这个方法里面只有一个表达式，于是可以简写：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></div></figure><p><code>=&gt; 表达式</code>语法是<code>{ return 表达式;}</code>的简写。<code>=&gt;</code>符号有时也被称为箭头语法。</p><p>一个方法可能有两个类型的参数：必须和可选。必要的参数在最前，随后是可选参数。</p><h3 id="可选参数">可选参数<a href="post/Note-Learn-Dart#可选参数"></a></h3><p>可选参数可以是位置参数或命名参数，不能同时存在</p><h4 id="可选命名参数">可选命名参数<a href="post/Note-Learn-Dart#可选命名参数"></a></h4><p>当调用一个方法，您可以指定命名参数<code>paramName: value.</code>，例如：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></div></figure><p>当定义一个方法时，使用<code>{param1, param2, ...}</code>来指定命名参数：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 设置加粗和隐藏标记</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;...&#125;</span><br></pre></td></tr></table></div></figure><p><a href="https://flutter.dev/" target="_blank" rel="noopener">Flutter</a>实例创建可能更复杂，因此widget构造器仅使用命名参数。这让实例的创建更加容易阅读。</p><p>您可以在任何Dard代码中标记注解<a href="https://pub.dartlang.org/documentation/meta/latest/meta/required-constant.html" target="_blank" rel="noopener">@required</a>，表面它是一个必传参数。例如：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scrollbar(&#123;Key key, <span class="meta">@required</span> Widget child&#125;)</span><br></pre></td></tr></table></div></figure><p>当<code>Scrollbar</code>被创建时，如果没有传入child那么解析器就会报告问题。</p><p><a href="https://pub.dartlang.org/documentation/meta/latest/meta/required-constant.html" target="_blank" rel="noopener">Required</a>被定义在<a href="https://pub.dartlang.org/packages/meta" target="_blank" rel="noopener">meta</a>包中，要么直接导入<code>package:meta/meta.dart</code>，要么导入的其他包中导入过<code>meta</code>，例如Flutter的<code>package:flutter/material.dart</code>。</p><p>命名参数加了<code>@required</code>必传，其他可传可不传。</p><h4 id="可选位置参数">可选位置参数<a href="post/Note-Learn-Dart#可选位置参数"></a></h4><p>在<code>[]</code>中设置函数类型使它们作为可选位置参数，该参数可传可不传。</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  if (device != null) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    result = '</span></span><span class="subst">$result</span> with a <span class="subst">$device<span class="string">';</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  return result;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></div></figure><p>没有传入可选位置参数时：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>)); <span class="comment">// Bob says Howdy</span></span><br></pre></td></tr></table></div></figure><p>当传入可选位置参数的时候：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>, <span class="string">'smoke signal'</span>)); <span class="comment">// Bob says Howdy with a smoke a signal</span></span><br></pre></td></tr></table></div></figure><h4 id="参数默认值">参数默认值<a href="post/Note-Learn-Dart#参数默认值"></a></h4><p>命名参数和位置参数都可以使用<code>=</code>来定义默认值，默认值必须是编译器常量。如果没有提供默认值，默认值为<code>null</code></p><p>设置命名参数的默认值：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;...&#125;</span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>); <span class="comment">// bold = true, hidden = false</span></span><br></pre></td></tr></table></div></figure><p>设置可选位置参数的默认值：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">'carrier pigeon'</span>, <span class="built_in">String</span> mood]) &#123; ... &#125;</span><br></pre></td></tr></table></div></figure><p>你也可以为列表或集合参数设置默认值，如下：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(</span><br><span class="line">    &#123;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">'first'</span>: <span class="string">'paper'</span>,</span><br><span class="line">      <span class="string">'second'</span>: <span class="string">'cotton'</span>,</span><br><span class="line">      <span class="string">'third'</span>: <span class="string">'leather'</span></span><br><span class="line">    &#125;&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'list:  <span class="subst">$list<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>gifts: <span class="subst">$gifts<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></div></figure><h3 id="main-方法"><code>main()</code>方法<a href="post/Note-Learn-Dart#main-方法"></a></h3><p>每个app必须有个顶级<code>main()</code>方法，它是app的入口点。<code>main()</code>方法返回<code>void</code>并且有一个可选参数<code>List&lt;String&gt;</code>。</p><p>这是一个web app的main()方法例子：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">querySelector</span>(<span class="string">'#sample_text_id'</span>)</span><br><span class="line">  ..text = <span class="string">'Click me!'</span></span><br><span class="line">  ..onClick.listen(reverseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>注意：这里的<code>..</code>语法被称为<a href="https://www.dartlang.org/guides/language/language-tour#cascade-notation-" target="_blank" rel="noopener">级联</a>，通过级联您可以多次对一个对象进行操作。</p></blockquote><p>下面是创建了一个命令行运行的app，在<code>main()</code>方法的参数可获得命令行的值：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; arguments) &#123;</span><br><span class="line">  <span class="built_in">print</span>(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>首先需要配置好dart环境变量，然后在终端当前文件目录运行：<code>dart test.dart 1 test</code>，将会输出<code>[1, test]</code>。</p><p>您可以使用<a href="https://www.dartlang.org/guides/language/language-tour#cascade-notation-" target="_blank" rel="noopener">args</a>类库定义或解析命令行参数。</p><h3 id="方法看做类对象">方法看做类对象<a href="post/Note-Learn-Dart#方法看做类对象"></a></h3><p>您可以将一个方法作为参数传入另一个方法，例如：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">void</span> printElement(<span class="built_in">int</span> element) &#123;</span><br><span class="line">    <span class="built_in">print</span>(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="comment">// 将方法作为参数传入</span></span><br><span class="line">  list.forEach(printElement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行输出：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></div></figure><p>您也可以为变量分配一个方法，例如：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loudify = (msg) =&gt; <span class="string">'!!!<span class="subst">$&#123;msg.toUpperCase()&#125;</span>!!!'</span>;</span><br><span class="line"><span class="built_in">print</span>(loudify(<span class="string">'hello'</span>)); <span class="comment">// !!!HELLO!!!</span></span><br></pre></td></tr></table></div></figure><p>这个例子使用匿名方法，更多信息请接着看看下面哦！</p><h3 id="匿名方法">匿名方法<a href="post/Note-Learn-Dart#匿名方法"></a></h3><p>很多方面都有名字，例如<code>main()</code>或<code>printElement()</code>。您也可以创建一个没有名字的方法，我们称之为匿名方法，或<code>lambda</code>，或<code>闭包(closure)</code>。您可以分配给变量一个匿名方法，例如，您可以在列表中添加或移除它。</p><p>匿名方法和命名方法差不多，一个或多个参数放在括号里，之间用逗号分隔。</p><p>代码样式看起来如下面的格式：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([[类型] 参数<span class="number">1</span>[, …]]) &#123;</span><br><span class="line">  代码块;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>下面的例子中定义了一个无类型参数<code>item</code>的匿名方法，这个方法在列表轮询时被调用，打印对应的值和下标：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">'apples'</span>, <span class="string">'bananas'</span>, <span class="string">'oranges'</span>];</span><br><span class="line">list.forEach((item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;list.indexOf(item)&#125;</span>:<span class="subst">$item<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;);</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">// 输出：</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">// 0:apples</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">// 1:bananas</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">// 2:oranges</span></span></span></span><br></pre></td></tr></table></div></figure><p>由于这个方法只有一条指令，您可以用箭头表达：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach((item) =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item<span class="string">'));</span></span></span></span><br></pre></td></tr></table></div></figure><h3 id="作用域语法">作用域语法<a href="post/Note-Learn-Dart#作用域语法"></a></h3><p>Dart也是一个作用域语法语言，这意味着变量的作用域是确定的，只需改变代码布局就可。您可以使用花括号外的变量来查看是否在作用域内。</p><p>下面是一个方法内嵌的例子，并且每个等级的作用域中都有一个变量：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> topLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> insideMain = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> myFunction() &#123;</span><br><span class="line">    <span class="keyword">var</span> insideFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> nestedFunction() &#123;</span><br><span class="line">      <span class="keyword">var</span> insideNestedFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span>(topLevel);</span><br><span class="line">      <span class="keyword">assert</span>(insideMain);</span><br><span class="line">      <span class="keyword">assert</span>(insideFunction);</span><br><span class="line">      <span class="keyword">assert</span>(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意<code>nestedFunction()</code>如何使用每个级别的变量，一直到顶级。</p><h3 id="闭包语法">闭包语法<a href="post/Note-Learn-Dart#闭包语法"></a></h3><p>一个闭包是一个方法对象，它能访问在它作用域语法内的变量。即使当这个方法使用在原来的作用域之外。</p><p>方法能关联作用域范围的变量，在下面的例子中，<code>makeAdder()</code>获取的变量是<code>addBy</code>，返回一个方法，无论它返回在哪都会记住<code>addBy</code>。</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 返回一个方法</span></span><br><span class="line"><span class="comment">/// addBy + 方法的参数i</span></span><br><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">num</span> addBy) =&gt; (i) =&gt; addBy + i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 创建一个加2的方法</span></span><br><span class="line">  <span class="keyword">var</span> add2 = makeAdder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个加4的方法</span></span><br><span class="line">  <span class="keyword">var</span> add4 = makeAdder(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;add2(<span class="number">3</span>)&#125;</span>, <span class="subst">$&#123;add4(<span class="number">3</span>)&#125;</span>'</span>); <span class="comment">// 5,  7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="测试方法相等性">测试方法相等性<a href="post/Note-Learn-Dart#测试方法相等性"></a></h3><p>这儿有一个测试最外层方法，静态方法和实例方法的相等性的例子：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() &#123;&#125; <span class="comment">// 最外层方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> bar() &#123;&#125; <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">void</span> baz() &#123;&#125; <span class="comment">// 实例方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较静态方法</span></span><br><span class="line">  x = foo;</span><br><span class="line">  <span class="built_in">print</span>(foo == x); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较实例方法</span></span><br><span class="line">  x = A.bar;</span><br><span class="line">  <span class="built_in">print</span>(A.bar == x); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> v = A(); <span class="comment">// 第一个A实例</span></span><br><span class="line">  <span class="keyword">var</span> w = A(); <span class="comment">// 第二个A实例</span></span><br><span class="line">  <span class="keyword">var</span> y = w;</span><br><span class="line">  x = w.baz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于这两个变量引用同一个实例，因此他们的闭包相等</span></span><br><span class="line">  <span class="built_in">print</span>(y.baz == x); <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 由于这是两个实例，因此他们的闭包不等</span></span><br><span class="line">  <span class="built_in">print</span>(v.baz == w.baz); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="返回值">返回值<a href="post/Note-Learn-Dart#返回值"></a></h3><p>所有方法都有一个返回值，如果没有指定返回值，那么在方法体中会隐式声明<code>return null;</code></p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo() &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(foo()); <span class="comment">// null</span></span><br></pre></td></tr></table></div></figure><h2 id="运算符">运算符<a href="post/Note-Learn-Dart#运算符"></a></h2><p>下面的表格中展示了Dart中定义的运算符，您可以覆盖下面大部分运算符，详情参照：<a href="https://www.dartlang.org/guides/language/language-tour#overridable-operators" target="_blank" rel="noopener">可覆盖运算符</a></p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">描述</th><th style="text-align:left">运算符</th></tr></thead><tbody><tr><td style="text-align:left">单目后置</td><td style="text-align:left"><code>expr++</code> <code>expr--</code> <code>()</code> <code>[]</code> <code>.</code> <code>?.</code></td></tr><tr><td style="text-align:left">单目前置</td><td style="text-align:left"><code>-expr</code> <code>!expr</code> <code>~expr</code> <code>++expr</code> <code>--expr</code></td></tr><tr><td style="text-align:left">乘法类</td><td style="text-align:left"><code>*</code> <code>/</code> <code>%</code> <code>~/</code></td></tr><tr><td style="text-align:left">加减类</td><td style="text-align:left"><code>+</code> <code>-</code></td></tr><tr><td style="text-align:left">位移</td><td style="text-align:left"><code>&gt;&gt;</code> <code>&lt;&lt;</code> <code>&gt;&gt;&gt;</code></td></tr><tr><td style="text-align:left">按位与</td><td style="text-align:left"><code>&amp;</code></td></tr><tr><td style="text-align:left">按位异或</td><td style="text-align:left"><code>^</code></td></tr><tr><td style="text-align:left">按位或</td><td style="text-align:left">`</td><td>`</td></tr><tr><td style="text-align:left">关系和类型校验</td><td style="text-align:left"><code>&gt;=</code> <code>&gt;</code> <code>&lt;=</code> <code>&lt;</code> <code>as</code> <code>is</code> ‘is!’</td></tr><tr><td style="text-align:left">等性</td><td style="text-align:left"><code>==</code> <code>!=</code></td></tr><tr><td style="text-align:left">逻辑与</td><td style="text-align:left"><code>&amp;&amp;</code></td></tr><tr><td style="text-align:left">逻辑或</td><td style="text-align:left">`</td><td></td><td>`</td></tr><tr><td style="text-align:left">是否是null</td><td style="text-align:left">??</td></tr><tr><td style="text-align:left">三目运算</td><td style="text-align:left"><code>expr1 ? expr2 : expr2</code></td></tr><tr><td style="text-align:left">级联</td><td style="text-align:left"><code>..</code></td></tr><tr><td style="text-align:left">赋值</td><td style="text-align:left"><code>=</code> <code>*=</code> <code>/=</code> <code>+=</code> <code>-=</code> <code>&amp;=</code> <code>^=</code> 等</td></tr></tbody></table></div></div><h3 id="算数运算符">算数运算符<a href="post/Note-Learn-Dart#算数运算符"></a></h3><p>Dart支持常用算数运算符，如下表所示：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">加</td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">减</td></tr><tr><td style="text-align:left"><code>-expr</code></td><td style="text-align:left">一元减，也称为否定（反转表达式的符号）</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">乘</td></tr><tr><td style="text-align:left"><code>/</code></td><td style="text-align:left">除</td></tr><tr><td style="text-align:left"><code>~/</code></td><td style="text-align:left">除以，并返回整数结果</td></tr><tr><td style="text-align:left"><code>%</code></td><td style="text-align:left">求余</td></tr></tbody></table></div></div><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">5</span> / <span class="number">2</span>); <span class="comment">// 2.5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> ~/ <span class="number">2</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></div></figure><p>Dart也支持单目递增和递减运算符</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>++var</code></td><td style="text-align:left"><code>var = var + 1</code>(表达式的值为<code>var + 1</code>)</td></tr><tr><td style="text-align:left"><code>var++</code></td><td style="text-align:left"><code>var = var + 1</code>(表达式的值为<code>var</code>)</td></tr><tr><td style="text-align:left"><code>--var</code></td><td style="text-align:left"><code>var = var - 1</code>(表达式的值为<code>var - 1</code>)</td></tr><tr><td style="text-align:left"><code>var--</code></td><td style="text-align:left"><code>var = var - 1</code>(表达式的值为<code>var</code>)</td></tr></tbody></table></div></div><h3 id="等式和关系运算符">等式和关系运算符<a href="post/Note-Learn-Dart#等式和关系运算符"></a></h3><p>下面的表格列出了等式和关系运算符的含义</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>==</code></td><td style="text-align:left">恒等于</td></tr><tr><td style="text-align:left"><code>!=</code></td><td style="text-align:left">不等于</td></tr><tr><td style="text-align:left"><code>&gt;</code></td><td style="text-align:left">大于</td></tr><tr><td style="text-align:left"><code>&lt;</code></td><td style="text-align:left">小于</td></tr><tr><td style="text-align:left"><code>&gt;=</code></td><td style="text-align:left">大于或等于</td></tr><tr><td style="text-align:left"><code>&lt;=</code></td><td style="text-align:left">小于或等于</td></tr></tbody></table></div></div><p>使用<code>==</code>判断两个对象是否是同一个东西（在少数情况下您需要判断两个引用是否指向同一个对象时，使用<a href="https://api.dartlang.org/stable/2.2.0/dart-core/identical.html" target="_blank" rel="noopener">identical()</a>）</p><h3 id="类型检测运算符">类型检测运算符<a href="post/Note-Learn-Dart#类型检测运算符"></a></h3><p><code>as</code>,<code>is</code>和<code>is!</code>运算符用来检测运行时类型</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">意思</th></tr></thead><tbody><tr><td style="text-align:left"><code>as</code></td><td style="text-align:left">类型转换（也经常用来指定<a href="https://www.dartlang.org/guides/language/language-tour#specifying-a-library-prefix" target="_blank" rel="noopener">类库前缀</a>）</td></tr><tr><td style="text-align:left"><code>is</code></td><td style="text-align:left">对象是否有指定的类型</td></tr><tr><td style="text-align:left"><code>is!</code></td><td style="text-align:left">和上面相反</td></tr></tbody></table></div></div><p><code>as</code> 强转类型， <code>is</code> 类型判断</p><h3 id="赋值运算符">赋值运算符<a href="post/Note-Learn-Dart#赋值运算符"></a></h3><p>您已知道，您可以通过<code>=</code>运算符为变量赋值。如果要仅仅变量为<code>null</code>时才赋值，使用<code>??=</code>运算符</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">int</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">int</span> b;</span><br><span class="line"></span><br><span class="line">  a ??= <span class="number">10</span>;</span><br><span class="line">  b ??= <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'a = <span class="subst">$a</span>, b = <span class="subst">$b<span class="string">'); // a = 5, b = 10</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></div></figure><p>组合赋值运算符，如<code>+=</code>将运算符和赋值结合</p><div class="article-bounded"><div class="article-table"><table><tbody><tr><td style="text-align:left"><code>=</code></td><td style="text-align:left"><code>-=</code></td><td style="text-align:left"><code>/=</code></td><td style="text-align:left"><code>%=</code></td><td style="text-align:left"><code>&gt;&gt;=</code></td><td style="text-align:left"><code>^=</code></td></tr><tr><td style="text-align:left"><code>+=</code></td><td style="text-align:left"><code>*=</code></td><td style="text-align:left"><code>~/=</code></td><td style="text-align:left"><code>&lt;&lt;=</code></td><td style="text-align:left"><code>&amp;=</code></td><td style="text-align:left"><code>&#124;=</code></td></tr></tbody></table></div></div><h3 id="逻辑运算符">逻辑运算符<a href="post/Note-Learn-Dart#逻辑运算符"></a></h3><p>您可以通过逻辑运算符颠倒或组合布尔表达式</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">意思</th></tr></thead><tbody><tr><td style="text-align:left"><code>!expr</code></td><td style="text-align:left">颠倒是非</td></tr><tr><td style="text-align:left"><code>&#124;&#124;</code></td><td style="text-align:left">逻辑或</td></tr><tr><td style="text-align:left"><code>&amp;&amp;</code></td><td style="text-align:left">逻辑与</td></tr></tbody></table></div></div><h3 id="按位运算和移位运算符">按位运算和移位运算符<a href="post/Note-Learn-Dart#按位运算和移位运算符"></a></h3><p>您可以在Dart中操作数字的位运算</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">意思</th></tr></thead><tbody><tr><td style="text-align:left"><code>&amp;</code></td><td style="text-align:left">与</td></tr><tr><td style="text-align:left"><code>&#124;</code></td><td style="text-align:left">或</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">异或</td></tr><tr><td style="text-align:left"><code>~expr</code></td><td style="text-align:left">取反</td></tr><tr><td style="text-align:left"><code>&lt;&lt;</code></td><td style="text-align:left">左移</td></tr><tr><td style="text-align:left"><code>&gt;&gt;</code></td><td style="text-align:left">右移</td></tr></tbody></table></div></div><h3 id="条件表达式">条件表达式<a href="post/Note-Learn-Dart#条件表达式"></a></h3><p>Dart有两种表达式让您简明的表达需要使用到<code>if-else</code>的情景：</p><p>1.三目运算符</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expr1 : expr2</span><br></pre></td></tr></table></div></figure><p>2.是否为null，如果为null则用后面的表达式</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr1 ?? expr2</span><br></pre></td></tr></table></div></figure><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span> &gt; <span class="number">2</span> ? <span class="string">"是的1&gt;2"</span> : <span class="string">"不不，1&lt;2"</span>); <span class="comment">// 不不，1&lt;2</span></span><br><span class="line">  <span class="built_in">int</span> value;</span><br><span class="line">  <span class="built_in">print</span>(value ?? <span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="级联表示法">级联表示法<a href="post/Note-Learn-Dart#级联表示法"></a></h3><p><code>..</code>允许您对同一个对象进行一系列连续的操作。不仅可以调用方法，您也可以为这个对象字段赋值。这通常为您节省了创建临时变量的不步骤，并能让你写成更多流畅的代码。</p><p>请参考下面代码：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">'#confirm'</span>) <span class="comment">// 获得一个对象</span></span><br><span class="line">  ..text = <span class="string">'Confirm'</span> <span class="comment">// 使用它的成员变量</span></span><br><span class="line">  ..classes.add(<span class="string">'important'</span>)</span><br><span class="line">  ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">'Confirmed!'</span>));</span><br></pre></td></tr></table></div></figure><p>还有内部联结：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">'jenny'</span></span><br><span class="line">      ..email = <span class="string">'jenny@example.com'</span></span><br><span class="line">      ..phone = (PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">'415-555-0100'</span></span><br><span class="line">            ..label = <span class="string">'home'</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></div></figure><h3 id="其他操作符">其他操作符<a href="post/Note-Learn-Dart#其他操作符"></a></h3><p>您已在其他案例中看到了大多数的相关操作符</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">名字</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>()</code></td><td style="text-align:left">方法</td><td style="text-align:left">表示方法调用</td></tr><tr><td style="text-align:left"><code>[]</code></td><td style="text-align:left">列表访问</td><td style="text-align:left">通过索引引用列表中的值</td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">成员访问</td><td style="text-align:left">引用一个属性；例如：<code>foo.bar</code>，引用foo对象中的bar属性</td></tr><tr><td style="text-align:left"><code>?.</code></td><td style="text-align:left">条件成员访问</td><td style="text-align:left">左边的变量可以是null</td></tr></tbody></table></div></div><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="built_in">print</span>(a?.b); <span class="comment">// null, 如果不加“？”就会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>更多关于<code>.</code>，<code>?.</code>和<code>..</code>的操作，请参考<a href="https://www.dartlang.org/guides/language/language-tour#classes" target="_blank" rel="noopener">类</a></p><h2 id="控制流语句">控制流语句<a href="post/Note-Learn-Dart#控制流语句"></a></h2><p>您可以使用下面的任意Dart代码控制流程</p><ul><li><code>if</code> 和 <code>else</code></li><li><code>for</code> 循环</li><li><code>while</code> 和 <code>do-while</code>循环</li><li><code>break</code> 和 <code>continue</code></li><li><code>switch</code> 和 <code>case</code></li><li><code>assert</code></li></ul><p>您也可以可以通过<code>try-catch</code>和<code>throw</code>影响流程，详细介绍在<a href="https://www.dartlang.org/guides/language/language-tour#exceptions" target="_blank" rel="noopener">异常</a></p><h3 id="for循环">for循环<a href="post/Note-Learn-Dart#for循环"></a></h3><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> callback = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    callback.add(() =&gt; <span class="built_in">print</span>(i));</span><br><span class="line">  &#125;</span><br><span class="line">  callback.forEach((c) =&gt; c());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></div></figure><p>列表中放入的是两个闭包，列表是一个迭代器，您可以使用<a href="https://api.dartlang.org/stable/2.2.0/dart-core/Iterable/forEach.html" target="_blank" rel="noopener">forEach()</a>方法来遍历。如果你不需要知道当前的迭代数量，使用<code>forEach()</code>是一个不错的选择：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candidates.forEach((candidate) =&gt; candidate.interview());</span><br></pre></td></tr></table></div></figure><p>可迭代的类如List和Set也支持<code>for-in</code><a href="https://www.dartlang.org/guides/libraries/library-tour#iteration" target="_blank" rel="noopener">iteration</a>：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;</span><br><span class="line">  <span class="built_in">print</span>(x); <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="Switch和case">Switch和case<a href="post/Note-Learn-Dart#Switch和case"></a></h3><p>值得注意的是switch里面使用<code>==</code>作为判断整型，字符串或编译期常量。用法大致和java差不多，主要注意下面这样的写法有改进：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'OPEN'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'OPEN'</span>:</span><br><span class="line">    executeOpen();</span><br><span class="line">    <span class="comment">// 错误： 没有break （如果去掉executeOpen();也是没有问题的）</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'CLOSED'</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>改：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'CLOSED'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'CLOSED'</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">continue</span> nowClosed;</span><br><span class="line">  <span class="comment">// 继续执行nowClosed标签</span></span><br><span class="line"></span><br><span class="line">  nowClosed:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'NOW_CLOSED'</span>:</span><br><span class="line">    <span class="comment">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class="line">    executeNowClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="断言">断言<a href="post/Note-Learn-Dart#断言"></a></h2><p>断言不会影响到生产代码，只应用在开发调试模式下</p><h2 id="异常">异常<a href="post/Note-Learn-Dart#异常"></a></h2><p>您的Dart代码可以抛出或捕获异常，异常是发生了一些不希望的。如果异常没有捕获处理，会导致程序终止。Dart提供<a href="https://api.dartlang.org/stable/2.2.0/dart-core/Exception-class.html" target="_blank" rel="noopener">Exception</a>和<a href="https://api.dartlang.org/stable/2.2.0/dart-core/Error-class.html" target="_blank" rel="noopener">Error</a>类型，以及许多预定义的子类型。当然，您也可以定义您自己的异常。然而对于异常，Dart程序能抛出任何非null对象，不仅仅是Exception和Error对象。</p><h3 id="Throw">Throw<a href="post/Note-Learn-Dart#Throw"></a></h3><p>下面是一个抛出异常的列子：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> FormatException(<span class="string">'Expected at least 1 section'</span>);</span><br></pre></td></tr></table></div></figure><p>您也可以随意抛出一个对象：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">'异常。。。'</span>;</span><br></pre></td></tr></table></div></figure><p>由于抛出异常是一个表达式，可以通过<code>=&gt;</code>如下表达：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> distanceTo(Point other) =&gt; <span class="keyword">throw</span> UnimplementedError();</span><br></pre></td></tr></table></div></figure><h3 id="Catch">Catch<a href="post/Note-Learn-Dart#Catch"></a></h3><p>捕获一个异常</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>捕获多个异常，<code>catch</code>可以得到异常对象的引用，如果不明确类型直接用<code>catch</code>：</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// 一个特定异常</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 任何其他类型Exception异常</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Unknown exception: <span class="subst">$e<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125; catch (e) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  // 不指定类型，处理所有</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>Something really unknown: <span class="subst">$e<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></div></figure><p><code>catch()</code>可指定两个参数，第一个是抛出的异常对象，第二个是堆栈（<a href="https://api.dartlang.org/stable/2.2.0/dart-core/StackTrace-class.html" target="_blank" rel="noopener">StackTrace</a>）</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Exception details:\n <span class="subst">$e<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125; catch (e, s) &#123;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>Exception details:\n <span class="subst">$e<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  print('</span></span>Stack trace:\n <span class="subst">$s<span class="string">');</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></div></figure><p>既要处理异常，又要让异常重新跑出去使用<code>rethrow</code>关键字</p><figure class="highlight dart"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> misbehave() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">dynamic</span> foo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="built_in">print</span>(foo++); <span class="comment">// 运行时错误</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'misbehave() partially handled <span class="subst">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// 让调用者继续得到异常</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="Finally">Finally<a href="post/Note-Learn-Dart#Finally"></a></h3><p>和java一样</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dart笔记&quot;&gt;Dart笔记&lt;a href=&quot;post/Note-Learn-Dart#Dart笔记&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;变量&quot;&gt;变量&lt;a href=&quot;post/Note-Learn-Dart#变量&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;初始化一个变量&lt;/p&gt;
      
    
    </summary>
    
      <category term="Dart" scheme="https://blog.xujiaji.com/categories/Dart/"/>
    
    
      <category term="笔记" scheme="https://blog.xujiaji.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Dart" scheme="https://blog.xujiaji.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VBO）</title>
    <link href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven/index.html"/>
    <id>https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven/index.html</id>
    <published>2019-03-09T08:49:10.000Z</published>
    <updated>2019-04-12T17:44:07.238Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译文</p></blockquote><p>原文标题：Android Lesson Seven: An Introduction to Vertex Buffer Objects (VBOs)<br>原文链接：<a href="http://www.learnopengles.com/android-lesson-seven-an-introduction-to-vertex-buffer-objects-vbos/" target="_blank" rel="noopener">http://www.learnopengles.com/android-lesson-seven-an-introduction-to-vertex-buffer-objects-vbos/</a><br><a id="more"></a></p><hr><h1 id="介绍Vertex-Buffer-Objects（顶点缓冲区对象，简称：VBO）">介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VBO）<a href="post/Learn-OpenGL-Lesson-Seven#介绍Vertex-Buffer-Objects（顶点缓冲区对象，简称：VBO）"></a></h1><div class="article-bounded"><div class="article-table"><table><tbody><tr><td>在这节课中，我们将介绍如何定义和如何去使用<br>顶点缓冲对象（VBO）。下面是我们要讲到的几点：<br><br>1.怎样用顶点缓冲对象定义和渲染<br>2.单个缓冲区、所有数据打包进去、多个缓冲区之间的区别<br>3.问题和陷阱我们如何取处理它们</td><td style="text-align:center"><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190309170313.png" alt="screenshot"></td></tr></tbody></table></div></div><h2 id="什么是顶点缓冲区对象？为什么使用它们？">什么是顶点缓冲区对象？为什么使用它们？<a href="post/Learn-OpenGL-Lesson-Seven#什么是顶点缓冲区对象？为什么使用它们？"></a></h2><p>到目前为止，我们所有的课程都是将对象数据存储在客户端内存中，只有在渲染时将其传输到GPU中。没有大量数据传输时，这很好，但随着我们的场景越来越复杂，有更多的物体和三角形，这会给GPU和内存增加额外的成本。</p><p>我们能做些什么呢？我们可以使用顶点缓冲对象，而不是每帧从客户端内存传输顶点信息，信息将被传输一次，然后渲染器将从该图形存储器缓存中得到数据。</p><h2 id="前提条件">前提条件<a href="post/Learn-OpenGL-Lesson-Seven#前提条件"></a></h2><p>请阅读<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a>介绍如何从客户端的内存上传顶点数据。了解OpenGL ES如何与顶点数组一起工作对于理解本课至关重要。</p><h2 id="更详细的了解客户端缓冲区">更详细的了解客户端缓冲区<a href="post/Learn-OpenGL-Lesson-Seven#更详细的了解客户端缓冲区"></a></h2><p>一但了解了如何使用客户端内存进行渲染，切换到使用VBO实际上并不太难。其主要的不同在于添加了一个上传数据到图形内存的额外步骤，以及渲染时添加了绑定这个缓冲区的额外调用。</p><p>本节课将使用四种不同的模式：</p><ol><li>客户端，单独的缓冲区</li><li>客户端，打包的缓冲</li><li>顶点缓冲对象，单独的缓冲区</li><li>顶点缓冲对象，打包的缓冲</li></ol><p>无论我们是否使用顶点缓冲对象，我们都需要先将我们的数据存储在客户端本地缓冲区。会想到<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">第一课</a>中OpenGL ES 是一个本地系统库，而java是运行在Android上的一个虚拟机中。如何去桥接这个距离？我们需要使用一组特殊的缓冲区类来在本地堆上分配内存，并使使其供OpenGL访问：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 数组</span></span><br><span class="line"><span class="keyword">float</span>[] cubePositions;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 浮点缓冲区</span></span><br><span class="line"><span class="keyword">final</span> FloatBuffer cubePositionsBuffer;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 在本地堆上直接分配一块内存</span></span><br><span class="line"><span class="comment">// 字节大小为cubePositions的长度乘以每个浮点数的字节大小</span></span><br><span class="line"><span class="comment">// 每个float的字节大小为4，因为float是32位或4字节</span></span><br><span class="line">cubePositionsBuffer = ByteBuffer.allocateDirect(cubePositions.length * BYTES_PRE_FLOAT)</span><br><span class="line"><span class="comment">// 浮点会以大端（big-endian）或小段（little-endian）的顺序排列</span></span><br><span class="line"><span class="comment">// 我想让其同本地平台相同的排列</span></span><br><span class="line">.order(ByteOrder.nativeOrder())</span><br><span class="line"><span class="comment">// 在这个字节缓冲区上给我们一个浮点视角</span></span><br><span class="line">.asFloatBuffer();</span><br></pre></td></tr></table></div></figure><p>将Java堆上数据转换到本地堆上，就是两方法调用的事情：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将java堆上的数据拷贝到本地堆</span></span><br><span class="line">cubePositionsBuffer.put(cubePositions)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置这个缓冲区开始的缓冲位置</span></span><br><span class="line">.position(<span class="number">0</span>);</span><br></pre></td></tr></table></div></figure><p>缓冲位置的目的是什么？通常，Java没有为我们提供一种在内存中使用<a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)" target="_blank" rel="noopener">指针</a>，任意指定位置的方法。然而，设置缓冲区的位置在功能上等同于更改指向内存块指针的值。通过改变指针的位置，我们可以将缓冲区中任意的内存位置传递给OpenGL调用。当我们使用打包的缓冲作业时，这将派上用场。</p><p>一但数据存放到本地堆上，我们就不需要长时间持有float[]数组了，我们可以让垃圾回收器清理它。</p><p>使用客户端缓冲区进行渲染非常简单，我们仅需要启动对应属性的顶点素组，并将指针传递给我们的数据：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入位置信息</span></span><br><span class="line">GLES20.glEnableVertexAttribArray(mPositionHandle);</span><br><span class="line">GLES20.glVertexAttriPointer(mPositionHandle, POSITION_DATA_SIZE,</span><br><span class="line">    GLES20.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, mCubePositions)</span><br></pre></td></tr></table></div></figure><p><a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glVertexAttribPointer.xml" target="_blank" rel="noopener">glVertexAttriPointer</a>参数说明：</p><ul><li><em>mPositionHandle：</em> 我们着色器程序的位置属性索引</li><li><em>POSITION_DATA_SIZE：</em> 定义这个属性需要多少个float元素</li><li><em>GL_FLOAT：</em> 每个元素的类型</li><li><em>false：</em> 定点数据因该标准化吗？由于我们使用的是浮点数据，因此不适用。</li><li><em>0：</em> 跨度，设置0，以为着应安顺序读取。第一课中设置为7，表示每次读取跨度7个位置</li><li><em>mCubePositions：</em> 指向缓冲区的的指针，包含所有位置数据</li></ul><h2 id="使用打包缓冲区">使用打包缓冲区<a href="post/Learn-OpenGL-Lesson-Seven#使用打包缓冲区"></a></h2><p>使用打包缓冲区是非常相似的，替换了每个位置、法线等的缓冲区，现在一个缓冲区将包含所有这些数据。不同点看下面：</p><blockquote><p>使用单缓冲区</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">positions = X,Y,Z,X,Y,Z,X,Y,Z,...</span><br><span class="line">colors = R,G,B,A,R,G,B,A,...</span><br><span class="line">textureCoordinates = S,T,S,T,S,T...</span><br></pre></td></tr></table></div></figure><blockquote><p>使用打包缓冲区</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer = X,Y,Z,R,G,B,A,S,T...</span><br></pre></td></tr></table></div></figure><p>使用打包缓冲区的好处是它将会使GPU更高效的渲染，因为渲染三角形所需的所有信息都位于内存同一块地方。缺点是，如果我们使用动态数据，更新可能会更困难，更慢。</p><p>当我们使用打包缓冲区时，我们需要以下几种方式更改渲染调用。首先，我们需要告诉OpenGL<code>跨度（stride）</code> ，定义一个顶点的字节数。</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> stride = (POSITION_DATA_SIZE + NORMAL_DATA_SIZE + TEXTURE_COORDINATE_DATA_SIZE)</span><br><span class="line">    * BYTES_PER_FLOAT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入位置信息</span></span><br><span class="line">mCubeBuffer.position(<span class="number">0</span>);</span><br><span class="line">GLES20.glEnableVertexAttribArray(mPositionHandle);</span><br><span class="line">GLES20.glVertexAttribPointer(mPositionHandle, POSITION_DATA_SIZE,</span><br><span class="line">    GLES20.GL_FLOAT, <span class="keyword">false</span>, stride, mCubeBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入法线信息</span></span><br><span class="line">mCubeBuffer.position(POSITION_DATA_SIZE);</span><br><span class="line">GLES20.glEnableVertexAttribArray(mNormalHandle);</span><br><span class="line">GLES20.glVertexAttribPointer(mNormalHandle, NORMAL_DATA_SIZE,</span><br><span class="line">    GLES20.GL_FLOAT, <span class="keyword">false</span>, stride, mCubeBuffer);</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>这个跨度告诉OpenGL ES下一个顶点的同样的属性要再跨多远才能找到。例如：如果元素0是第一个顶点的开始位置，并且这里每个顶点有8个元素，然后这个跨度将是8个元素，也就是32个字节。下一个顶点的位置将找到第8个元素，下下个顶点的位置将找到第16个元素，以此类推。</p><p>请记住，传递给<code>glVertexAttriPointer</code>的跨度单位是字节，而不是元素，因此请记住进行该转换。</p><p>注意，当我们从指定位置切换到指定法线时，我们要更改缓冲区的其实位置。这是我们之前提到的指针算法，这是我们在使用OpengGL ES时用Java做的方式。我们仍然使用同一个缓冲区<code>mCubeBuffer</code>，但是我们告诉OpenGL从位置数据后的第一个元素开始读取法线信息。我们也告诉OpenGL下一个法线要跨越8个元素（也可以说是32个字节）开始。</p><h2 id="Dalvik和本地堆上的内存">Dalvik和本地堆上的内存<a href="post/Learn-OpenGL-Lesson-Seven#Dalvik和本地堆上的内存"></a></h2><p>如果你在本地堆上分配大量内存把并将其释放，您迟早会遇到心爱的<code>OutOfMemoryError</code> ，背后有几个原因：</p><ol><li>您可能认为通过让引用超出范围而自动释放了内存，但是本地内存似乎需要一些额外的GC周期才能完全清理，如果没有足够可用的内存并且尚未释放本地内存，Dalvik将抛出异常。</li><li>本地堆可能会<a href="https://stackoverflow.com/questions/6892676/android-bitmap-limit-preventing-java-lang-outofmemory" target="_blank" rel="noopener">碎片化</a>，调用<code>allocateDirect()</code>将会莫名其妙失败，尽管似乎有足够的内存可用。有时它有助于进行较小的分配，释放它，然后再次尝试更大的分配。</li></ol><p>如何能避免这些问题？除了希望Google在未来的版本中改进Dalvik的行为之外，并不多。或者通过本地代码进行分配或预先分配一大块内存来自行管理堆，并根据此分离缓冲区。</p><blockquote><p>注意：这些信息最初写于2012年初，现在Android使用了一个名为ART的不同运行时，它可能在相同程度上不会遇到这些问题。</p></blockquote><h2 id="移动到顶点缓冲区对象">移动到顶点缓冲区对象<a href="post/Learn-OpenGL-Lesson-Seven#移动到顶点缓冲区对象"></a></h2><p>现在我们已经回顾了使用客户端缓冲区，让我们继续讨论顶点缓冲区对象！首先，我们需要回顾几个非常重要的问题：</p><h3 id="1-缓冲区必须创建在一个有效的OpenGL上下文中">1. 缓冲区必须创建在一个有效的OpenGL上下文中<a href="post/Learn-OpenGL-Lesson-Seven#1-缓冲区必须创建在一个有效的OpenGL上下文中"></a></h3><p>这似乎是一个明显的观点，但是它仅仅提醒你必须等到<code>onSurfaceCreated()</code>执行，并且你必须注意OpenGL ES调用是在GL线程上完成的。<br>看这个文档：<a href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="noopener">iOS OpenGL ES编程指南</a>，它可能是为iOS写的，但是OpenGL ES在Android的行为和这相同。</p><h3 id="2-顶点缓冲区对象使用不当会导致图形驱动程序崩溃">2. 顶点缓冲区对象使用不当会导致图形驱动程序崩溃<a href="post/Learn-OpenGL-Lesson-Seven#2-顶点缓冲区对象使用不当会导致图形驱动程序崩溃"></a></h3><p>当你使用顶点缓冲对象时，需要注意传递的数据。不当的值将会导致OpenGL ES系统库或图形驱动库本地崩溃。在我的Nexus S上，一些游戏完全卡在我的手机上或导致手机重启，因为图形驱动因为他们的指令崩溃。并非所有的崩溃都会锁定您的设备，但至少您不会看到“此应用已停止工作”的对话框。您的活动将在没有警告的情况下重新启动，您将获得唯一的信息可能是日志中的本地调试跟踪。</p><h2 id="上传顶点数据到GPU">上传顶点数据到GPU<a href="post/Learn-OpenGL-Lesson-Seven#上传顶点数据到GPU"></a></h2><p>要上传数据到GPU，我们需要像以前一样创建客户端缓冲区的相同步骤：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cubePositionsBuffer = ByteBuffer.allocateDirect(cubePositions.length * BYTES_PER_FLOAT)</span><br><span class="line">.order(ByteOrder.nativeOrder()).asFloatBuffer();</span><br><span class="line">cubePositionsBuffer.put(cubePositions).position(<span class="number">0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>一旦我们有了客户端缓冲区，我们就可以创建一个顶点缓冲区对象，并使用一下指令将数据从客户端内存上传到GPU：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，我们要尽可能的申请更多的缓冲区</span></span><br><span class="line"><span class="comment">// 这将为我们提供这些缓冲区的handle</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> buffers[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">GLES20.glGenBuffers(<span class="number">3</span>, buffers, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定这个缓冲区，将来的指令将单独影响此缓冲区</span></span><br><span class="line">GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, buffers[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端内存中的数据转移到缓冲区</span></span><br><span class="line"><span class="comment">// 我们能在此次调动后释放客户端内存</span></span><br><span class="line">GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, cubePositionsBuffer.capacity() * BYTES_PER_FLOAT,</span><br><span class="line">    cubePositionsBuffer, GLES20.GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要提醒：完成缓冲后，从缓冲区取消绑定</span></span><br><span class="line">GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure><p>一旦数据上传到了OpenGL ES，我们就可以释放这个客户端内存，因为我们不需要再继续保留它。这是<a href="http://www.learnopengles.com/android-lesson-seven-an-introduction-to-vertex-buffer-objects-vbos/GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER,%200);" target="_blank" rel="noopener">glBufferData</a>的解释：</p><ul><li><em>GL_ARRAY_BUFFER：</em> 这个缓冲区包含顶点数据数组</li><li><em>cubePositionsBuffer.capacity() </em> BYTES_PER_FLOAT：* 这个缓冲区因该包含的字节数</li><li><em>cubePositionsBuffer：</em> 将要拷贝到这个顶点缓冲区对象的源</li><li><em>GL_STATIC_DRAW：</em> 这个缓冲区不会动态更新</li></ul><p>我们对<code>glVertexAttribPointer</code>的调用看起来有点儿不同，因为最后一个参数现在是偏移量而不是指向客户端内存的指针：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入位置信息</span></span><br><span class="line">GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, mCubePositionsBufferIdx);</span><br><span class="line">GLES20.glEnableVertexAttribArray(mPositionHandle);</span><br><span class="line">mGlEs20.glVertexAttribPointer(mPositionHandle, POSITION_DATA_SIZE, GLES20.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>像以前一样，我们绑定到缓冲区，然后启用顶点数组。由于缓冲区早已绑定，当从缓冲区读取数据时，我们仅需要告诉OpenGL开始的偏移。因为我们使用的特定的缓冲区，我们传入偏移量0。另请注意，我们使用自定义绑定来调用<code>glVertexAttribPointer</code>，因为官方SKD缺少此特定函数调用。</p><p>一旦我们用缓冲区绘制完成，我们应该解除它：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure><p>当我们不想在保留缓冲区时，我们可以释放内存：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] buffersToDelete = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; mCubePositionsBufferIdx, mCubeNormalsBufferIdx,</span><br><span class="line">    mCubeTexCoordsBufferIdx &#125;;</span><br><span class="line">GLES20.glDeleteBuffers(buffersToDelete.length, buffersToDelete, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure><h2 id="打包顶点缓冲区对象">打包顶点缓冲区对象<a href="post/Learn-OpenGL-Lesson-Seven#打包顶点缓冲区对象"></a></h2><p>我们还可以使用单个缓冲区打包顶点缓冲区对象的所有顶点数据。打包顶点缓冲区的创建和上面相同，唯一的区别是我们从打包客户端缓冲区开始。打包缓冲区渲染也是一样的，除了我们需要传偏移量，就像在客户端内存中使用打包缓冲区一样：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> stride = (POSITION_DATA_SIZE + NORMAL_DATA_SIZE + TEXTURE_COORDINATE_DATA_SIZE)</span><br><span class="line">    * BYTES_PER_FLOAT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入位置信息</span></span><br><span class="line">GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, mCubeBufferIdx);</span><br><span class="line">GLES20.glEnableVertexAttribArray(mPositionHandle);</span><br><span class="line">mGlEs20.glVertexAttribPointer(mPositionHandle, POSITION_DATA_SIZE,</span><br><span class="line">    GLES20.GL_FLOAT, <span class="keyword">false</span>, stride, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入法线信息</span></span><br><span class="line">GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, mCubeBufferIdx);</span><br><span class="line">GLES20.glEnableVertexAttribArray(mNormalHandle);</span><br><span class="line">mGlEs20.glVertexAttribPointer(mNormalHandle, NORMAL_DATA_SIZE,</span><br><span class="line">    GLES20.GL_FLOAT, <span class="keyword">false</span>, stride, POSITION_DATA_SIZE * BYTES_PER_FLOAT);</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>注意：偏移量需要以字节为单位指定。与之前一样解除绑定和删除缓冲区的相同注意事项也适用。</p><h2 id="将顶点数据放到一起">将顶点数据放到一起<a href="post/Learn-OpenGL-Lesson-Seven#将顶点数据放到一起"></a></h2><p>这节课已构建了多立方体组成的立方体，每个面的立方体数量体相同。它将在1x1x1立方体和16x16x16立方体之间构建立方体。由于每个立方体共享相同的法线和纹理数据，因此在初始化客户端缓冲区时将重复复制此数据。所有立方体都将在同一个缓冲区对象中结束。</p><p>您可以查看课程中的代码并查看使用和不使用VBO，以及使用和不使用打包缓冲区进行渲染的示例。检查代码以查看如何处理一下某些操作：</p><ul><li>通过<code>runOnUiThread()</code>将事件从OpenGL线程发布回UI主线程</li><li>异步生成顶点数据</li><li>处理内存溢出异常</li><li>我们移除了<code>glEnable(GL_TEXTURE_2D)</code>的调用，因为它实际在OpenGL ES 2是一个无效枚举。这是以前的固定写法延续下来的，在OpenGLES2中，这些东西由着色器处理，因此不需要使用<code>glEnable</code>或<code>glDisable</code>。</li><li>怎样使用不同的方式进行渲染，而不添加太多的if语句和条件。</li></ul><h2 id="进一步练习">进一步练习<a href="post/Learn-OpenGL-Lesson-Seven#进一步练习"></a></h2><p>您何时使用顶点缓冲区？什么时候从客户端内存传输数据更好？使用顶点缓冲区对象有哪些缺点？您将如何改进异步加载代码？</p><h2 id="教程目录">教程目录<a href="post/Learn-OpenGL-Lesson-Seven#教程目录"></a></h2><ul><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">OpenGL Android课程二：环境光和漫射光</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">OpenGL Android课程三：使用每片段照明</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four">OpenGL Android课程四：介绍纹理基础</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five">OpenGL Android课程五：介绍混合（Blending）</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six">OpenGL Android课程六：介绍纹理过滤</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VBO）</a></li></ul><h2 id="打包教材">打包教材<a href="post/Learn-OpenGL-Lesson-Seven#打包教材"></a></h2><p>可以在Github下载本课程源代码：<a href="https://github.com/learnopengles/Learn-OpenGLES-Tutorials" target="_blank" rel="noopener">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href="https://market.android.com/details?id=com.learnopengles.android" target="_blank" rel="noopener">google play 下载apk</a><br>为了方便大家下载，“我”也编译了个apk，：<a href="https://github.com/xujiaji/LearnOpenGL/releases" target="_blank" rel="noopener">github download</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文标题：Android Lesson Seven: An Introduction to Vertex Buffer Objects (VBOs)&lt;br&gt;原文链接：&lt;a href=&quot;http://www.learnopengles.com/android-lesson-seven-an-introduction-to-vertex-buffer-objects-vbos/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.learnopengles.com/android-lesson-seven-an-introduction-to-vertex-buffer-objects-vbos/&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/categories/OpenGL/"/>
    
    
      <category term="Android" scheme="https://blog.xujiaji.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/tags/OpenGL/"/>
    
      <category term="学习" scheme="https://blog.xujiaji.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://blog.xujiaji.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Android课程六：介绍纹理过滤</title>
    <link href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six/index.html"/>
    <id>https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six/index.html</id>
    <published>2019-02-19T08:24:18.000Z</published>
    <updated>2019-04-08T06:56:15.793Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译文</p></blockquote><p>原文标题：Android Lesson Six: An Introduction to Texture Filtering<br>原文链接：<a href="http://www.learnopengles.com/android-lesson-six-an-introduction-to-texture-filtering/" target="_blank" rel="noopener">http://www.learnopengles.com/android-lesson-six-an-introduction-to-texture-filtering/</a><br><a id="more"></a></p><hr><h1 id="介绍纹理过滤">介绍纹理过滤<a href="post/Learn-OpenGL-Lesson-Six#介绍纹理过滤"></a></h1><div class="article-bounded"><div class="article-table"><table><tbody><tr><td>这节课，我们将介绍基本纹理过滤的不同类型和怎样使用它们，<br>包括最邻近（nearest-neighbour）过滤，<a href="https://en.wikipedia.org/wiki/Bilinear_filtering" target="_blank" rel="noopener">双线性(bilinear)过滤</a>，<br>和使用mipmap的<a href="https://en.wikipedia.org/wiki/Trilinear_filtering" target="_blank" rel="noopener">三线性(trilinear)过滤</a>。<br><br>你将学习如何使纹理看起来更平滑，以及平滑带来的缺点。<br>[这儿有旋转物体][]的不同方式，本课使用了其中一。</td><td style="text-align:center"><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190219164050.png" alt="screenshot"></td></tr></tbody></table></div></div><h2 id="前提条件">前提条件<a href="post/Learn-OpenGL-Lesson-Six#前提条件"></a></h2><p>强烈建议您先阅读<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four">OpenGL Android课程四：介绍纹理基础</a>，理解纹理映射在OpenGL中的基本使用。</p><h2 id="什么是纹理过滤？">什么是纹理过滤？<a href="post/Learn-OpenGL-Lesson-Six#什么是纹理过滤？"></a></h2><p>OpenGLES中的纹理由元素数组组成，被称为纹素(texels)，其中包含颜色和alpha值。这与显示器相对应，显示器由一堆像素组成，并在每个点显示不同的颜色。在OpenGL中纹理被用在三角形上并绘制到屏幕，因此这些纹理能绘制出各种各样的尺寸和方向。OpenGL中的纹理过滤选项告诉它如何根据具体情况将纹理像素过滤到设备的像素上。</p><blockquote><p>有三种情况：</p></blockquote><ul><li>每个纹素映射到多个像素，这被称为放大(magnification)</li><li>每个纹素精确的映射到一个像素，过滤不适合这种情况</li><li>每个纹素映射少于一个像素，这被称为缩小(minification)</li></ul><p>OpenGL允许我们为放大和缩小分配过滤器，并允许我们使用最邻近、双线性和三线性过滤。我们将在下面解释这些意思。</p><h2 id="放大和缩小">放大和缩小<a href="post/Learn-OpenGL-Lesson-Six#放大和缩小"></a></h2><p>这里是放大和缩小的最邻近渲染的可视化，当您用USB连接你的Android设备时使用这个可爱的Android显示成功连接。</p><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221100843.png" alt="cute android" class="article-img"></p><h3 id="放大">放大<a href="post/Learn-OpenGL-Lesson-Six#放大"></a></h3><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221100936.png" alt="magnification android" class="article-img"></p><p>正如您所见，纹素现在很容易看到，因为当前一个纹素覆盖了很多像素展示出来。</p><h3 id="缩小">缩小<a href="post/Learn-OpenGL-Lesson-Six#缩小"></a></h3><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221101211.png" alt="minification android" class="article-img"></p><p>随着缩小，许多纹素不能渲染到有限的像素上，许多细节将会丢失。</p><h2 id="纹理过滤模式">纹理过滤模式<a href="post/Learn-OpenGL-Lesson-Six#纹理过滤模式"></a></h2><h3 id="双线性插值（Bilinear-interpolation）">双线性插值（Bilinear interpolation）<a href="post/Learn-OpenGL-Lesson-Six#双线性插值（Bilinear-interpolation）"></a></h3><p>当纹素值之间没有插值时，在放大示例中，纹理的纹素清晰可见为大正方形。当使用最邻近方式时，像素将会分配到最邻近的像素。</p><p>通过切换到双线性插值，渲染质量显著提高。这些值将会在邻近的四个像素之间线性插值，而不是将一组像素分配给邻近相同的纹素值。每个像素被平滑化，使得最后的图片看起来也更平滑：</p><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221103115.png" alt="smoother android" class="article-img"></p><p>一些块效果仍然很明显，但是这个图片看起来比之前更加平滑。那些在3D加速卡出现前玩过3D游戏的人将会记得软件渲染游戏和硬件加速游戏之间的特性：软件渲染游戏根本没有进行预计算处理，所以一切都显示得块状和锯齿状。一旦人们开始使用图形加速，这些东西都将变得平滑。</p><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221104453.png" alt="smooth" class="article-img"></p><p>双线性插值大多使用在放大。它也能使用在缩小，但是超过某个度，我们将会遇到同样的问题，我们在尝试将太多的纹素放到相同的像素上。OpenGL仅使用最多4个纹素渲染一个像素，因此许多信息仍然会丢失。</p><p>如果我们看应用了双线性插值的纹理，当我们在远处看它移动时看起来会很嘈杂，因为每帧都会选择不同的纹素。</p><h3 id="纹理映射（Mipmapping）">纹理映射（Mipmapping）<a href="post/Learn-OpenGL-Lesson-Six#纹理映射（Mipmapping）"></a></h3><p>我们如何才能在缩小纹理时不引用嘈杂并使用上所有纹素呢？我们可以生成一组优化后的不同尺寸的纹理，然后在我们运行的时候使用它们。由于这些纹理已预先生成，它们能使用更多高昂的技术去过滤所有纹素，并且在运行时OpenGL会根据纹理在屏幕上的最终大小选择最合适的层。</p><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221143838.png" alt="textures set" class="article-img"></p><p>生成的图片可以具有更多细节，更少噪点，并且整体上看起来更好。尽管需要更多的内存，但渲染速度也会更快，因为较小的层级能更容易保存在GPU的纹理缓存中。让我们来仔细研究一下原尺寸的1/8倍的图片，在使用了双线性过滤使用纹理映射和双线性过滤没有使用映射。为了清楚图片已被扩大：</p><h4 id="双线性过滤没有mipmap">双线性过滤没有mipmap<a href="post/Learn-OpenGL-Lesson-Six#双线性过滤没有mipmap"></a></h4><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221145134.png" alt="without mipmaps" class="article-img"></p><h4 id="双线性过滤-mipmap">双线性过滤+mipmap<a href="post/Learn-OpenGL-Lesson-Six#双线性过滤-mipmap"></a></h4><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221145249.png" alt="with mipmaps" class="article-img"></p><p>使用mipmap的版本拥有更多细节，由于图像预处理到单独的层级，所有纹素最终都会在最终的图像中使用。</p><h3 id="三线性过滤（Trilinear-filtering）">三线性过滤（Trilinear filtering）<a href="post/Learn-OpenGL-Lesson-Six#三线性过滤（Trilinear-filtering）"></a></h3><p>当使用双线性过滤的mipmap时，有时在渲染场景中可以看到明显的跳跃或线，由于OpenGL在纹理的不同mipmap层级之间切换。比较不同的OpenGL纹理的过滤模式将在下面进一步指出。</p><p>三线性插值通过在不同mipmap层级之间插值来解决这个问题，这样总共8个纹素将用于插值得到最终的像素值，使得图像更平滑。</p><h2 id="OpenGL-纹理过滤模式">OpenGL 纹理过滤模式<a href="post/Learn-OpenGL-Lesson-Six#OpenGL-纹理过滤模式"></a></h2><p>OpenGL有两个可被设置的参数：</p><ul><li><code>GL_TEXTURE_MIN_FILTER</code> 纹理缩小时的过滤模式</li><li><code>GL_TEXTURE_MAG_FILTER</code> 纹理放大时的过滤模式</li></ul><p>这些相对应于上面的缩小和放大描述。  </p><ul><li><code>GL_TEXTURE_MIN_FILTER</code>接受以下选项：<ul><li><code>GL_NEAREST</code></li><li><code>GL_LINEAR</code></li><li><code>GL_NEAREST_MIPMAP_NEAREST</code></li><li><code>GL_NEAREST_MIPMAP_LINEAR</code></li><li><code>GL_LINEAR_MIPMAP_NEAREST</code></li><li><code>GL_LINEAR_MIPMAP_LINEAR</code></li></ul></li><li><code>GL_TEXTURE_MAG_FILTER</code>接受以下选项：<ul><li><code>GL_NEAREST</code></li><li><code>GL_LINEAR</code></li></ul></li></ul><p><code>GL_NEAREST</code> 对应最邻近渲染；<br><code>GL_LINEAR</code> 对应双线性过滤；<br><code>GL_LINEAR_MIPMAP_NEAREST</code> 对应双线性过滤+mipmap；<br><code>GL_LINEAR_MIPMAP_LINEAR</code> 对应三线性过滤；<br>本课中将进一步介绍图形示例和最常见选项的进一步说明。</p><h3 id="怎样设置纹理过滤模式">怎样设置纹理过滤模式<a href="post/Learn-OpenGL-Lesson-Six#怎样设置纹理过滤模式"></a></h3><p>我们首先需要绑定纹理，然后我们在这个纹理上设置合适的过滤参数：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureHandle);</span><br><span class="line">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, filter);</span><br></pre></td></tr></table></div></figure><h3 id="怎样生成mipmap">怎样生成mipmap<a href="post/Learn-OpenGL-Lesson-Six#怎样生成mipmap"></a></h3><p>这真的很容易！在加载纹理到OpenGL中后，纹理仍然是绑定的，我们可以简单的调用：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glGenerateMipmap(GLES20.GL_TEXTURE_2D);</span><br></pre></td></tr></table></div></figure><p>它将为我们生成所有的mipmap层级，并且这些层级会根据纹理过滤自动使用。</p><h2 id="它看起来怎么样？">它看起来怎么样？<a href="post/Learn-OpenGL-Lesson-Six#它看起来怎么样？"></a></h2><p>以下是可用的最常见的组合的屏幕截图，当你看到它运动中时，效果更加引人注目，因此我建议下载<a href="https://github.com/xujiaji/LearnOpenGL/releases" target="_blank" rel="noopener">这个App</a>并试一试。</p><h3 id="最邻近渲染">最邻近渲染<a href="post/Learn-OpenGL-Lesson-Six#最邻近渲染"></a></h3><p>这个模式让人想起旧版3D游戏软件的渲染。</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GL_TEXTURE_MIN_FILTER = GL_NEAREST</span><br><span class="line">GL_TEXTURE_MAG_FILTER = GL_NEAREST</span><br></pre></td></tr></table></div></figure><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221163746.png" alt="nearest nearest" class="article-img"></p><h3 id="双线性过滤，mipmap">双线性过滤，mipmap<a href="post/Learn-OpenGL-Lesson-Six#双线性过滤，mipmap"></a></h3><p>许多支持3D加速的首批游戏都使用此模式，这是今天在Android手机上平滑纹理的有效方式。</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GL_TEXTURE_MIN_FILTER = GL_LINEAR_MIPMAP_NEAREST</span><br><span class="line">GL_TEXTURE_MAG_FILTER = GL_LINEAR</span><br></pre></td></tr></table></div></figure><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221164349.png" alt="linear mipmap" class="article-img"></p><p>静态图上很难看图问题，但是当物体运动时，您可能会注意到渲染的像素在mipmap层级之间切换的水平条带。</p><h3 id="三线性过滤">三线性过滤<a href="post/Learn-OpenGL-Lesson-Six#三线性过滤"></a></h3><p>此模式通过在mipmap层级之间进行插值，改进了使用mipmap的双线性过滤的渲染质量。</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GL_TEXTURE_MIN_FILTER = GL_LINEAR_MIPMAP_LINEAR</span><br><span class="line">GL_TEXTURE_MAG_FILTER = GL_LINEAR</span><br></pre></td></tr></table></div></figure><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190221165703.png" alt="trilinear" class="article-img"></p><p>像素在近距离和远距离之间完全平滑；事实上，纹理现在可能在倾斜角度下显示的过于平滑。<br><a href="https://en.wikipedia.org/wiki/Anisotropic_filtering" target="_blank" rel="noopener">各向异性过滤（Anisotropic filtering）</a>是一种更先进的技术，受到某些移动GPU的支持，可用于改善最终结果，超出三线性过滤所能提供的效果。</p><h3 id="进一步练习">进一步练习<a href="post/Learn-OpenGL-Lesson-Six#进一步练习"></a></h3><p>使用其他模式可以达到什么样的效果？例如，您何时会使用像<code>GL_NEAREST_MIPMAP_LINEAR</code>这样的东西？</p><h2 id="教程目录">教程目录<a href="post/Learn-OpenGL-Lesson-Six#教程目录"></a></h2><ul><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">OpenGL Android课程二：环境光和漫射光</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">OpenGL Android课程三：使用每片段照明</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four">OpenGL Android课程四：介绍纹理基础</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five">OpenGL Android课程五：介绍混合（Blending）</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six">OpenGL Android课程六：介绍纹理过滤</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）</a></li></ul><h2 id="打包教材">打包教材<a href="post/Learn-OpenGL-Lesson-Six#打包教材"></a></h2><p>可以在Github下载本课程源代码：<a href="https://github.com/learnopengles/Learn-OpenGLES-Tutorials" target="_blank" rel="noopener">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href="https://market.android.com/details?id=com.learnopengles.android" target="_blank" rel="noopener">google play 下载apk</a><br>“我”也编译了个apk，方便大家下载：<a href="https://github.com/xujiaji/LearnOpenGL/releases" target="_blank" rel="noopener">github download</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文标题：Android Lesson Six: An Introduction to Texture Filtering&lt;br&gt;原文链接：&lt;a href=&quot;http://www.learnopengles.com/android-lesson-six-an-introduction-to-texture-filtering/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.learnopengles.com/android-lesson-six-an-introduction-to-texture-filtering/&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/categories/OpenGL/"/>
    
    
      <category term="Android" scheme="https://blog.xujiaji.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/tags/OpenGL/"/>
    
      <category term="学习" scheme="https://blog.xujiaji.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://blog.xujiaji.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Android课程五：介绍混合（Blending）</title>
    <link href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five/index.html"/>
    <id>https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five/index.html</id>
    <published>2019-02-12T08:37:00.000Z</published>
    <updated>2019-04-08T06:55:57.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译文</p></blockquote><p>原文标题：Android Lesson Five: An Introduction to Blending<br>原文链接：<a href="http://www.learnopengles.com/android-lesson-five-an-introduction-to-blending/" target="_blank" rel="noopener">http://www.learnopengles.com/android-lesson-five-an-introduction-to-blending/</a><br><a id="more"></a></p><hr><h1 id="介绍混合（Blending）">介绍混合（Blending）<a href="post/Learn-OpenGL-Lesson-Five#介绍混合（Blending）"></a></h1><div class="article-bounded"><div class="article-table"><table><tbody><tr><td>这节课，我们来学习混合(blending)在OpenGL中的<br>基本使用。我们来看看如何打开或关闭混合，怎样设置<br>不同的混合模式，以及不同的混合模式如何模仿显示生<br>活中的效果。在后面的课程中，我们还将介绍如何使用<br>alpha通道，如何使用深度缓冲区在同一个场景中渲染<br>半透明和不透明的物体，以及什么时候按深度排序对象，<br>以及为什么。<br><br>我们还将研究如何监听触摸事件，然后基于此更改渲染<br>状态。</td><td style="text-align:center"><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190212163914.png" alt="display"><br><em>基本混合</em></td></tr></tbody></table></div></div><h2 id="前提条件">前提条件<a href="post/Learn-OpenGL-Lesson-Five#前提条件"></a></h2><p>本系列每个课程构建都是以前一个课程为基础。然而，对于这节课，如果您理解了<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a>就足够了。尽管代码基本上是前一课的，照明和纹理部分已在本课中移除，因此我们仅关注混合。</p><h2 id="混合（Blending）">混合（Blending）<a href="post/Learn-OpenGL-Lesson-Five#混合（Blending）"></a></h2><p>混合是将一种颜色与另一种颜色组合以获得第三种颜色的行为。我们在现实世界任何时候都能看到混合：当光穿过玻璃时，当它从表面反射时，当光源本身叠加在背景上时，例如我们在晚上看到一盏明亮的路灯周围的耀斑。</p><p>OpenGL有不同的混合模式，我们能使用它模拟这种效果。在OpenGL中，混合发生在渲染过程的后期：一旦片段着色器计算出片段的最终输出颜色并且它即将被写入帧缓冲区，就会发生这种情况。通常情况下，这片段会覆盖之前所有内容，但如果启用了混合，那么该片段将与之前的片段混合。</p><p>默认情况下，当<code>glBlendEquation()</code>设置为默认值<code>GL_FUNC_ADD</code>时OpenGL的默认混合方程式为：</p><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 = （源因子 * 源片段） + （目标因子 * 目标片段）</span></span><br><span class="line">output = (source factor * source fragment) + (destination factor * destination fragment)</span><br></pre></td></tr></table></div></figure><p>OpenGL ES 2 中还有另外两种模式<code>GL_FUNC_SUBTRACT</code>和<code>GL_FUNC_REVERSE_SUBTRACT</code>。<br>这些可能在以后的教程中介绍，然而，当我尝试调用此函数时，我在Nexus S上遇到了<br><code>UnsupportedOperationException</code>，因此Android实现可能实际上不支持此功能。<br>这不是世界末日，因为你可以用<code>GL_FUNC_ADD</code>做很多事情。</p><p>使用函数<code>glBlendFunc()</code>设置源因子和目标因子。下面将给出几个常见混合因子的概述；更多信息以及不同可能的因素的列举，请参阅<a href="http://www.khronos.org/opengles/sdk/docs/man/" target="_blank" rel="noopener">Khronos在线手册</a>：</p><ul><li><a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glBlendFunc.xml" target="_blank" rel="noopener">glBlendFunc()</a></li><li><a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glBlendEquation.xml" target="_blank" rel="noopener">glBlendEquation()</a></li></ul><h3 id="截取（Clamping）">截取（Clamping）<a href="post/Learn-OpenGL-Lesson-Five#截取（Clamping）"></a></h3><p>OpenGL预期的输入被限制在[0,1]的范围内，并且输入也被限制在[0,1]。这在实践中意味着当您进行混合时，颜色可以在色调中移动。<br>如果继续想帧缓冲区添加红色（RGB = 1，0，0），最终颜色会是红色。如果想添加一点儿绿色，您要添加（RGB = 1，0.1，0）到缓冲区，即使您开始带红色的色调，最后也会得到黄色！<br>打开混合时，您可以在本课程的Demo中看到此效果：不同颜色的重叠的颜色变得过饱和。</p><h2 id="不同类型的混合以及它们有怎样不同的效果">不同类型的混合以及它们有怎样不同的效果<a href="post/Learn-OpenGL-Lesson-Five#不同类型的混合以及它们有怎样不同的效果"></a></h2><h3 id="相加混合（Additive-blending）">相加混合（Additive blending）<a href="post/Learn-OpenGL-Lesson-Five#相加混合（Additive-blending）"></a></h3><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:center"><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190213200752.png" alt="rgb"></th></tr></thead><tbody><tr><td style="text-align:center"><em>RGB颜色相加模型； 来源：Wikipedia</em></td></tr></tbody></table></div></div><p>相加混合是当我们添加不同颜色在一起的混合，这就是我们的视觉与光一起工作的模式，这就是我们如何在我们的显示器上感知数百万种不同的颜色——它们实际上只是将三种不同的原色混合在一起。</p><p>这种混合在3D混合中很有用，例如在粒子效果中，它们似乎发出光线和覆盖物，例如灯光周围的光晕，或光剑周围的发光效果。</p><p>相加混合能通过调用<code>glBlendFunc(GL_ONE, GL_ONE)</code>指定，<br>混合的结果等式<code>输出=（1 * 源片段） + （1 * 目标片段）</code>，运算后：<code>输出=源片段 + 目标片段</code></p><h3 id="相乘混合（Multiplicative-blending）">相乘混合（Multiplicative blending）<a href="post/Learn-OpenGL-Lesson-Five#相乘混合（Multiplicative-blending）"></a></h3><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:center"><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190213202603.png" alt="rg"></th></tr></thead><tbody><tr><td style="text-align:center"><em>光照贴图的一个例子</em></td></tr></tbody></table></div></div><p>相乘混合（也称为调制）是另一种有用的混合模式，它表示光在通过过滤器时的行为方式，或从被点燃的物体反射并进入我们的眼睛。一个红色的物体看上去是红色是因为白光照射到这个物体上，蓝光和绿光被吸收，只有红光反射回我们的眼睛。在上面的例子中，我们能看到一些红色和绿色，但是很少会有一点蓝色。</p><p>当多纹理不可用时，乘法混合用于在游戏中实现光照贴图。纹理与光照贴图相乘，以填充在明亮和阴影的区域。</p><p>相乘混合能通过调用<code>glBlendFunc(GL_DST_COLOR, GL_ZERO)</code>指定，<br>其混合的结果等式<code>输出=（目标片段 * 源片段）+ （0 * 目标片段）</code>，写作：<code>输出=目标片段 * 源片段</code>。</p><h3 id="插值混合（Interpolative-blending）">插值混合（Interpolative blending）<a href="post/Learn-OpenGL-Lesson-Five#插值混合（Interpolative-blending）"></a></h3><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:center"><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190213205158.png" alt="textures"></th></tr></thead><tbody><tr><td style="text-align:center"><em>一个两个纹理一起插值的案例</em></td></tr></tbody></table></div></div><p>插值混合结合了乘法和加法，以提供插值效果。与添加和调制本身不同，此混合模式也可是依赖绘制顺序的。因此在某些情况下，如果您先画出最远的半透明物体，然后绘制更近的物体，结果才会是正确。即使排序也不是完美，因为三角形可能重叠并相交，但产生的伪像可能是可接受的。</p><p>插值通常是将相邻的表面混合在一起，以及做有色玻璃或淡入淡出的效果。上面这个图片显示了两个纹理（纹理来自<a href="http://pdtextures.blogspot.com/" target="_blank" rel="noopener">公共领域纹理</a>）使用插值混合在一起。</p><p>插值混合能通过调用<code>glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)</code>指定，<br>其混合结果等式<code>输出 = （源alpha * 源片段） + （（1 - 源alpha） * 目标片段）</code>。这是一个例子：</p><p>想象一下，我们正在绘制一个只有25%不透明的绿色（0，1，0），当前屏幕上的物体时红色（1，0，0）。</p><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输出 = （源因子 * 源片段） + （目标因子 * 目标片段）</span><br><span class="line">输出 = （源alpha * 源片段） + （（<span class="number">1</span> - 源alpha） * 目标片段）</span><br><span class="line"></span><br><span class="line">输出 = (<span class="number">0.25</span> * (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)) + (<span class="number">0.72</span> * (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">输出 = (<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0</span>) + (<span class="number">0.75</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">输出 = (<span class="number">0.75</span>, <span class="number">0.25</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></div></figure><p>注意，我们不需要对目标alpha做任何涉及，因为这个帧缓冲区本身不需要alpha通道，这为我们提供了更多的颜色通道位。</p><h2 id="使用混合">使用混合<a href="post/Learn-OpenGL-Lesson-Five#使用混合"></a></h2><p>在我们的课程中，我们的Demo将使用相加混合将立方体显示为光的发射器。发光的东西不需要其他光源照亮，因此这个Demo中没有灯光。我也删除了纹理，虽然它可以很好地使用。本课程的着色器程序很简单；我们只需要一个可传递颜色的着色器。</p><h3 id="顶点着色器">顶点着色器<a href="post/Learn-OpenGL-Lesson-Five#顶点着色器"></a></h3><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_MVPMatrix;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Position;</span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    v_Color = a_Color;</span><br><span class="line">    <span class="built_in">gl_Position</span> = u_MVPMatrix * a_Position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="片段着色器">片段着色器<a href="post/Learn-OpenGL-Lesson-Five#片段着色器"></a></h3><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = v_Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="打开混合">打开混合<a href="post/Learn-OpenGL-Lesson-Five#打开混合"></a></h3><p>打开混合就像是做一些方法调用那么简单：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭剔除去掉背面</span></span><br><span class="line">GLES20.glDisable(GLES20.GL_CULL_FACE);</span><br><span class="line"><span class="comment">// 关闭深度测试</span></span><br><span class="line">GLES20.glDisable(GLES20.GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动混合</span></span><br><span class="line">GLES20.glEnable(GLES20.GL_BLEND);</span><br><span class="line">GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE);</span><br></pre></td></tr></table></div></figure><p>我们关闭背面剔除，是因为如果立方体是半透明的，那么现在我们能看到立方体的背面。我们需要绘制它们，否则可能看起来会很奇怪。出于同样的原因我们关闭了深度测试。</p><h2 id="学习触摸事件并进行操作">学习触摸事件并进行操作<a href="post/Learn-OpenGL-Lesson-Five#学习触摸事件并进行操作"></a></h2><p>你将注意到，当您运行Demo时，可以通过点击屏幕来打开和关闭混合。</p><p>现实触摸事件，您首先需要创建您的<code>GLSurfaceView</code>自定义view。在这个view中，创建一个默认构造用来调用父类，创建一个新的方法来接收特定的渲染器替换常用接口，并覆写<code>onTouchEvent()</code>。我们传入一个具体的渲染器类，因为我们将要在<code>onTouchEvent()</code>方法中调用这个类的特定方法。</p><p>在Android中，OpenGL渲染器在独立的线程中完成，因此我们还将看看如何安全的从正在监听触摸事件的主线程调度到单独的渲染器线程。</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LessonFiveGLSurfaceView</span> <span class="keyword">extends</span> <span class="title">GLSurfaceView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LessonFiveRenderer mRenderer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LessonFiveGLSurfaceView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                event == <span class="keyword">null</span></span><br><span class="line">                || event.getAction() != MotionEvent.ACTION_DOWN</span><br><span class="line">                || mRenderer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确保我们在OpenGL线程上调用switchMode()</span></span><br><span class="line">        <span class="comment">// queueEvent() 是GLSurfaceView的一个方法，它将为我们做到这点</span></span><br><span class="line">        queueEvent(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mRenderer.switchMode();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRenderer</span><span class="params">(LessonFiveRenderer renderer)</span> </span>&#123;</span><br><span class="line">        mRenderer = renderer;</span><br><span class="line">        <span class="keyword">super</span>.setRenderer(renderer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在<code>LessonFiveRenderer</code>中实现<code>switchMode()</code></p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mBlending = !mBlending;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBlending) &#123;</span><br><span class="line">        <span class="comment">// 关闭剔除去掉背面</span></span><br><span class="line">        GLES20.glDisable(GLES20.GL_CULL_FACE);</span><br><span class="line">        <span class="comment">// 关闭深度测试</span></span><br><span class="line">        GLES20.glDisable(GLES20.GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动混合</span></span><br><span class="line">        GLES20.glEnable(GLES20.GL_BLEND);</span><br><span class="line">        GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        GLES20.glEnable(GLES20.GL_CULL_FACE);</span><br><span class="line">        GLES20.glEnable(GLES20.GL_DEPTH_TEST);</span><br><span class="line">        GLES20.glDisable(GLES20.GL_BLEND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>仔细看<code>LessonFiveGLSurfaceView::onTouchEvent()</code>，主要记住触摸事件都是在UI主线程中<br>，而<code>GLSurfaceView</code>在一个单独的线程中创建OpenGL ES上下文，这意味着我们的渲染器的回调也在一个单独的线程中运行。这是一个需要记住的重点，因为我们不能再其他线程调用OpenGL并希望其工作。</p><p>辛运的是，编写<code>GLSurfaceView</code>的人也想到了这点，并提供了一个<code>queueEvent()</code>方法，这使得你可以调用OpenGL线程上的东西。因此，当我们想通过点击屏幕打开和关闭混合时，我们确保通过在UI线程中使用<code>queueEvent()</code>来正确调用OpenGL线程中的内容。</p><h3 id="进一步练习">进一步练习<a href="post/Learn-OpenGL-Lesson-Five#进一步练习"></a></h3><p>这个Demo目前仅使用相加混合，尝试改变其为插值混合并重新添加灯光和纹理。如果您只在黑色背景上绘制两个半透明纹理，绘制顺序是否重要？什么时候重要？</p><h2 id="教程目录">教程目录<a href="post/Learn-OpenGL-Lesson-Five#教程目录"></a></h2><ul><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">OpenGL Android课程二：环境光和漫射光</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">OpenGL Android课程三：使用每片段照明</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four">OpenGL Android课程四：介绍纹理基础</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five">OpenGL Android课程五：介绍混合（Blending）</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six">OpenGL Android课程六：介绍纹理过滤</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）</a></li></ul><h2 id="打包教材">打包教材<a href="post/Learn-OpenGL-Lesson-Five#打包教材"></a></h2><p>可以在Github下载本课程源代码：<a href="https://github.com/learnopengles/Learn-OpenGLES-Tutorials" target="_blank" rel="noopener">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href="https://market.android.com/details?id=com.learnopengles.android" target="_blank" rel="noopener">google play 下载apk</a><br>“我”也编译了个apk，方便大家下载：<a href="https://github.com/xujiaji/LearnOpenGL/releases" target="_blank" rel="noopener">github download</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文标题：Android Lesson Five: An Introduction to Blending&lt;br&gt;原文链接：&lt;a href=&quot;http://www.learnopengles.com/android-lesson-five-an-introduction-to-blending/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.learnopengles.com/android-lesson-five-an-introduction-to-blending/&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/categories/OpenGL/"/>
    
    
      <category term="Android" scheme="https://blog.xujiaji.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/tags/OpenGL/"/>
    
      <category term="学习" scheme="https://blog.xujiaji.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://blog.xujiaji.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Android课程四：介绍纹理基础</title>
    <link href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four/index.html"/>
    <id>https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four/index.html</id>
    <published>2019-02-08T11:26:29.000Z</published>
    <updated>2019-04-08T06:56:03.158Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译文</p></blockquote><p>原文标题：Android Lesson Four: Introducing Basic Texturing<br>原文链接：<a href="http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/" target="_blank" rel="noopener">http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/</a><br><a id="more"></a></p><hr><h1 id="介绍纹理基础">介绍纹理基础<a href="post/Learn-OpenGL-Lesson-Four#介绍纹理基础"></a></h1><div class="article-bounded"><div class="article-table"><table><tbody><tr><td>这是我们Android系列的第四个课程。<br>在本课中，我们将添加我们在<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">第三课</a><br>中学到的内容，并学习如何添加纹理。<br>我们来看看如何从应用资源中获取一张<br>图片加载到OpenGLES中，并展示到<br>屏幕上。<br><br>跟着我一起来，你将马上明白纹理的<br>基本使用方式。</td><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190208193740.png" alt="screenshot"></td></tr></tbody></table></div></div><h2 id="前提条件">前提条件<a href="post/Learn-OpenGL-Lesson-Four#前提条件"></a></h2><p>本系列每个课程构建都是以前一个课程为基础，这节课是<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">第三课</a>的扩展，因此请务必在继续之前复习该课程。</p><blockquote><p>已下是本系列课程的前几课：</p></blockquote><ul><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">OpenGL Android课程二：环境光和漫射光</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">OpenGL Android课程三：使用每片段照明</a></li></ul><h2 id="纹理基础">纹理基础<a href="post/Learn-OpenGL-Lesson-Four#纹理基础"></a></h2><p>纹理映射的艺术（以及照明）是构建逼真的3D世界最重要的部分。没有纹理映射，一切都是平滑的阴影，看起来很人工，就像是90年代的老式控制台游戏。</p><p>第一个开始大量使用纹理的游戏，如Doom和Duke Nukem 3D，通过增加视觉冲击力，大大提升了游戏的真实感——如果在晚上玩可能会真的吓唬到我们。</p><blockquote><p>这里我们来看有纹理和没有纹理的场景</p></blockquote><div class="article-bounded"><div class="article-table"><table><tbody><tr><td style="text-align:center"><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190208215006.png" alt="pre-fragment lighting"><br><em>每片段照明；<br>正方形四个顶点中心位置</em></td><td style="text-align:center"><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190208215108.png" alt="added texture"><br><em>添加了纹理；<br>正方形四个顶点中心位置</em></td><td>看左边的图片，这个场景通过每像<br>素照明和着色点亮。这个场景看起<br>来非常平滑，现实生活中我们走进<br>一个房间有充满了光滑阴影的东西<br>就像是这个立方体。<br><br>在看右边的图片，同样的场景现在<br>纹理化了。环境光也增加了，因为<br>纹理的使用使整个场景变暗，也可<br>以看到纹理对侧面立方体的影响。<br>立方体具有和以前相同数量的多边<br>形，但它们有新纹理看起来更加详<br>细。<br><br>满足于那些好奇的人，这个纹理的<br>资源来自于<a href="http://pdtextures.blogspot.com/2008/03/first-set.html" target="_blank" rel="noopener">公共领域的资源</a></td></tr></tbody></table></div></div><h2 id="纹理坐标">纹理坐标<a href="post/Learn-OpenGL-Lesson-Four#纹理坐标"></a></h2><p>在OpengGL中，纹理坐标时常使用坐标(s,t)代替(x,y)。(s,t)表示纹理上的一个纹理元素，然后映射到多边形。另外需要注意这些纹理坐标和其他OpengGL坐标相似：t(或y)轴指向上方，所以值越高您走的越远。</p><p>大多数计算机图形，y轴指向下方。这意味着左上角是图片的原点(0,0)，并且y值向下递增。换句话说，OpenGL的坐标系和大多数计算机图形相反，这是您需要考虑到的。</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:center"><em>OpenGL的纹理坐标系</em></th></tr></thead><tbody><tr><td style="text-align:center"><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190208225905.png" alt="coordiante"></td></tr></tbody></table></div></div><h2 id="纹理映射基础">纹理映射基础<a href="post/Learn-OpenGL-Lesson-Four#纹理映射基础"></a></h2><p>在本课中，我们将来看看常规2D纹理（<code>GL_TEXTURE_2D</code>）和红，绿，蓝颜色信息（<code>GL_RGB</code>）。OpenGL ES 也提供其他纹理模式让你做更多不同的特殊效果。我们将使用<code>GL_NEAREST</code>查看点采样，<code>GL_LINEAR</code>和MIP-映射将在后面的课程中讲解。</p><p>让我们一起来到代码部分，看看怎样开始在Android中使用基本的纹理。</p><h3 id="顶点着色器">顶点着色器<a href="post/Learn-OpenGL-Lesson-Four#顶点着色器"></a></h3><p>我们将采用上节课中的每像素照明着色器，并添加纹理支持。</p><blockquote><p>这儿是新的变化：</p></blockquote><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> a_TexCoordinate;<span class="comment">// 我们将要传入的每个顶点的纹理坐标信息</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> v_TexCoordinate;  <span class="comment">// 这将会传入到片段着色器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 传入纹理坐标</span></span><br><span class="line">   v_TexCoordinate = a_TexCoordinate;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在顶点着色器中，我们添加一个新的属性类型<code>vec2</code>（一个包含两个元素的数组），将用来放入纹理坐标信息。这将是每个顶点都有，同位置，颜色，法线数据一样。我们也添加了一个新的变量，它将通过三角形表面上的线性插值将数据传入片段着色器。</p><h3 id="片段着色器">片段着色器<a href="post/Learn-OpenGL-Lesson-Four#片段着色器"></a></h3><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D u_Texture;" +  // 传入纹理</span><br><span class="line">...</span><br><span class="line">varying vec2 v_TexCoordinate;" + // 插入的纹理坐标</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class="line">   float diffuse = max(dot(v_Normal, lightVector), 0.1);" +</span><br><span class="line">   <span class="comment">// 根据距离哀减光线</span></span><br><span class="line">   diffuse = diffuse * (1.0 / (1.0 + (0.10 * distance * distance)));" +</span><br><span class="line">   <span class="comment">// 添加环境照明</span></span><br><span class="line">   diffuse = diffuse + 0.3;" +</span><br><span class="line">   <span class="comment">// 颜色乘以亮度哀减和纹理值得到最终的颜色</span></span><br><span class="line">   gl_FragColor = v_Color * diffuse * texture2D(u_Texture, v_TexCoordinate);" +</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>我们添加了一个新的常量类型<code>sampler2D</code>来表示实际纹理数据（与纹理坐标对应），<br>由定点着色器插值传入纹理坐标，我们再调用<code>texture2D(texture, textureCoordinate)</code><br>得到纹理在当前坐标的值，我们得到这个值后再乘以其他项得到最终输出的颜色。</p><p>这种方式添加纹理会使整个场景变暗，因此我们还会稍微增强环境光照并减少光照哀减。</p><h3 id="将一个图片加载到纹理">将一个图片加载到纹理<a href="post/Learn-OpenGL-Lesson-Four#将一个图片加载到纹理"></a></h3><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loadTexture</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> <span class="keyword">int</span> resourceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] textureHandle = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    GLES20.glGenTextures(<span class="number">1</span>, textureHandle, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (textureHandle[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">        options.inScaled = <span class="keyword">false</span>; <span class="comment">// 没有预先缩放</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到图片资源</span></span><br><span class="line">        <span class="keyword">final</span> Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), resourceId, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在OpenGL中绑定纹理</span></span><br><span class="line">        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置过滤</span></span><br><span class="line">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);</span><br><span class="line">        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将位图加载到已绑定的纹理中</span></span><br><span class="line">        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, bitmap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回收位图，因为它的数据已加载到OpenGL中</span></span><br><span class="line">        bitmap.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (textureHandle[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error loading texture."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textureHandle[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这段代码将Android<code>res</code>文件夹中的图形文件读取并加载到OpenGL中，我会解释每一部分的作用。</p><p>我们首先需要告诉OpenGL去为我们创建一个新的<code>handle</code>，这个<code>handle</code>作为一个唯一标识，我们想在OpenGL中引用纹理时就会使用它。</p><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final <span class="type">int</span>[] textureHandle = new <span class="type">int</span>[<span class="number">1</span>];</span><br><span class="line">GLES20.glGenTextures(<span class="number">1</span>, textureHandle, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure><p>这个OpenGL方法可以用来同时生成多个<code>handle</code>，这里我们仅生成一个。</p><p>因为我们这里只需要一个handle去加载纹理。首先，我们需要得到OpenGL能理解的纹理格式。<br>我们不能只从PNG或JPG提供原始数据，因为它不会理解。我们需要做的第一步是将图像文件解码为Android Bitmap对象：</p><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final BitmapFactory.Options options = new BitmapFactory.Options();</span><br><span class="line">options.inScaled = <span class="literal">false</span>; <span class="comment">// 没有预先缩放</span></span><br><span class="line"><span class="comment">// 得到图片资源</span></span><br><span class="line">final Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), resourceId, options);</span><br></pre></td></tr></table></div></figure><p>默认情况下，Android会根据设备的分辨率和你放置图片的资源文件目录而预先缩放位图。我们不希望Android根据我们的情况对位图进行缩放，因此我们将<code>inScaled</code>设置为<code>false</code></p><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在OpenGL中绑定纹理</span></span><br><span class="line">GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置过滤</span></span><br><span class="line">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);</span><br><span class="line">GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);</span><br></pre></td></tr></table></div></figure><p>然后我们绑定纹理，并设置几个参数，绑定一个纹理，并告诉OpenGL后续OpenGL调用需要这样过滤这个纹理。我们将默认过滤器设置为<code>GL_NEAREST</code>，这是最快，也是最粗糙的过滤形式。它所做的就是在屏幕的每个点选择最近的纹素，这可能导致图像伪像和锯齿。</p><ul><li><code>GL_TEXTURE_MIN_FILTER</code> 这是告诉OpenGL在绘制小于原始大小（以像素为单位）的纹理时要应用哪种类型的过滤。</li><li><code>GL_TEXTURE_MAG_FILTER</code> 这是告诉OpenGL在放大纹理到原始大小时要应用哪种类型的过滤。</li></ul><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将位图加载到已绑定的纹理中</span></span><br><span class="line">GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, <span class="number">0</span>, bitmap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收位图，因为它的数据已加载到OpenGL中</span></span><br><span class="line">bitmap.recycle();</span><br></pre></td></tr></table></div></figure><p>安卓有一个非常实用的功能可以直接将位图加载到OpenGL中。一旦您将资源读入Bitmap对象<code>GLUtils.texImage2D()</code>将负责其他事情，这个方法的签名：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">texImage2D</span> <span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> level, Bitmap bitmap, <span class="keyword">int</span> border)</span></span></span><br></pre></td></tr></table></div></figure><p>我们想要一个常规的2D位图，因此我们传入<code>GL_TEXTURE_2D</code>作为第一个参数。第二个参数用于MIP-映射，并允许您指定要在哪个级别使用的图像。我们这里没有使用MIP-映射，因此我们将传入0设置为默认级别。我们传入位图，由于我们没有使用边框，所以我们传入0。</p><p>然后原始位图对象调用<code>recycle()</code>，这提醒Android可以回收这部分内存。由于纹理已被加载到OpenGL，我们不需要继续保留这个副本。<br>是的，Android应用程序在执行垃圾收集的Dalvik VM下运行，但Bitmap对象包含驻留在native内存中的数据，如果你不明确的回收它们，它们需要几个周期来进行垃圾收集。<br>这意味着如果您忘记执行此操作，实际上可能会因内存不足错误而崩溃，即使您不再持有对位图的任何引用。</p><h3 id="将纹理应用到我们的场景">将纹理应用到我们的场景<a href="post/Learn-OpenGL-Lesson-Four#将纹理应用到我们的场景"></a></h3><p>首先，我们需要添加各种成员变量来持有我们纹理所需要的东西：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放我们的模型数据在浮点缓冲区</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FloatBuffer mCubeTextureCoordinates;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来传入纹理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mTextureUniformHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来传入模型纹理坐标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mTextureCoordinateHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个数据元素的纹理坐标大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mTextureCoordinateDataSize = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纹理数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mTextureDataHandle;</span><br></pre></td></tr></table></div></figure><p>我们基本上是需要添加新成员变量来跟踪我们添加到着色器的内容，以及保持对纹理的引用。</p><h3 id="定义纹理坐标">定义纹理坐标<a href="post/Learn-OpenGL-Lesson-Four#定义纹理坐标"></a></h3><p>我们在构造方法中定义我们的纹理坐标</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S, T （或 X， Y）</span></span><br><span class="line"><span class="comment">// 纹理坐标数据</span></span><br><span class="line"><span class="comment">// 因为图像Y轴指向下方（向下移动图片时值会增加），OpenGL的Y轴指向上方</span></span><br><span class="line"><span class="comment">// 我们通过翻转Y轴来调整它</span></span><br><span class="line"><span class="comment">// 每个面的纹理坐标都是相同的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span>[] cubeTextureCoordinateData =</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// 正面</span></span><br><span class="line">                <span class="number">0.0F</span>, <span class="number">0.0F</span>,</span><br><span class="line">                <span class="number">0.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">                <span class="number">1.0F</span>, <span class="number">0.0F</span>,</span><br><span class="line">                <span class="number">0.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">                <span class="number">1.0F</span>, <span class="number">1.1F</span>,</span><br><span class="line">                <span class="number">1.0F</span>, <span class="number">0.0F</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>这坐标数据看起来可能有点混乱。如果您返回去看第三课中点的位置是如何定义的，您将会发现我们为正方体每个面都定义了两个三角形。点的定义方式像下面这样：</p><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（三角形<span class="number">1</span>）</span><br><span class="line">左上，</span><br><span class="line">左下，</span><br><span class="line">右上</span><br><span class="line">（三角形<span class="number">2</span>）</span><br><span class="line">左下，</span><br><span class="line">右下，</span><br><span class="line">右上</span><br></pre></td></tr></table></div></figure><p>纹理坐标和正面的位置坐标对应，但是由于Y轴翻转，Y轴指向和OpenGL的Y轴相反的方向。</p><blockquote><p>看下图，实线坐标表示在OpenGL中正方体正面X，Y坐标。虚线表示翻转后的坐标，可以看出和上面定义的纹理坐标是一一对应的</p></blockquote><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190211153435.jpg" alt="纹理坐标对应" class="article-img"></p><h3 id="设置纹理">设置纹理<a href="post/Learn-OpenGL-Lesson-Four#设置纹理"></a></h3><p>我们在<code>onSurfaceCreated()</code>方法中加载纹理</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mProgramHandle = ShaderHelper.createAndLinkProgram(vertexShaderHandle, fragmentShaderHandle, <span class="string">"a_Position"</span>, <span class="string">"a_Color"</span>, <span class="string">"a_Normal"</span>, <span class="string">"a_TexCoordinate"</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 加载纹理</span></span><br><span class="line">    mTextureDataHandle = TextureHelper.loadTexture(mActivityContext, R.drawable.bumpy_bricks_public_domain);</span><br></pre></td></tr></table></div></figure><p>我们传入一个新的属性<code>a_TexCoordinate</code>绑定到我们的着色器中，并且我们通过之前创建的<code>loadTexture()</code>方法加载着色器。</p><h3 id="使用纹理">使用纹理<a href="post/Learn-OpenGL-Lesson-Four#使用纹理"></a></h3><p>我们也需要在<code>onDrawFrame(GL10 gl)</code>方法中添加一些代码。</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mTextureUniformHandle = GLES20.glGetUniformLocation(mProgramHandle, <span class="string">"u_Texture"</span>);</span><br><span class="line">    mTextureCoordinateHandle = GLES20.glGetAttribLocation(mProgramHandle, <span class="string">"a_TexCoordinate"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将纹理单元设置为纹理单元0</span></span><br><span class="line">    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将纹理绑定到这个单元</span></span><br><span class="line">    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextureDataHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过绑定到纹理单元0，告诉纹理标准采样器在着色器中使用此纹理</span></span><br><span class="line">    GLES20.glUniform1i(mTextureUniformHandle, <span class="number">0</span>);</span><br></pre></td></tr></table></div></figure><p>我们得到着色器中的纹理数据和纹理坐标句柄。在OpenGL中，纹理能在着色之前，需要绑定到纹理单元。纹理单元是读取纹理并实际将它传入着色器的中，因此可以再屏幕上显示。不同的图形芯片有不同数量的纹理单元，因此在使用它们之前，您需要检查是否存在其他纹理单元。</p><p>首先，我们告诉OpenGL我们想设置使用的纹理单元到第一个单元，纹理单元0。然后自动绑定纹理到第一个单元，通过调用<code>glBindTexture()</code>。最后，我们告诉OpenGL，我们想将<code>mTextureUniformHandle</code>绑定到第一个纹理单元，它引用了片段着色器中<code>u_Texture</code>属性。</p><p>简而言之：</p><ol><li>设置纹理单元</li><li>绑定纹理到这个单元</li><li>将此单元指定给片段着色器中的纹理标准</li></ol><p>根据需要重复多个纹理。</p><h3 id="进一步练习">进一步练习<a href="post/Learn-OpenGL-Lesson-Four#进一步练习"></a></h3><p>一旦您做到这儿，您就完成的差不多了！当然这这并没有您预期的那么糟糕…或者确实糟糕？😉作为下一个练习，尝试通过加载另一个纹理，将其绑定到另一个单元，并在着色器中使用它。</p><h2 id="回顾">回顾<a href="post/Learn-OpenGL-Lesson-Four#回顾"></a></h2><p>现在我们回顾一下所有的着色器代码，以及我们添加了一个新的帮助功能用来从资源目录读取着色器代码，而不是存储在java字符串中：</p><h3 id="顶点着色器-all">顶点着色器 all<a href="post/Learn-OpenGL-Lesson-Four#顶点着色器-all"></a></h3><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_MVPMatrix;                      <span class="comment">// 一个表示组合model、view、projection矩阵的常量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_MVMatrix;                       <span class="comment">// 一个表示组合model、view矩阵的常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Position;                     <span class="comment">// 我们将要传入的每个顶点的位置信息</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Color;                        <span class="comment">// 我们将要传入的每个顶点的颜色信息</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> a_Normal;                       <span class="comment">// 我们将要传入的每个顶点的法线信息</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> a_TexCoordinate;                <span class="comment">// 我们将要传入的每个顶点的纹理坐标信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> v_Position;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> v_Normal;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> v_TexCoordinate;                  <span class="comment">// 这将会传入到片段着色器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器入口点</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 传入纹理坐标</span></span><br><span class="line">   v_TexCoordinate = a_TexCoordinate;</span><br><span class="line">   <span class="comment">// 将顶点位置转换成眼睛空间的位置</span></span><br><span class="line">   v_Position = <span class="type">vec3</span>(u_MVMatrix * a_Position);</span><br><span class="line">   <span class="comment">// 传入颜色</span></span><br><span class="line">   v_Color = a_Color;</span><br><span class="line">   <span class="comment">// 将法线的方向转换在眼睛空间</span></span><br><span class="line">   v_Normal = <span class="type">vec3</span>(u_MVMatrix * <span class="type">vec4</span>(a_Normal, <span class="number">0.0</span>));</span><br><span class="line">   <span class="comment">// gl_Position是一个特殊的变量用来存储最终的位置</span></span><br><span class="line">   <span class="comment">// 将顶点乘以矩阵得到标准化屏幕坐标的最终点</span></span><br><span class="line">   <span class="built_in">gl_Position</span> = u_MVPMatrix * a_Position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="片段着色器-all">片段着色器 all<a href="post/Learn-OpenGL-Lesson-Four#片段着色器-all"></a></h3><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>; <span class="comment">//我们将默认精度设置为中等，我们不需要片段着色器中的高精度</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> u_Texture;  <span class="comment">// 传入纹理</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> u_LightPos; <span class="comment">// 光源在眼睛空间的位置</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> v_Position; <span class="comment">// 插入的位置</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color; <span class="comment">// 插入的位置颜色</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> v_Normal; <span class="comment">// 插入的位置法线</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> v_TexCoordinate; <span class="comment">// 插入的纹理坐标</span></span><br><span class="line"><span class="type">void</span> main()  <span class="comment">// 片段着色器入口</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 将用于哀减</span></span><br><span class="line">   <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(u_LightPos - v_Position);</span><br><span class="line">   <span class="comment">// 获取从光源到顶点方向的光线向量</span></span><br><span class="line">   <span class="type">vec3</span> lightVector = <span class="built_in">normalize</span>(u_LightPos - v_Position);</span><br><span class="line">   <span class="comment">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class="line">   <span class="type">float</span> diffuse = <span class="built_in">max</span>(<span class="built_in">dot</span>(v_Normal, lightVector), <span class="number">0.1</span>);</span><br><span class="line">   <span class="comment">// 根据距离哀减光线</span></span><br><span class="line">   diffuse = diffuse * (<span class="number">1.0</span> / (<span class="number">1.0</span> + (<span class="number">0.25</span> * <span class="built_in">distance</span> * <span class="built_in">distance</span>)));</span><br><span class="line">   <span class="comment">// 添加环境照明</span></span><br><span class="line">   diffuse = diffuse + <span class="number">0.3</span>;</span><br><span class="line">   <span class="comment">// 颜色乘以亮度哀减和纹理值得到最终的颜色</span></span><br><span class="line">   <span class="built_in">gl_FragColor</span> = v_Color * diffuse * <span class="built_in">texture2D</span>(u_Texture, v_TexCoordinate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="怎样从raw资源目录中读取文本？">怎样从raw资源目录中读取文本？<a href="post/Learn-OpenGL-Lesson-Four#怎样从raw资源目录中读取文本？"></a></h3><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RawResourceReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readTextFileFromRawResource</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> <span class="keyword">int</span> resurceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> InputStream inputStream = context.getResources().openRawResource(resurceId);</span><br><span class="line">        <span class="keyword">final</span> InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line">        <span class="keyword">final</span> BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line"></span><br><span class="line">        String nextLine;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> StringBuilder body = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((nextLine = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                body.append(nextLine).append(<span class="string">'\n'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> body.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="教程目录">教程目录<a href="post/Learn-OpenGL-Lesson-Four#教程目录"></a></h2><ul><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">OpenGL Android课程二：环境光和漫射光</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">OpenGL Android课程三：使用每片段照明</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four">OpenGL Android课程四：介绍纹理基础</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five">OpenGL Android课程五：介绍混合（Blending）</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six">OpenGL Android课程六：介绍纹理过滤</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）</a></li></ul><h2 id="打包教材">打包教材<a href="post/Learn-OpenGL-Lesson-Four#打包教材"></a></h2><p>可以在Github下载本课程源代码：<a href="https://github.com/learnopengles/Learn-OpenGLES-Tutorials" target="_blank" rel="noopener">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href="https://market.android.com/details?id=com.learnopengles.android" target="_blank" rel="noopener">google play 下载apk</a><br>“我”也编译了个apk，方便大家下载：<a href="https://github.com/xujiaji/LearnOpenGL/releases" target="_blank" rel="noopener">github download</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文标题：Android Lesson Four: Introducing Basic Texturing&lt;br&gt;原文链接：&lt;a href=&quot;http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.learnopengles.com/android-lesson-four-introducing-basic-texturing/&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/categories/OpenGL/"/>
    
    
      <category term="Android" scheme="https://blog.xujiaji.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/tags/OpenGL/"/>
    
      <category term="学习" scheme="https://blog.xujiaji.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://blog.xujiaji.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Android课程三：使用每片段照明</title>
    <link href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three/index.html"/>
    <id>https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three/index.html</id>
    <published>2019-01-26T09:55:49.000Z</published>
    <updated>2019-04-08T08:32:50.360Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译文</p></blockquote><p>原文标题：Android Lesson Three: Moving to Per-Fragment Lighting<br>原文链接：<a href="http://www.learnopengles.com/android-lesson-three-moving-to-per-fragment-lighting/" target="_blank" rel="noopener">http://www.learnopengles.com/android-lesson-three-moving-to-per-fragment-lighting/</a><br><a id="more"></a></p><hr><h1 id="使用每片段照明">使用每片段照明<a href="post/Learn-OpenGL-Lesson-Three#使用每片段照明"></a></h1><div class="article-bounded"><div class="article-table"><table><tbody><tr><td>欢迎来到第三课！这节课，我们将会在<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">第二课</a>的基础上，<br>学习如何使用每像素技术来达到相同的照明。<br>简单的正方体即使使用标准的漫射照明我们也能看到差异。</td><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190126183929.png" alt="screenshot"></td></tr></tbody></table></div></div><h2 id="前提条件">前提条件<a href="post/Learn-OpenGL-Lesson-Three#前提条件"></a></h2><p>本系列的每节课都以前面的课程为基础，本节课是<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">第二课</a>的补充，因此请务在阅读了之前的课程后再来回顾。</p><blockquote><p>下面是本系列课程的前几课：</p></blockquote><ul><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">OpenGL Android课程二：环境光和漫射光</a></li></ul><h2 id="什么是每像素照明">什么是每像素照明<a href="post/Learn-OpenGL-Lesson-Three#什么是每像素照明"></a></h2><p>随着着色器的使用，每像素照明在游戏中是一种相对较新的现象。许多有名的旧游戏，例如原版的<a href="https://en.wikipedia.org/wiki/Half-Life_(video_game)" target="_blank" rel="noopener">半条命</a>，都是在着色器之前开发出来的，主要使用静态照明，通过一些技巧模拟动态照明，使用每顶点（也称为<a href="http://en.wikipedia.org/wiki/Gouraud_shading" target="_blank" rel="noopener">Gouraud阴影</a>）照明或其他技术，如动态<a href="https://en.wikipedia.org/wiki/Lightmap" target="_blank" rel="noopener">光照贴图</a>。</p><p>光照贴图可以提供非常好的效果，有时可以比单独的着色器提供更好的效果，因为可以预先计算昂贵的光线计算。但缺点是它们占用了大量内存并使用它们进行动态照明仅限于简单的计算。</p><p>使用着色器，现在很多这些计算转给GPU，这可以完成更多实时的效果。</p><h2 id="从每顶点照明转移到每片段照明">从每顶点照明转移到每片段照明<a href="post/Learn-OpenGL-Lesson-Three#从每顶点照明转移到每片段照明"></a></h2><p>这本课中，我们将针对每顶点解决方案和每片段解决方案查看相同的照明代码。尽管我将这种类型称为每像素，但在OpenGL ES中我们实际上使用片段，并且几个片段可以贡献一个像素的最终值。</p><p>手机的GPU变得越来越快，但是性能仍然是一个问题。对于“软”照明例如地形，每顶点照明可能足够好。确保您在质量和速度之间取得适当的平衡。</p><p>在某些情况下可以看到两种类型的照明之间的显著差异。看看下面的屏幕截图：</p><div class="article-bounded"><div class="article-table"><table><tbody><tr><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190127004415.png" alt="Per vertex lighting"><br>每顶点照明；<br>在正方形四个顶点为中心</td><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190127004455.png" alt="Per fragment lighting"><br>每片段照明；<br>在正方形四个顶点为中心</td><td>在左图的每顶点照明中正方体的<br>正面看起来像是平面阴影，不能<br>表明附近有光源。这是因为正面<br>的四个顶点和光源距离差不多相<br>等，并且四个点的低光强度被简<br>单的插入两个三角形构成的正面。<hr>相对比，每片段照明很好的<br>显示了亮点特性</td></tr><tr><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190127004542.png" alt="Per vertex lighting"><br>每顶点照明；<br>在正方形角落</td><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190127004615.png" alt="Per fragment lighting"><br>每片段照明；<br>在正方形角落</td><td>左图显示了一个<a href="http://en.wikipedia.org/wiki/Gouraud_shading" target="_blank" rel="noopener">Gouraud阴影</a><br>立方体。当光源移动到立方体正<br>面角落时，可以看到类似三角形<br>的效果。这是因为正面实际上是<br>由两个三角形组成，并且在每个<br>三角形不同方向插值，我们能看<br>到构成立方体的基础几何图形。<hr>每片段的版本显示上没有此类插<br>值的问题并且它在边缘附近显示<br>了一个漂亮的圆形高光。</td></tr></tbody></table></div></div><h3 id="每顶点照明概述">每顶点照明概述<a href="post/Learn-OpenGL-Lesson-Three#每顶点照明概述"></a></h3><p>我们来看看<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">第二课</a>讲的着色器；在该课程中可以找到详细的着色器说明。</p><h3 id="顶点着色器">顶点着色器<a href="post/Learn-OpenGL-Lesson-Three#顶点着色器"></a></h3><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_MVPMatrix;      <span class="comment">// 一个表示组合model、view、projection矩阵的常量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_MVMatrix;       <span class="comment">// 一个表示组合model、view矩阵的常量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> u_LightPos;       <span class="comment">// 光源在眼睛空间的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Position;     <span class="comment">// 我们将要传入的每个顶点的位置信息</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Color;        <span class="comment">// 我们将要传入的每个顶点的颜色信息</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> a_Normal;       <span class="comment">// 我们将要传入的每个顶点的法线信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color;          <span class="comment">// 这将被传入片段着色器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()                    <span class="comment">// 顶点着色器入口</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将顶点转换成眼睛空间</span></span><br><span class="line">   <span class="type">vec3</span> modelViewVertex = <span class="type">vec3</span>(u_MVMatrix * a_Position);</span><br><span class="line"><span class="comment">// 将法线的方向转换成眼睛空间</span></span><br><span class="line">   <span class="type">vec3</span> modelViewNormal = <span class="type">vec3</span>(u_MVMatrix * <span class="type">vec4</span>(a_Normal, <span class="number">0.0</span>));</span><br><span class="line"><span class="comment">// 将用于哀减</span></span><br><span class="line">   <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(u_LightPos - modelViewVertex);</span><br><span class="line"><span class="comment">// 获取从光源到顶点方向的光线向量</span></span><br><span class="line">   <span class="type">vec3</span> lightVector = <span class="built_in">normalize</span>(u_LightPos - modelViewVertex);</span><br><span class="line"><span class="comment">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class="line">   <span class="type">float</span> diffuse = <span class="built_in">max</span>(<span class="built_in">dot</span>(modelViewNormal, lightVector), <span class="number">0.1</span>);</span><br><span class="line"><span class="comment">// 根据距离哀减光线</span></span><br><span class="line">   diffuse = diffuse * (<span class="number">1.0</span> / (<span class="number">1.0</span> + (<span class="number">0.25</span> * <span class="built_in">distance</span> * <span class="built_in">distance</span>)));</span><br><span class="line"><span class="comment">// 将颜色乘以亮度，它将被插入三角形中</span></span><br><span class="line">   v_Color = a_Color * diffuse;</span><br><span class="line"><span class="comment">// gl_Position是一个特殊的变量用来存储最终的位置</span></span><br><span class="line"><span class="comment">// 将顶点乘以矩阵得到标准化屏幕坐标的最终点</span></span><br><span class="line">   <span class="built_in">gl_Position</span> = u_MVPMatrix * a_Position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="片段着色器">片段着色器<a href="post/Learn-OpenGL-Lesson-Three#片段着色器"></a></h3><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;     <span class="comment">// 我们将默认精度设置为中等，我们不需要片段着色器中的高精度</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color;        <span class="comment">// 这是从三角形每个片段内插的顶点着色器的颜色</span></span><br><span class="line"><span class="type">void</span> main()                  <span class="comment">// 片段着色器入口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = v_Color;   <span class="comment">// 直接将颜色传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>正如您所见，大部分工作都在我们的着色器中做的。转移到每片段着色照明意味着，我们的片段着色器还有更多的工作要做。</p><h3 id="实现每片段照明">实现每片段照明<a href="post/Learn-OpenGL-Lesson-Three#实现每片段照明"></a></h3><p>以下是移动到每片段照明后的代码的样子。</p><h3 id="顶点着色器-new">顶点着色器 new<a href="post/Learn-OpenGL-Lesson-Three#顶点着色器-new"></a></h3><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_MVPMatrix;    <span class="comment">// 一个表示组合model、view、projection矩阵的常量</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_MVMatrix;     <span class="comment">// 一个表示组合model、view矩阵的常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Position;   <span class="comment">// 我们将要传入的每个顶点的位置信息</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_Color;      <span class="comment">// 我们将要传入的每个顶点的颜色信息</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> a_Normal;     <span class="comment">// 我们将要传入的每个顶点的法线信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> v_Position;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> v_Normal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点着色器入口点</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 将顶点位置转换成眼睛空间的位置</span></span><br><span class="line">   v_Position = <span class="type">vec3</span>(u_MVMatrix * a_Position);</span><br><span class="line">   <span class="comment">// 传入颜色</span></span><br><span class="line">   v_Color = a_Color;</span><br><span class="line">   <span class="comment">// 将法线的方向转换在眼睛空间</span></span><br><span class="line">   v_Normal = <span class="type">vec3</span>(u_MVMatrix * <span class="type">vec4</span>(a_Normal, <span class="number">0.0</span>));</span><br><span class="line">   <span class="comment">// gl_Position是一个特殊的变量用来存储最终的位置</span></span><br><span class="line">   <span class="comment">// 将顶点乘以矩阵得到标准化屏幕坐标的最终点</span></span><br><span class="line">   <span class="built_in">gl_Position</span> = u_MVPMatrix * a_Position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>顶点着色器比之前更加的简单。我们添加了两个线性插值变量用来传入到片段着色器：顶点位置和顶点法线。它们将在片段着色器计算光亮的时候被使用。</p><h3 id="片段着色器-new">片段着色器 new<a href="post/Learn-OpenGL-Lesson-Three#片段着色器-new"></a></h3><figure class="highlight glsl"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>; <span class="comment">//我们将默认精度设置为中等，我们不需要片段着色器中的高精度</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> u_LightPos; <span class="comment">// 光源在眼睛空间的位置</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> v_Position; <span class="comment">// 插入的位置</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec4</span> v_Color;    <span class="comment">// 插入的位置颜色</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> v_Normal;   <span class="comment">// 插入的位置法线</span></span><br><span class="line"><span class="type">void</span> main()              <span class="comment">// 片段着色器入口</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 将用于哀减</span></span><br><span class="line">   <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(u_LightPos - v_Position);</span><br><span class="line">   <span class="comment">// 获取从光源到顶点方向的光线向量</span></span><br><span class="line">   <span class="type">vec3</span> lightVector = <span class="built_in">normalize</span>(u_LightPos - v_Position);</span><br><span class="line">   <span class="comment">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class="line">   <span class="type">float</span> diffuse = <span class="built_in">max</span>(<span class="built_in">dot</span>(v_Normal, lightVector), <span class="number">0.1</span>);</span><br><span class="line">   <span class="comment">// 根据距离哀减光线</span></span><br><span class="line">   diffuse = diffuse * (<span class="number">1.0</span> / (<span class="number">1.0</span> + (<span class="number">0.25</span> * <span class="built_in">distance</span> * <span class="built_in">distance</span>)));</span><br><span class="line">   <span class="comment">// 颜色乘以亮度哀减得到最终的颜色</span></span><br><span class="line">   <span class="built_in">gl_FragColor</span> = v_Color * diffuse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>使用每片段照明，我们的片段着色器还有更多的工作要做。我们基本上将<a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law" target="_blank" rel="noopener">朗伯计算</a>和哀减移到了每像素级别，这为我们提供了更逼真的照明，而无需添加更多顶点。</p><h2 id="进一步练习">进一步练习<a href="post/Learn-OpenGL-Lesson-Three#进一步练习"></a></h2><p>我们可以在顶点着色器中计算距离，然后赋值给变量通过线性插值传入片段着色器吗？</p><h2 id="教程目录">教程目录<a href="post/Learn-OpenGL-Lesson-Three#教程目录"></a></h2><ul><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">OpenGL Android课程二：环境光和漫射光</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">OpenGL Android课程三：使用每片段照明</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four">OpenGL Android课程四：介绍纹理基础</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five">OpenGL Android课程五：介绍混合（Blending）</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six">OpenGL Android课程六：介绍纹理过滤</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）</a></li></ul><h2 id="打包教材">打包教材<a href="post/Learn-OpenGL-Lesson-Three#打包教材"></a></h2><p>可以在Github下载本课程源代码：<a href="https://github.com/learnopengles/Learn-OpenGLES-Tutorials" target="_blank" rel="noopener">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href="https://market.android.com/details?id=com.learnopengles.android" target="_blank" rel="noopener">google play 下载apk</a><br>“我”也编译了个apk，方便大家下载：<a href="https://github.com/xujiaji/LearnOpenGL/releases" target="_blank" rel="noopener">github download</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文标题：Android Lesson Three: Moving to Per-Fragment Lighting&lt;br&gt;原文链接：&lt;a href=&quot;http://www.learnopengles.com/android-lesson-three-moving-to-per-fragment-lighting/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.learnopengles.com/android-lesson-three-moving-to-per-fragment-lighting/&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/categories/OpenGL/"/>
    
    
      <category term="Android" scheme="https://blog.xujiaji.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/tags/OpenGL/"/>
    
      <category term="学习" scheme="https://blog.xujiaji.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://blog.xujiaji.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Android课程二：环境光和漫射光</title>
    <link href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two/index.html"/>
    <id>https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two/index.html</id>
    <published>2019-01-23T07:50:51.000Z</published>
    <updated>2019-04-08T06:56:23.990Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译文</p></blockquote><p>原文标题：OpenGL Android Lesson One: Getting Started<br>原文链接：<a href="http://www.learnopengles.com/android-lesson-two-ambient-and-diffuse-lighting/" target="_blank" rel="noopener">http://www.learnopengles.com/android-lesson-two-ambient-and-diffuse-lighting/</a><br><a id="more"></a></p><hr><h1 id="环境光和漫射光">环境光和漫射光<a href="post/Learn-OpenGL-Lesson-Two#环境光和漫射光"></a></h1><div class="article-bounded"><div class="article-table"><table><tbody><tr><td>欢迎来到第二课，我们将学习如何使用<br>着色器实现<a href="https://en.wikipedia.org/wiki/Lambertian_reflectance" target="_blank" rel="noopener">朗伯反射（ Lambertian reflectance ）</a>，也称为标准漫射照明。<br><br>在OpengGLES2，我们需要实现我们自己的照明算法，<br>因此我们要学会数学如何工作以及如何应用到我们的场景中。</td><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190123163828.png" alt="screenshot"></td></tr></tbody></table></div></div><h2 id="阅读本文前提条件">阅读本文前提条件<a href="post/Learn-OpenGL-Lesson-Two#阅读本文前提条件"></a></h2><p>本系列的每节课都以前面的课程为基础。在开始前，<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">请看第一课</a>，因为本课程将以此为基础概念介绍。</p><h2 id="什么是光">什么是光<a href="post/Learn-OpenGL-Lesson-Two#什么是光"></a></h2><p>没错！一个没有光的世界是昏暗的。没有[光]，我们甚至不能感知世界或我们周围的物体，除了声音和触摸等其他感官。<br>光向我们展示了物体是明亮还是昏暗，是远还是近，它的角度是什么。</p><p>在现实世界，我们所感知的光实际是数万亿微小粒子的聚集，称为光子。它从光源飞出，反弹数千或数百万次，最终到达我们的眼镜我们称之为光。</p><p>我们如何通过计算机图形模拟光的影响？<br>有两种流行的方法：<a href="http://en.wikipedia.org/wiki/Ray_tracing_(graphics)" target="_blank" rel="noopener">光线追踪</a>和<a href="http://en.wikipedia.org/wiki/Rasterisation" target="_blank" rel="noopener">光栅化</a><br>光线跟踪的工作原理是通过数学计算跟踪实际光线并查看它们的最终位置。该技术可以得到非常精准和逼真的结果，但缺点是模拟所有这些光线的计算成本非常高，并且通常对于实时渲染来说太慢了。<br>由于这个限制，大多数实时图形计算使用光栅化，它通过近似值模拟光照。鉴于当前游戏的真实性，光栅化看起来非常好，即使在手机上也可以快速实现实时图形。OpengGL ES主要是一个光栅化库，因此我们主要关注这个。</p><h3 id="不同种类的光">不同种类的光<a href="post/Learn-OpenGL-Lesson-Two#不同种类的光"></a></h3><p>事实证明，我们可以抽象出光的工作方式，并提出三种基本的光照方式</p><div class="article-bounded"><div class="article-table"><table><tbody><tr><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190123234400.png" alt="Ambient"><br>环境光</td><td><strong>环境光</strong><br>这是基本的照明水平，似乎遍布整个场景。它似乎不是来自任何<br>光源的光，因为它在到达你之前已经反弹了很多次。这种类型的光<br>在户外的阴天可以体验，或者在户内作为许多不同光源的积累影响。<br>我们可以为物体或场景设置一个基本的亮度，而不是为所有的<br>光单独计算。</td></tr><tr><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190124093759.png" alt="diffuse"><br>环境照明和漫射照明<br>的例子</td><td><strong>漫射照明</strong><br>这是直接从一个物体上跳弹后到达您眼睛中的光，物体的亮度<br>随着它与照明的角度而变化，面向灯光的方向比其他角度更加明亮<br>此外，无论我们相对于物体的角度怎样，我们都觉得物体是相同的<br>亮度，这也被称为<a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law" target="_blank" rel="noopener">Lambert的余弦定律</a>。漫射照明或朗伯反射率在<br>日常生活中很常见，您可以在室内灯光照明的白墙上轻松看到。</td></tr><tr><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190124105013.png" alt="specular"><br>镜面高光的一个例子</td><td><strong>镜面照明</strong><br>与漫射照明不同，当我们相对于物体移动时，镜面光照也会<br>发生改变。这给物体带来“光泽”，并且可以在“更光滑”的表面<br>上看到，例如玻璃和其他有光泽的物体。</td></tr></tbody></table></div></div><h3 id="模拟光">模拟光<a href="post/Learn-OpenGL-Lesson-Two#模拟光"></a></h3><p>正如3D场景中的3中主要类型的光照一样，还有三种主要类型的光源：定向光源，点光源，聚光灯，这些也可以在日常生活中轻松看到。</p><div class="article-bounded"><div class="article-table"><table><tbody><tr><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190124112017.png" alt="Directional lighting"><br>一个明亮的风景</td><td><strong>定向光源</strong><br>定向光照通常来自于一个很远的光源，它可以均匀的照亮整个<br>场景达到相同的亮度。这种光源是最简单的类型，无论您处在<br>场景哪里，光照都具有相同的强度和方向。</td></tr><tr><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190124112915.png" alt="Point lighting"><br>一个点光源的例子</td><td><strong>点光源</strong><br>点光源可以添加到场景中，以提供更多样化和逼真的照明。<br>点光的照射<a href="https://en.wikipedia.org/wiki/Inverse-square_law" target="_blank" rel="noopener">随着距离而下降</a>，并且它的光线在所有方向上<br>向外传播，光源位于中心。</td></tr><tr><td><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190124113930.png" alt="Spot lighting"><br>聚光灯</td><td><strong>聚光灯</strong><br>除了具有点光源的特性外，聚光灯也有光哀减的方向，<br>通常呈锥形。</td></tr></tbody></table></div></div><h3 id="数学">数学<a href="post/Learn-OpenGL-Lesson-Two#数学"></a></h3><p>本节课，我们来看看来自一个点光源的环境照明和漫射照明。</p><h3 id="环境照明">环境照明<a href="post/Learn-OpenGL-Lesson-Two#环境照明"></a></h3><p>环境照明其实是<a href="https://en.wikipedia.org/wiki/Radiosity_(computer_graphics)" target="_blank" rel="noopener">间接漫射照明</a>，但它也可以被认为是遍布整个场景的低级光。如果我们这么想，那么它将非常好计算：</p><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终颜色 = 材质颜色 * 环境光颜色</span></span><br><span class="line">final color = material color * ambient light color</span><br></pre></td></tr></table></div></figure><p>例如，我们有个红色的物体和一个暗白色的环境照明。我们假设三个颜色（红，绿，蓝）的数组存储颜色，使用<a href="https://en.wikipedia.org/wiki/RGB_color_model" target="_blank" rel="noopener">RGB颜色模型</a>：</p><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终颜色 = 红色 * 暗白色 = 暗红色</span></span><br><span class="line">final color = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125; * &#123;<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>&#125; = &#123;<span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>&#125;</span><br></pre></td></tr></table></div></figure><p>物体的最终颜色将是暗红色，如果您有一个被昏暗的白光照明的红色物体，那么这就是您的预期。基本的环境光真的没有比这更多的了，除非您想加入更先进的照明技术，如光能传递。</p><h3 id="漫射照明-点光源">漫射照明-点光源<a href="post/Learn-OpenGL-Lesson-Two#漫射照明-点光源"></a></h3><p>对于漫射照明，我们需要添加哀减和光源位置。光源位置将用来计算光线和表面的角度，它将影响表面的整体光照水平。它还将用于计算光源到表面的距离，这决定了光在这个点上的强度。</p><h4 id="第一步：计算朗伯因子（lambert-factor）">第一步：计算朗伯因子（lambert factor）<a href="post/Learn-OpenGL-Lesson-Two#第一步：计算朗伯因子（lambert-factor）"></a></h4><p>我们最重要的是需要弄清楚表面和光线之间的角度。面向光直射的表面因该全强度照射，而倾斜的表面因该得到较少的照射，比较合适的计算方式是使用<a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law" target="_blank" rel="noopener">Lambert的余弦定律</a>。<br>果我们有两个向量，一个是从光到表面上的一个点，第二个是<a href="https://en.wikipedia.org/wiki/Normal_(geometry)" target="_blank" rel="noopener">表面的法线</a>（如果表面是平面，则表面法线是指向上或垂直于该表面的矢量），然后我们可以通过对每个向量进行归一化来计算余弦，使其长度为1，然后通过计算两个向量的<a href="https://en.wikipedia.org/wiki/Dot_product" target="_blank" rel="noopener">点积（数量积）</a>。<br>这个操作可以由OpenGL ES 2轻松完成。</p><p>我们称这位朗伯因子，它的取值范围在0~1之间</p><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 光线向量 = 光源位置 - 物体位置</span></span><br><span class="line">light <span class="built_in">vector</span> = light position - object position</span><br><span class="line"><span class="comment">// 余弦 = 物体法线和归一化后的光线向量的点积</span></span><br><span class="line">cosine = dot product(object normal, normalize(light <span class="built_in">vector</span>))</span><br><span class="line"><span class="comment">// 朗伯因子 = 取余弦和0中最大的</span></span><br><span class="line">lambert factor = max(cosine, <span class="number">0</span>)</span><br></pre></td></tr></table></div></figure><p>首先我们通过光源位置减去物体位置得到光线向量，然后我们通过物体法线和光向量的点积得到余弦。我们标准化光向量，这意味着改变它的长度，长度为1，这个物体的法线长度也是1，两个归一化向量的点积得到他们之间的余弦。因为点积的取值范围是-1~1，所以我们将其限制到0~1。</p><p>这儿有个处在原点的平面，其表面法线指向天空的例子。</p><blockquote><p>光的位置在{0, 10, -10}，我们想要计算在原点的光。</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 光线向量</span></span><br><span class="line">light <span class="built_in">vector</span> = &#123;<span class="number">0</span>, <span class="number">10</span>, <span class="number">-10</span>&#125; - &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; = &#123;<span class="number">0</span>, <span class="number">10</span>, <span class="number">-10</span>&#125;</span><br><span class="line"><span class="comment">// 物体法线</span></span><br><span class="line">object normal = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>简洁的说，如果们沿着光线矢量走，我们到达光源的位置。为了归一化矢量，我们将每个分量除以矢量长度：</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 光线向量长度 = 平方根(0*0 + 10*10 + (-10 * -10)) = 平方根(200) = 14.14</span></span><br><span class="line">light <span class="built_in">vector</span> length = square root(<span class="number">0</span>*<span class="number">0</span> + <span class="number">10</span>*<span class="number">10</span> + (<span class="number">-10</span> * <span class="number">-10</span>)) = square root(<span class="number">200</span>) = <span class="number">14.14</span></span><br><span class="line"><span class="comment">// 归一化光线向量</span></span><br><span class="line">normalize light <span class="built_in">vector</span> = &#123;<span class="number">0</span>, <span class="number">10</span>/<span class="number">14.14</span>, <span class="number">-10</span>/<span class="number">14.14</span>&#125; = &#123;<span class="number">0</span>, <span class="number">0.707</span>, <span class="number">-0.707</span>&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>然后我们计算点积：</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点积</span></span><br><span class="line"><span class="function">dot <span class="title">product</span><span class="params">(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0.707</span>, <span class="number">-0.707</span>&#125;)</span> </span>= (<span class="number">0</span> * <span class="number">0</span>) + (<span class="number">1</span> * <span class="number">0.707</span>) + (<span class="number">0</span> * <span class="number">-0.707</span>) = <span class="number">0.707</span></span><br></pre></td></tr></table></div></figure><p><a href="http://programmedlessons.org/VectorLessons/vch07/vch07_5.html" target="_blank" rel="noopener">这里有个一对点积计算很好的解释</a></p><blockquote><p>最后我们限制范围：</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朗伯因子</span></span><br><span class="line">lambert factor = max(<span class="number">0.707</span>, <span class="number">0</span>) = <span class="number">0.707</span></span><br></pre></td></tr></table></div></figure><p>OpenGL ES 2的着色器语言内置了对其中一些函数的支持，因此我们不需要手动完成所有数学运算，但它仍然有助于理解正在发生的事情。</p><h4 id="第二步：计算哀减系数">第二步：计算哀减系数<a href="post/Learn-OpenGL-Lesson-Two#第二步：计算哀减系数"></a></h4><p>接下来，我们需要计算哀减。来自光源的实际光哀减遵循<a href="https://en.wikipedia.org/wiki/Inverse-square_law" target="_blank" rel="noopener">反平方定律</a></p><blockquote><p>也可以这样表示：</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 亮度 = 1 / 距离的平方</span></span><br><span class="line">luminosity = <span class="number">1</span> / (distance * distance)</span><br></pre></td></tr></table></div></figure><blockquote><p>回到我们的列子，因为我们有光线长度为14.14，这儿我们最终的亮度：</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luminosity = <span class="number">1</span> / (<span class="number">14.14</span> * <span class="number">14.14</span>) = <span class="number">1</span> / <span class="number">200</span> = <span class="number">0.005</span></span><br></pre></td></tr></table></div></figure><p>正如您所见，反平方定律会导致距离的强烈哀减。这就是点光源的光在现实世界中的作用，但是由于我们图形展示范围有限，控制这个哀减系数是非常有用的，因此我们仍然能获得逼真的照明而不会让其看起来很昏暗。</p><h4 id="第三步：计算最终颜色">第三步：计算最终颜色<a href="post/Learn-OpenGL-Lesson-Two#第三步：计算最终颜色"></a></h4><blockquote><p>现在我们知道了余弦和哀减度，我们可以计算我们最终的亮度：</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终颜色 = 材质颜色 * （光的颜色 * 朗伯因子 * 亮度）</span></span><br><span class="line">final color = material color * (light color * lambert factor * luminosity)</span><br></pre></td></tr></table></div></figure><blockquote><p>继续我们之前的红色物体和白光源的例子，这儿计算最终颜色：</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final color = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125; * (&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125; * <span class="number">0.707</span> * <span class="number">0.005</span>) = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125; * &#123;<span class="number">0.0035</span>, <span class="number">0.0035</span>, <span class="number">0.0035</span>&#125; = &#123;<span class="number">0.0035</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></div></figure><p>回顾一下，对于漫射照明，我们需要使用表面和光线之间的角度以及距离，用来计算最终的整体漫射亮度。</p><blockquote><p>以下是步骤：</p></blockquote><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line">light <span class="built_in">vector</span> = light position - object position</span><br><span class="line">cosine = dot product(object normal, normalize(light <span class="built_in">vector</span>))</span><br><span class="line">lambert factor = mac(cosine, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line">luminosity = <span class="number">1</span> / (distance * distance)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line">final color = material color * (light color * lambert factor * luminosity)</span><br></pre></td></tr></table></div></figure><h3 id="将这一切放到OpenGL-ES-2着色器中">将这一切放到OpenGL ES 2着色器中<a href="post/Learn-OpenGL-Lesson-Two#将这一切放到OpenGL-ES-2着色器中"></a></h3><h4 id="顶点着色器">顶点着色器<a href="post/Learn-OpenGL-Lesson-Two#顶点着色器"></a></h4><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String vertexShader =</span><br><span class="line">        <span class="string">"uniform mat4 u_MVPMatrix;      \n"</span> + <span class="comment">// 一个表示组合model、view、projection矩阵的常量</span></span><br><span class="line">        <span class="string">"uniform mat4 u_MVMatrix;       \n"</span> + <span class="comment">// 一个表示组合model、view矩阵的常量</span></span><br><span class="line">        <span class="string">"uniform vec3 u_LightPos;       \n"</span> + <span class="comment">// 光源在眼睛空间（相对于相机视角）的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"attribute vec4 a_Position;     \n"</span> + <span class="comment">// 我们将要传入的每个顶点的位置信息</span></span><br><span class="line">        <span class="string">"attribute vec4 a_Color;        \n"</span> + <span class="comment">// 我们将要传入的每个顶点的颜色信息</span></span><br><span class="line">        <span class="string">"attribute vec3 a_Normal;       \n"</span> + <span class="comment">// 我们将要传入的每个顶点的法线信息</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"varying vec4 v_Color;          \n"</span> + <span class="comment">// 这将被传入片段着色器</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"void main()                    \n"</span> + <span class="comment">// 顶点着色器入口</span></span><br><span class="line">        <span class="string">"&#123;                              \n"</span> +</span><br><span class="line">        <span class="comment">// 将顶点转换成眼睛空间（相对于相机视角）</span></span><br><span class="line">        <span class="string">"   vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);                \n"</span> +</span><br><span class="line">        <span class="comment">// 将法线的方向转换成眼睛空间（相对于相机视角）</span></span><br><span class="line">        <span class="string">"   vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));       \n"</span> +</span><br><span class="line">        <span class="comment">// 将用于哀减</span></span><br><span class="line">        <span class="string">"   float distance = length(u_LightPos - modelViewVertex);               \n"</span> +</span><br><span class="line">        <span class="comment">// 获取从光源到顶点方向的光线向量</span></span><br><span class="line">        <span class="string">"   vec3 lightVector = normalize(u_LightPos - modelViewVertex);          \n"</span> +</span><br><span class="line">        <span class="comment">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class="line">        <span class="string">"   float diffuse = max(dot(modelViewNormal, lightVector), 0.1);         \n"</span> +</span><br><span class="line">        <span class="comment">// 根据距离哀减光线</span></span><br><span class="line">        <span class="string">"   diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));    \n"</span> +</span><br><span class="line">        <span class="comment">// 将颜色乘以亮度，它将被插入三角形中</span></span><br><span class="line">        <span class="string">"   v_Color = a_Color * diffuse;                                         \n"</span> +</span><br><span class="line">        <span class="comment">// gl_Position是一个特殊的变量用来存储最终的位置</span></span><br><span class="line">        <span class="comment">// 将顶点乘以矩阵得到标准化屏幕坐标的最终点</span></span><br><span class="line">        <span class="string">"   gl_Position = u_MVPMatrix * a_Position;                              \n"</span> +</span><br><span class="line">        <span class="string">"&#125;                                                                       \n"</span>;</span><br></pre></td></tr></table></div></figure><p>这里有相当多的事情要做。我们在<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">第一课</a>讲到过我们要有一个model/view/projection的组合矩阵，但是我们还要添加了一个model/view矩阵。为什么？因为我们将需要这个矩阵去计算光源位置到当前顶点位置之间的距离。对于漫射照明，无论您使用世界空间（model矩阵）或眼睛空间（model/view矩阵）只要你能计算出合适的距离和角度实际上都没有问题。</p><p>我们传入顶点的颜色和位置信息，以及它的<a href="https://en.wikipedia.org/wiki/Normal_(geometry)" target="_blank" rel="noopener">法线</a>。我们会将最终的颜色传入片段着色器，它将在顶点之间插值，这也被称为<a href="https://en.wikipedia.org/wiki/Gouraud_shading" target="_blank" rel="noopener">Gouraud着色法</a>。</p><p>让我们来看看着色器每一部分的意义：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将顶点转换成眼睛空间（相对于相机视角）</span></span><br><span class="line"><span class="string">"   vec3 modelViewVertex = vec3(u_MVMatrix * a_Position);                \n"</span></span><br></pre></td></tr></table></div></figure><p>因为我们是在眼睛空间观察光源位置，我们转换当前的顶点位置到眼睛空间的坐标系中，因此我们能计算出对应的距离和角度。</p><hr><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将法线的方向转换成眼睛空间（相对于相机视角）</span></span><br><span class="line"><span class="string">"   vec3 modelViewNormal = vec3(u_MVMatrix * vec4(a_Normal, 0.0));       \n"</span> +</span><br></pre></td></tr></table></div></figure><p>我们也需要转换法线的方向。这里我们只是想上面位置一样做了个常规乘法，但是如果model或view矩阵做过旋转或倾斜，那么将不能工作：我们实际上需要通过将法线乘以原始矩阵的反转来消除倾斜或缩放的影响。<a href="https://web.archive.org/web/20150101061328/http://www.arcsynthesis.org/gltut/Illumination/Tut09%20Normal%20Transformation.html" target="_blank" rel="noopener">这个网站很好的解释了为什么我们必须这么做</a></p><hr><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将用于哀减</span></span><br><span class="line"><span class="string">"   float distance = length(u_LightPos - modelViewVertex);               \n"</span></span><br></pre></td></tr></table></div></figure><p>如前面数学部分所示，我们需要这个距离去计算哀减系数</p><hr><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取从光源到顶点方向的光线向量</span></span><br><span class="line"><span class="string">"   vec3 lightVector = normalize(u_LightPos - modelViewVertex);          \n"</span></span><br></pre></td></tr></table></div></figure><p>我们也需要光线向量去计算朗伯反射因子</p><hr><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算光线矢量和顶点法线的点积，如果法线和光线矢量指向相同的方向，那么它将获得最大的照明</span></span><br><span class="line"><span class="string">"   float diffuse = max(dot(modelViewNormal, lightVector), 0.1);         \n"</span></span><br></pre></td></tr></table></div></figure><p>这与上面的数学部分相同，只是在OpenGL ES 2着色器中完成。后面的0.1是一种非常便宜的环境照明方式（最小值将被限制在0.1）。</p><hr><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据距离哀减光线</span></span><br><span class="line"><span class="string">"   diffuse = diffuse * (1.0 / (1.0 + (0.25 * distance * distance)));    \n"</span></span><br></pre></td></tr></table></div></figure><p>这里和上面的数学部分略有不同。我们将距离的平方缩放0.25以抑制衰减的效应，并且我们还将修改的距离加1，这样当光源非常接近物体时我们就不会过饱和（否则，当距离小于1时，该等式实际上回照亮光源而不是哀减它）。</p><hr><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将颜色乘以亮度，它将被插入三角形中</span></span><br><span class="line"><span class="string">"   v_Color = a_Color * diffuse;                                         \n"</span> +</span><br><span class="line"><span class="comment">// gl_Position是一个特殊的变量用来存储最终的位置</span></span><br><span class="line"><span class="comment">// 将顶点乘以矩阵得到标准化屏幕坐标的最终点</span></span><br><span class="line"><span class="string">"   gl_Position = u_MVPMatrix * a_Position;                              \n"</span></span><br></pre></td></tr></table></div></figure><p>当我们有了最终的光色，我们将它乘以顶点的颜色得到最终输出的颜色，然后我们将这个顶点的位置投影到屏幕上。</p><h4 id="像素着色器">像素着色器<a href="post/Learn-OpenGL-Lesson-Two#像素着色器"></a></h4><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String fragmentShader =</span><br><span class="line">        <span class="string">"precision mediump float;       \n"</span> + <span class="comment">// 我们将默认精度设置为中等，我们不需要片段着色器中的高精度</span></span><br><span class="line">                <span class="string">"varying vec4 v_Color;          \n"</span> + <span class="comment">// 这是从三角形每个片段内插的顶点着色器的颜色</span></span><br><span class="line">                <span class="string">"void main()                    \n"</span> + <span class="comment">// 片段着色器入口</span></span><br><span class="line">                <span class="string">"&#123;                              \n"</span> +</span><br><span class="line">                <span class="string">"   gl_FragColor = v_Color;     \n"</span> + <span class="comment">// 直接将颜色传递</span></span><br><span class="line">                <span class="string">"&#125;                              \n"</span>;</span><br></pre></td></tr></table></div></figure><p>因为我们是在每个顶点的基础上计算光，我们的片段着色器和<a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">上节课</a>一样，我们所做的是将颜色直接传过去。在下节课中，我们将学习每像素照明。</p><h2 id="每顶点照明和每像素照明">每顶点照明和每像素照明<a href="post/Learn-OpenGL-Lesson-Two#每顶点照明和每像素照明"></a></h2><p>这节课我们的关注点在实现每顶点照明。对于具有光滑表面的物体（如地形），或具有许多三角形的物体的漫反射，这通常是足够了。然而，当您的物体没有包含许多顶点时（例如我们的在这个案例中的正方体），或者有尖角，顶点光照可能会导致伪影，因为亮度在多边形上线性插值；当镜面高光添加到图像时，这些伪影也会变得更加明显。更多关于<a href="https://en.wikipedia.org/wiki/Gouraud_shading" target="_blank" rel="noopener">Gouraud着色法</a>的Wiki文章</p><h2 id="正方体的构造">正方体的构造<a href="post/Learn-OpenGL-Lesson-Two#正方体的构造"></a></h2><p>在第一课中，我们将位置和颜色属性打包到一个数组中，但是OpengGL ES 2也允许让我们将属性单独存放：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//X, Y, Z</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span>[] cubePositionData = &#123;</span><br><span class="line">        <span class="comment">// 在OpenGL，逆时针绕组（下面的点事逆时针顺序）是默认的。</span></span><br><span class="line">        <span class="comment">// 这意味着当我们在观察一个三角形时，如果这些电视逆时针的，那么我们正在看"前面"，如果不是我们则正在看背面</span></span><br><span class="line">        <span class="comment">// OpenGL有一个优化，所有背面的三角形都会被剔除，因为它们通常代表一个物体的背面，无论如何都不可见</span></span><br><span class="line">        <span class="comment">// 正面</span></span><br><span class="line">        -<span class="number">1.0F</span>, <span class="number">1.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        -<span class="number">1.0F</span>, -<span class="number">1.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        <span class="number">1.0F</span>, <span class="number">1.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        -<span class="number">1.0F</span>, -<span class="number">1.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        <span class="number">1.0F</span>, -<span class="number">1.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        <span class="number">1.0F</span>, <span class="number">1.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// R，G，B，A</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span>[] cubeColorData = &#123;</span><br><span class="line">        <span class="comment">// 正面红色</span></span><br><span class="line">        <span class="number">1.0F</span>, <span class="number">0.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        <span class="number">1.0F</span>, <span class="number">0.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        <span class="number">1.0F</span>, <span class="number">0.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        <span class="number">1.0F</span>, <span class="number">0.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        <span class="number">1.0F</span>, <span class="number">0.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        <span class="number">1.0F</span>, <span class="number">0.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h2 id="新的OpenGL-flag">新的OpenGL flag<a href="post/Learn-OpenGL-Lesson-Two#新的OpenGL-flag"></a></h2><p>我们还使用了<code>glEnable()</code>调用启用了剔除和深度缓冲：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用剔除去掉背面</span></span><br><span class="line">GLES20.glEnable(GLES20.GL_CULL_FACE);</span><br><span class="line"><span class="comment">// 启用深度测试</span></span><br><span class="line">GLES20.glEnable(GLES20.GL_DEPTH_TEST);</span><br></pre></td></tr></table></div></figure><p>作为优化，您可以告诉OpenGL剔除物体背面的三角形。当我们定义正方体时，我们还定义了每个三角形的三个点，以便当我们在查看正面的时候是逆时针的。当我们翻转三角形以便我们到背面时，这些点将会顺时针展示。<br>您只能同时看到一个正方体的三个面，所以这个优化告诉OpenGL不要浪费时间去绘制背面的三角形。</p><p>之后当我们绘制透明的物体时，我们希望关闭剔除，然后物体背面将会变得可见。</p><p>我们还开启了<a href="https://en.wikipedia.org/wiki/Z-buffering" target="_blank" rel="noopener">深度测试</a>。如果你总是从后面向前面绘制物体，那么深度测试绝非必要，但是通过启用它您不仅不需要担心绘制顺序（尽管如果你先画最近的物体渲染会更快），一些显卡也将进行优化，通过花费更少的时间绘制像素来加速渲染。</p><h2 id="加载着色器程序的修改">加载着色器程序的修改<a href="post/Learn-OpenGL-Lesson-Two#加载着色器程序的修改"></a></h2><p>因为在OpenGL中加载着色器程序的步骤大致相同，这些步骤可以很容易的重构为一个单独的方法。我们还添加了以下调用来检索调试信息，以防编译/链接失败：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glGetProgramInfoLog(programHandle);</span><br><span class="line">GLES20.glGetShaderInfoLog(shaderHandle);</span><br></pre></td></tr></table></div></figure><h2 id="光点的顶点和着色程序">光点的顶点和着色程序<a href="post/Learn-OpenGL-Lesson-Two#光点的顶点和着色程序"></a></h2><p>这个新的顶点和着色器程序绘制在屏幕上代表当前光源的位置：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个简单的着色程序</span></span><br><span class="line"><span class="keyword">final</span> String pointVertexShader =</span><br><span class="line">        <span class="string">"uniform mat4 u_MVPMatrix;                  \n"</span> +</span><br><span class="line">        <span class="string">"attribute vec4 a_Position;                 \n"</span> +</span><br><span class="line">        <span class="string">"void main()                                \n"</span> +</span><br><span class="line">        <span class="string">"&#123;                                          \n"</span> +</span><br><span class="line">        <span class="string">"   gl_Position = u_MVPMatrix * a_Position; \n"</span> +</span><br><span class="line">        <span class="string">"   gl_PointSize = 5.0;                     \n"</span> +</span><br><span class="line">        <span class="string">"&#125;                                          \n"</span>;</span><br><span class="line"><span class="keyword">final</span> String pointFragmentShader =</span><br><span class="line">        <span class="string">"precision mediump float;                   \n"</span> +</span><br><span class="line">        <span class="string">"void main()                                \n"</span> +</span><br><span class="line">        <span class="string">"&#123;                                          \n"</span> +</span><br><span class="line">        <span class="string">"   gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0) \n"</span> +</span><br><span class="line">        <span class="string">"&#125;                                          \n"</span>;</span><br></pre></td></tr></table></div></figure><p>这个着色器类似于第一课的简单着色器，这里有个新的成员<code>gl_PointSize</code>，直接固定它的值为5.0，这是点的像素尺寸。当我们使用<code>GLES20.GL_POINTS</code>模式绘制这个点的时候它会被使用。我们也直接设置了它的显示颜色为白色。</p><h2 id="进一步练习">进一步练习<a href="post/Learn-OpenGL-Lesson-Two#进一步练习"></a></h2><ul><li>尝试删除“过渡饱和”看会发生什么</li><li>这里的照明方式存在缺陷，你能发现是什么吗？提示：我们做环境照明的方式的缺点是什么，以及alpha会放生什么？</li><li>如果将<code>gl_PointSize</code>添加到正方体着色器并使用<code>GL_POINTS</code>绘制它会发生什么？</li></ul><h2 id="进一步阅读">进一步阅读<a href="post/Learn-OpenGL-Lesson-Two#进一步阅读"></a></h2><ul><li><a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/lighting.php" target="_blank" rel="noopener">Clockworkcoders教程：每片段照明</a></li><li><a href="http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/" target="_blank" rel="noopener">Lighthouse3d.com：法线矩阵</a></li><li><a href="https://web.archive.org/web/20150101061328/http://www.arcsynthesis.org/gltut/Illumination/Tut09%20Normal%20Transformation.html" target="_blank" rel="noopener">arcsynthesis.org: OpenGL教程：法线转换</a></li><li><a href="http://glprogramming.com/red/chapter05.html" target="_blank" rel="noopener">OpenGL编程指南：5章 照明</a></li></ul><p>在编写本教程时，上面的进一步阅读部分对我来说是非常宝贵的资源，因此我强烈建议您阅读它们以获得更多的信息和解释。</p><h2 id="教程目录">教程目录<a href="post/Learn-OpenGL-Lesson-Two#教程目录"></a></h2><ul><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">OpenGL Android课程二：环境光和漫射光</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">OpenGL Android课程三：使用每片段照明</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four">OpenGL Android课程四：介绍纹理基础</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five">OpenGL Android课程五：介绍混合（Blending）</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six">OpenGL Android课程六：介绍纹理过滤</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）</a></li></ul><h2 id="打包教材">打包教材<a href="post/Learn-OpenGL-Lesson-Two#打包教材"></a></h2><p>可以在Github下载本课程源代码：<a href="https://github.com/learnopengles/Learn-OpenGLES-Tutorials" target="_blank" rel="noopener">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href="https://market.android.com/details?id=com.learnopengles.android" target="_blank" rel="noopener">google play 下载apk</a><br>“我”也编译了个apk，方便大家下载：<a href="https://github.com/xujiaji/LearnOpenGL/releases" target="_blank" rel="noopener">github download</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文标题：OpenGL Android Lesson One: Getting Started&lt;br&gt;原文链接：&lt;a href=&quot;http://www.learnopengles.com/android-lesson-two-ambient-and-diffuse-lighting/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.learnopengles.com/android-lesson-two-ambient-and-diffuse-lighting/&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/categories/OpenGL/"/>
    
    
      <category term="Android" scheme="https://blog.xujiaji.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/tags/OpenGL/"/>
    
      <category term="学习" scheme="https://blog.xujiaji.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://blog.xujiaji.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL Android课程一：入门</title>
    <link href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One/index.html"/>
    <id>https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One/index.html</id>
    <published>2019-01-21T08:10:46.000Z</published>
    <updated>2019-08-09T16:28:55.133Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>翻译文</p></blockquote><p>原文标题：OpenGL Android Lesson One: Getting Started<br>原文链接：<a href="http://www.learnopengles.com/android-lesson-one-getting-started/" target="_blank" rel="noopener">http://www.learnopengles.com/android-lesson-one-getting-started/</a><br><a id="more"></a></p><hr><p>这是在Android中使用OpenGL ES2的第一个教程。这一课中，我们将一步一步跟随代码，学习如何创建一个OpenGL ES 2并绘制到屏幕上。<br>我们还将了解什么是着色器，它们如何工作，以及怎样使用矩阵将场景转换为您在屏幕上看到的图像。最后，您需要在清单文件中添加您正在使用OpenGL ES 2的说明，以告知Android应用市场支持的设备可见。</p><h1 id="入门">入门<a href="post/Learn-OpenGL-Lesson-One#入门"></a></h1><p>我们将过一道下面所有的代码并且解释每一部分的作用。您可以跟着拷贝每一处的代码片段来创建您自己的项目，您也可以在文章末尾下载这个已完成的项目。<br>在开发工具（如：Android Studio）中创建您的Android项目，名字不重要，这里由于这个课程我将<code>MainActivity</code>更名为<code>LessonOneActivity</code>。</p><blockquote><p>我们来看这段代码：</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 保留对GLSurfaceView的引用*/</span></span><br><span class="line"><span class="keyword">private</span> GLSurfaceView mGLSurfaceView;</span><br></pre></td></tr></table></div></figure><p>这个<a href="http://developer.android.com/reference/android/opengl/GLSurfaceView.html" target="_blank" rel="noopener">GLSurfaceView</a>是一个特别的View，它为我们管理OpenGL界面并且将它绘制在Android View系统。它还添加了许多功能，使其更易于使用OpenGL，包括下面等等：</p><ul><li>它为OpenGL提供一个专用的着色线程，因此主线程不会停懈</li><li>它支持连续或按需渲染</li><li>它使用<a href="https://en.wikipedia.org/wiki/EGL_(API)" target="_blank" rel="noopener">EGL</a> (OpenGL和底层系统窗口之间的接口)来处理屏幕设置</li></ul><blockquote><p><code>GLSurfaceView</code>使得在Android中设置和使用OpenGL相对轻松</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    mGLSurfaceView = <span class="keyword">new</span> GLSurfaceView(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//检测系统是否支持OpenGL ES 2.0</span></span><br><span class="line">    <span class="keyword">final</span> ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    <span class="keyword">final</span> ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> supportsEs2 = configurationInfo.reqGlEsVersion &gt;= <span class="number">0x20000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsEs2) &#123;</span><br><span class="line">        <span class="comment">// 请求一个OpenGL ES 2.0兼容的上下文</span></span><br><span class="line">        mGLSurfaceView.setEGLContextClientVersion(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置我们的Demo渲染器，定义在后面讲</span></span><br><span class="line">        mGLSurfaceView.setRenderer(<span class="keyword">new</span> LessonOneRenderer());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果您想同时支持ES 1.0和2.0的话，这里您可以创建兼容OpenGL ES 1.0的渲染器</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setContentView(mGLSurfaceView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在<code>onCreate()</code>方法中是我们创建OpenGL上下文以及一切开始发生的重要部分。<br>在我们的<code>onCreate()</code>方法中,在调用<code>super.onCreate()</code>后我们首先创建了<code>GLSurfaceView</code>实例。<br>然后我们需要弄清楚系统是否支持OpenGL ES 2.为此，我们获得一个<code>ActivityManager</code>实例，它允许我们与全局系统状态进行交互。<br>然后我们使用它获取设备配置信息，它将告诉我们设备是否支持OpenGL ES 2。<br>我们也可以通过传入不同的渲染器来支持OpenGL ES 1.x，尽管因为API不同，我们需要编写不同的代码。对于本课我们仅仅关注支持OpenGL ES 2。</p><p>一旦我们知道设备是否支持OpenGL ES 2，我们告诉<code>GLSurfaceView</code>兼容OpenGL ES 2，然后传入我们的自定义渲染器。无论何时调整界面或绘制新帧，系统都会调用此渲染器。</p><p>最后，我们调用<code>setContentView()</code>设置GLSurfaceView为显示内容，它告诉Android这个活动内容因该被我们的OpenGL界面填充。要入门OpenGL，就是这么简单。</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    <span class="comment">//Activity 必须在onResume中调用GLSurfaceView的onResume方法</span></span><br><span class="line">    mGLSurfaceView.onResume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    <span class="comment">//Activity 必须在onPause中调用GLSurfaceView的onPause方法</span></span><br><span class="line">    mGLSurfaceView.onPause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>GLSurfaceView</code>要求我们在Activity<code>onResume()</code>和<code>onPause()</code>的父方法被调用后分别调用它的<code>onResume()</code>和<code>onPause()</code>方法。我们在此添加调用以完善我们的Activity。</p><h2 id="可视化3D世界">可视化3D世界<a href="post/Learn-OpenGL-Lesson-One#可视化3D世界"></a></h2><p>在这部分，我们来看怎样让OpenGL ES 2工作，以及我们如何在屏幕上绘制东西。<br>在Activity中我们传入自定义的<a href="http://developer.android.com/reference/android/opengl/GLSurfaceView.Renderer.html" target="_blank" rel="noopener">GLSurfaceView.Renderer</a>到<code>GLSurfaceView</code>，它将在这里定义。<br>这个渲染器有三个重要的方法，每当系统事件发生时，它们将会自动被调用：</p><blockquote><p><em>public void onSurfaceCreated(GL10 gl, EGLConfig config)</em></p></blockquote><p>当界面第一次被创建时调用，如果我们失去界面上下文并且之后由系统重建，也会被调用。</p><blockquote><p><em>public void onSurfaceChanged(GL10 gl, int width, int height)</em></p></blockquote><p>每当界面改变时被调用；例如，从纵屏切换到横屏，在创建界面后也会被调用。</p><blockquote><p><em>public void onDrawFrame(GL10 gl)</em></p></blockquote><p>每当绘制新帧时被调用。</p><p>您可能注意到<code>GL10</code>的实例被传入名字是<code>gl</code>。当使用OpengGL ES 2绘制时，我们不能使用它；<br>我们使用<code>GLES20</code>类的静态方法来代替。这个<code>GL10</code>参数仅仅是在这里，因为相同的接口被使用在OpenGL ES 1.x。</p><blockquote><p>在我们的渲染器可以显示任何内容之前，我们需要有些东西去显示。在OpenGL ES 2，我们通过制定数字数组传递内容。这些数字可以表示位置、颜色或任何我们需要的。在这个Demo中，我们将显示三个三角形。</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新类成员</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FloatBuffer mTriangle1Verticels;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FloatBuffer mTriangle2Verticels;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FloatBuffer mTriangle3Verticels;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 每个Float多少字节*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mBytePerFloat = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始Model数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LessonOneRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个三角形是红色，蓝色和绿色组成</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[] triangle1VerticesData = &#123;</span><br><span class="line">        <span class="comment">// X, Y, Z,</span></span><br><span class="line">        <span class="comment">// R, G, B, A</span></span><br><span class="line">        -<span class="number">0.5F</span>, -<span class="number">0.25F</span>, <span class="number">0.0F</span>,</span><br><span class="line">        <span class="number">1.0F</span>, <span class="number">0.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0.5F</span>, -<span class="number">0.25F</span>, <span class="number">0.0F</span>,</span><br><span class="line">        <span class="number">0.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span>, <span class="number">1.0F</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0.0F</span>, <span class="number">0.559016994F</span>, <span class="number">0.0F</span>,</span><br><span class="line">        <span class="number">0.0F</span>, <span class="number">1.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 初始化缓冲区</span></span><br><span class="line">    mTriangle1Verticels = ByteBuffer.allocateDirect(triangle1VerticesData.length * mBytePerFloat).order(ByteOrder.nativeOrder()).asFloatBuffer();</span><br><span class="line">    ...</span><br><span class="line">    mTriangle1Verticels.put(triangle1VerticesData).position(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>那么，这些是什么意思？如果您曾经使用过OpenGL 1， 您可能会习惯这样做：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glBegin(GL_TRIANGLES);</span><br><span class="line">glVertex3f(-<span class="number">0.5f</span>, -<span class="number">0.25f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glColor3f(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">...</span><br><span class="line">glEnd();</span><br></pre></td></tr></table></div></figure><p>这种方法在OpenGL ES 2中不起作用。我们不是通过一堆方法调用来定义点，而是定义一个数组。让我们再来看看我们这个数组：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">float</span>[] triangle1VerticesData = &#123;</span><br><span class="line">                <span class="comment">// X, Y, Z,</span></span><br><span class="line">                <span class="comment">// R, G, B, A</span></span><br><span class="line">                -<span class="number">0.5f</span>, -<span class="number">0.25f</span>, <span class="number">0.0f</span>,</span><br><span class="line">                <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">                ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>上面展示的代表三角形的一个点。我们已设置好前三个数字代表位置（X,Y,Z），随后的四个数字代表颜色（红，绿，蓝，透明度）。<br>您不必太担心如何定义这个数组；只要记住当我们想绘制东西在OpenGL ES 2时，我们需要以块的形式传递数据，而不是一次传递一个。</p><h3 id="了解缓冲区">了解缓冲区<a href="post/Learn-OpenGL-Lesson-One#了解缓冲区"></a></h3><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化缓冲区</span></span><br><span class="line">mTriangle1Verticels = ByteBuffer.allocateDirect(triangle1VerticesData.length * mBytePerFloat).order(ByteOrder.nativeOrder()).asFloatBuffer();</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><p>我们在Android上使用Java进行编码，但OpengGL ES 2底层实现其实使用C语言编写的。<br>在我们将数据传递给OpenGL之前，我们需要将其转换成它能理解的形式。<br>Java和native系统可能不会以相同的顺序存储它们的字节，因此我们使用一个特殊的缓冲类并创建一个足够大的<code>ByteBuffer</code>来保存我们的数据，并告诉它使用native字节顺序存储数据。<br>然后我们将它转换成<code>FloatBuffer</code>，以便我们可以使用它来保存浮点数据。<br>最后，我们将数组复制到缓冲区。</p><p>这个缓冲区的东西看起来可能很混乱，单请记住，在将数据传递给OpenGL之前，我们需要做一个额外的步骤。我们现在的缓冲区已准备好可以用于将数据传入OpenGL。</p><p><strong>另外，<a href="https://issuetracker.google.com/issues/36921128" target="_blank" rel="noopener">float缓冲区在Froyo上很慢</a>,在Gingerbread上缓慢，因此您可能不希望经常更换它们。</strong></p><h3 id="理解矩阵">理解矩阵<a href="post/Learn-OpenGL-Lesson-One#理解矩阵"></a></h3><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new class 定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储view矩阵。可以认为这是一个相机，我们通过相机将世界空间转换为眼睛空间</span></span><br><span class="line"><span class="comment"> * 它定位相对于我们眼睛的东西</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mViewMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置背景清理颜色为灰色</span></span><br><span class="line">    GLES20.glClearColor(<span class="number">0.5F</span>, <span class="number">0.5F</span>, <span class="number">0.5F</span>, <span class="number">0.5F</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将眼睛放到原点之后</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> eyeX = <span class="number">0.0F</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> eyeY = <span class="number">0.0F</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> eyeZ = <span class="number">1.5F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的眼睛望向哪</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> lookX = <span class="number">0.0F</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> lookY = <span class="number">0.0F</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> lookZ = -<span class="number">5.0F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置我们的向量，这是我们拿着相机时头指向的方向</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> upX = <span class="number">0.0F</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> upY = <span class="number">1.0F</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> upZ = <span class="number">0.0F</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体场景：把手机正放桌面上，然后我们去看屏幕里面的东西</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置view矩阵，可以说这个矩阵代表相机的位置</span></span><br><span class="line">    <span class="comment">// 注意：在OpenGL 1中使用ModelView matrix，这是一个model和view矩阵的组合。</span></span><br><span class="line">    <span class="comment">//在OpenGL2中，我们选择分别跟踪这些矩阵</span></span><br><span class="line">    Matrix.setLookAtM(mViewMatrix, <span class="number">0</span>, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>另一个有趣的话题是矩阵！无论您何时进行3D编程，这些都将成为您最好的朋友。因此，您需要很好的了解他们。</p><p>当我们的界面被创建，我们第一件事情是设置清理颜色为灰色。alpha部分也设置为灰色，但在我们本课程中没有进行alpha混合，因此该值未使用。我们只需要设置一次清理颜色，之后我们不会更改它。</p><p>我们第二件事情是设置view矩阵。我们使用了几个不同种类的矩阵，它们都做了些重要的事情：</p><ol><li>model（模型）矩阵，该矩阵用于在“世界”中的某处放置模型。例如，您有一个模型车，你想将它放置在东边一千米处，您将使用矩阵模型来做这件事。</li><li>view （视图)矩阵，该矩阵代表相机。如果我们想查看位于东边一千米处的车，我们也需要向东移动一千米（另一种思考方式是我们保持静止，世界向西移动一千米）。我们使用视图矩阵来做到这点。</li><li>projection（投影)矩阵。由于我们的屏幕是平面的，我们需要进行最后的转换，将我们的视图“投影”到我们的屏幕上并获得漂亮的3D视角。这就是投影矩阵的用途</li></ol><p>可以在<a href="http://www.songho.ca/opengl/gl_transform.html" target="_blank" rel="noopener">SongHo的OpenGL教程</a>中找到很好的解释。我建议您阅读几次直到您把握好这个想法为止；别担心，我也阅读了它好几次！</p><p>在OpenGL 1中，模型和视图矩阵被组合并且假设了摄像机处于(0,0,0)坐标并面向Z轴方向。</p><p>我们不需要手动构建这些矩阵，Android有一个Matrix帮助类，它能为我们做繁重的工作。这里，我为摄像机创建了一个视图矩阵，它位于原点后，朝向远处。</p><h3 id="定义vertex（顶点）和fragment（片段）着色器">定义vertex（顶点）和fragment（片段）着色器<a href="post/Learn-OpenGL-Lesson-One#定义vertex（顶点）和fragment（片段）着色器"></a></h3><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String vertexShader =</span><br><span class="line">        <span class="string">"uniform mat4 u_MVPMatrix;    \n"</span> + <span class="comment">// 一个表示组合model、view、projection矩阵的常量</span></span><br><span class="line">        <span class="string">"attribute vec4 a_Position;   \n"</span> + <span class="comment">// 我们将要传入的每个顶点的位置信息</span></span><br><span class="line">        <span class="string">"attribute vec4 a_Color;      \n"</span> + <span class="comment">// 我们将要传入的每个顶点的颜色信息</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"varying vec4 v_Color;        \n"</span> + <span class="comment">// 他将被传入片段着色器</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"void main()                  \n"</span> + <span class="comment">// 顶点着色器入口</span></span><br><span class="line">        <span class="string">"&#123;                            \n"</span> +</span><br><span class="line">        <span class="string">"   v_Color = a_Color;        \n"</span> + <span class="comment">// 将颜色传递给片段着色器</span></span><br><span class="line">                                            <span class="comment">// 它将在三角形内插值</span></span><br><span class="line">        <span class="string">"   gl_Position = u_MVPMatrix \n"</span> + <span class="comment">// gl_Position是一个特殊的变量用来存储最终的位置</span></span><br><span class="line">        <span class="string">"               * a_Position  \n"</span> + <span class="comment">// 将顶点乘以矩阵得到标准化屏幕坐标的最终点</span></span><br><span class="line">        <span class="string">"&#125;                            \n"</span>;</span><br></pre></td></tr></table></div></figure><p>在OpenGL ES 2中任何我们想展示在屏幕中的东西都必须先经过顶点和片段着色器，还好这些着色器并不像他们看起来的那么复杂。顶点着色器在每个顶点执行操作，并把这些操作的结果使用在片段着色器做额外的每像素计算。</p><p>每个着色器基本由输入（input）、输出（output）和一个程序（program）组成。<br>首先我们定义一个统一（uniform），它是一个包含所有变换的组合矩阵。它是所有顶点的常量，用于将它们投影到屏幕上。<br>然后我们定义了位置和颜色属性（attribute），这些属性将从我们之前定义的缓存区中读入，并指定每个顶点的位置和颜色。<br>接着我们定义了一个变量（varying），它负责在三角形中插值并传递到片段着色器。当它运行到片段着色器，它将为每个像素持有一个插值。</p><p>假设我们定义了一个三角形每个点都是红色、绿色和蓝色，我们调整它的大小让它占用10像素屏幕。当片段着色器运行时，它将为每像素包含一个不同的变量（varying）颜色。在某一点上，变量（varying）将是红色，但是在红色和蓝色之间它可能是更紫的颜色。</p><p>除了设置颜色，我们还告诉OpenGL顶点在屏幕上的最终位置。然后我们定义片段着色器：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String fragmentShader =</span><br><span class="line">        <span class="string">"precision mediump float;       \n"</span> + <span class="comment">// 我们将默认精度设置为中等，我们不需要片段着色器中的高精度</span></span><br><span class="line">        <span class="string">"varying vec4 v_Color;          \n"</span> + <span class="comment">// 这是从三角形每个片段内插的顶点着色器的颜色</span></span><br><span class="line">        <span class="string">"void main()                    \n"</span> + <span class="comment">// 片段着色器入口</span></span><br><span class="line">        <span class="string">"&#123;                              \n"</span> +</span><br><span class="line">        <span class="string">"   gl_FragColor = v_Color;     \n"</span> + <span class="comment">// 直接将颜色传递</span></span><br><span class="line">        <span class="string">"&#125;                              \n"</span>;</span><br></pre></td></tr></table></div></figure><p>这是个片段着色器，它会将东西放到屏幕上。在这个着色器中，我们得到的变量（varying）颜色来自顶点着色器，然后将它直接传递给OpenGL。该点已按像素插值，因为片段着色器将针对每个将要绘制的像素点运行。</p><p>更多信息：<a href="http://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf" target="_blank" rel="noopener">OpenGL ES 2 API快速参考卡</a></p><h3 id="将着色器加载到OpenGL">将着色器加载到OpenGL<a href="post/Learn-OpenGL-Lesson-One#将着色器加载到OpenGL"></a></h3><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载顶点着色器</span></span><br><span class="line"><span class="keyword">int</span> vertexShaderHandle = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER);</span><br><span class="line"><span class="keyword">if</span> (vertexShaderHandle != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 传入顶点着色器源代码</span></span><br><span class="line">    GLES20.glShaderSource(vertexShaderHandle, vertexShader);</span><br><span class="line">    <span class="comment">// 编译顶点着色器</span></span><br><span class="line">    GLES20.glCompileShader(vertexShaderHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取编译状态</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] compileStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    GLES20.glGetShaderiv(vertexShaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果编译失败则删除着色器</span></span><br><span class="line">    <span class="keyword">if</span> (compileStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        GLES20.glDeleteShader(vertexShaderHandle);</span><br><span class="line">        vertexShaderHandle = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vertexShaderHandle == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error creating vertex shader."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>首先，我们创建一个着色器对象。如果成功，我们将得到这个对象的引用。<br>然后，我们使用这个引用传入着色器源码然后编译它。<br>我们可以从OpenGL获取编译是否成功的状态，如果失败我们可以使用<code>GLES20.glGetShaderInfoLog(shader)</code>找到原因。我们按照相同的步骤加载片段着色器。</p><h3 id="将顶点和片段着色器链接到一个程序中">将顶点和片段着色器链接到一个程序中<a href="post/Learn-OpenGL-Lesson-One#将顶点和片段着色器链接到一个程序中"></a></h3><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个程序对象并将引用放进去</span></span><br><span class="line"><span class="keyword">int</span> programHandle = GLES20.glCreateProgram();</span><br><span class="line"><span class="keyword">if</span> (programHandle != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 绑定顶点着色器到程序对象中</span></span><br><span class="line">    GLES20.glAttachShader(programHandle, vertexShaderHandle);</span><br><span class="line">    <span class="comment">// 绑定片段着色器到程序对象中</span></span><br><span class="line">    GLES20.glAttachShader(programHandle, fragmentShaderHandle);</span><br><span class="line">    <span class="comment">// 绑定属性</span></span><br><span class="line">    GLES20.glBindAttribLocation(programHandle, <span class="number">0</span>, <span class="string">"a_Position"</span>);</span><br><span class="line">    GLES20.glBindAttribLocation(programHandle, <span class="number">1</span>, <span class="string">"a_Color"</span>);</span><br><span class="line">    <span class="comment">// 将两个着色器连接到程序</span></span><br><span class="line">    GLES20.glLinkProgram(programHandle);</span><br><span class="line">    <span class="comment">// 获取连接状态</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] linkStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    GLES20.glGetProgramiv(programHandle, GLES20.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果连接失败，删除这程序</span></span><br><span class="line">    <span class="keyword">if</span> (linkStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        GLES20.glDeleteProgram(programHandle);</span><br><span class="line">        programHandle = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (programHandle == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error creating program."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在我们使用顶点和片段着色器之前，我们需要将它们绑定到一个程序中，它连接了顶点着色器的输出和片段着色器的输入。这也是让我们从程序传递输入并使用着色器绘制形状的原因。</p><p>我们创建一个程序对象，如果成功绑定着色器。我们想要将位置和颜色作为属性传递进去，因此我们需要绑定这些属性。然后我们将着色器连接到一起。</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新类成员</span></span><br><span class="line"><span class="comment">/** 这将用于传递变换矩阵*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mMVPMatrixHandle;</span><br><span class="line"><span class="comment">/** 用于传递model位置信息*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mPositionHandle;</span><br><span class="line"><span class="comment">/** 用于传递模型颜色信息*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mColorHandle;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置程序引用，这将在之后传递值到程序时使用</span></span><br><span class="line">    mMVPMatrixHandle = GLES20.glGetUniformLocation(programHandle, <span class="string">"u_MVPMatrix"</span>);</span><br><span class="line">    mPositionHandle = GLES20.glGetAttribLocation(programHandle, <span class="string">"a_Position"</span>);</span><br><span class="line">    mColorHandle = GLES20.glGetAttribLocation(programHandle, <span class="string">"a_Color"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉OpenGL渲染的时候使用这个程序</span></span><br><span class="line">    GLES20.glUseProgram(programHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在我们成功连接程序后，我们还要完成几个任务，以便我们能实际使用它。<br>第一个任务是获取引用，因为我们要传递数据到程序中。<br>然后我们要告诉OpenGL在绘制时使用我们这个程序。<br>由于本课我们仅使用了一个程序，我们可以将它放到<code>onSurfaceCreated()</code>方法中而不是<code>onDrawFrame()</code></p><h3 id="设置透视投影">设置透视投影<a href="post/Learn-OpenGL-Lesson-One#设置透视投影"></a></h3><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新类成员</span></span><br><span class="line"><span class="comment">// 存放投影矩阵，用于将场景投影到2D视角</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mProjectionMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置OpenGL界面和当前视图相同的尺寸</span></span><br><span class="line">    GLES20.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的透视投影矩阵，高度保持不变，而高度根据纵横比而变换</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> ratio = (<span class="keyword">float</span>) width / height;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> left = -ratio;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> right = ratio;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> bottom = -<span class="number">1.0F</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> top = <span class="number">1.0F</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> near = <span class="number">1.0F</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> far = <span class="number">10.0F</span>;</span><br><span class="line"></span><br><span class="line">    Matrix.frustumM(mProjectionMatrix, <span class="number">0</span>, left, right, bottom, top, near, far);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>onSurfaceChanged()</code>方法至少被调用一次，每当界面改变也会被调用。因为我们需要每当界面改变的时候重置投影矩阵，那么<code>onSurfaceChanged()</code>方法中是个理想的地方。</p><h3 id="绘制东西到屏幕上！">绘制东西到屏幕上！<a href="post/Learn-OpenGL-Lesson-One#绘制东西到屏幕上！"></a></h3><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新类成员</span></span><br><span class="line"><span class="comment">// 存放模型矩阵，该矩阵用于将模型从对象空间（可以认为每个模型开始都位于宇宙的中心）移动到世界空间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mModelMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">    GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每10s完成一次旋转</span></span><br><span class="line">    <span class="keyword">long</span> time = SystemClock.uptimeMillis() % <span class="number">10000L</span>;</span><br><span class="line">    <span class="keyword">float</span> angleDegrees = (<span class="number">360.0F</span> / <span class="number">10000.0F</span>) * ((<span class="keyword">int</span>)time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 画三角形</span></span><br><span class="line">    Matrix.setIdentityM(mModelMatrix, <span class="number">0</span>);</span><br><span class="line">    Matrix.rotateM(mModelMatrix, <span class="number">0</span>, angleDegrees, <span class="number">0.0F</span>, <span class="number">0.0F</span>, <span class="number">1.0F</span>);</span><br><span class="line">    drawTriangle(mTriangle1Verticels);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这是实际显示在屏幕上的内容。我们清理屏幕，因此不会得到任何奇怪的<a href="https://en.wikipedia.org/wiki/Noclip_mode#.22Hall_of_mirrors.22_effect" target="_blank" rel="noopener">镜像效应</a>影响，我们希望我们的三角形在屏幕上能有平滑的动画，通常使用时间而不是帧率更好。</p><blockquote><p>实际绘制在<code>drawTriangle()</code>方法中完成</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新的类成员</span></span><br><span class="line"><span class="comment">/** 为最终的组合矩阵分配存储空间，这将用来传入着色器程序*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mMVPMatrix = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 每个顶点有多少字节组成，每次需要迈过这么一大步（每个顶点有7个元素，3个表示位置，4个表示颜色，7 * 4 = 28个字节）*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mStrideBytes = <span class="number">7</span> * mBytePerFloat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 位置数据偏移量*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mPositionOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 一个元素的位置数据大小*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mPositionDataSize = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 颜色数据偏移量*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mColorOffset = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 一个元素的颜色数据大小*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mColorDataSize = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从给定的顶点数据中绘制一个三角形</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> aTriangleBuffer 包含顶点数据的缓冲区</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(FloatBuffer aTriangleBuffer)</span> </span>&#123;</span><br><span class="line">    aTriangleBuffer.position(mPositionOffset);</span><br><span class="line">    GLES20.glVertexAttribPointer(</span><br><span class="line">            mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, <span class="keyword">false</span>,</span><br><span class="line">            mStrideBytes, aTriangleBuffer);</span><br><span class="line"></span><br><span class="line">    GLES20.glEnableVertexAttribArray(mPositionHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入颜色信息</span></span><br><span class="line">    aTriangleBuffer.position(mColorOffset);</span><br><span class="line">    GLES20.glVertexAttribPointer(mColorHandle, mColorDataSize, GLES20.GL_FLOAT, <span class="keyword">false</span>,</span><br><span class="line">            mStrideBytes, aTriangleBuffer);</span><br><span class="line"></span><br><span class="line">    GLES20.glEnableVertexAttribArray(mColorHandle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将视图矩阵乘以模型矩阵，并将结果存放到MVP Matrix（model * view）</span></span><br><span class="line">    Matrix.multiplyMM(mMVPMatrix, <span class="number">0</span>, mViewMatrix, <span class="number">0</span>, mModelMatrix, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将上面计算好的视图模型矩阵乘以投影矩阵，并将结果存放到MVP Matrix（model * view * projection）</span></span><br><span class="line">    Matrix.multiplyMM(mMVPMatrix, <span class="number">0</span>, mProjectionMatrix, <span class="number">0</span>, mMVPMatrix, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    GLES20.glUniformMatrix4fv(mMVPMatrixHandle, <span class="number">1</span>, <span class="keyword">false</span>, mMVPMatrix, <span class="number">0</span>);</span><br><span class="line">    GLES20.glDrawArrays(GLES20.GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>您还记得我们最初创建渲染器时定义的那些缓冲区吗？我们终于可以使用它们了。<br>我们需要使用<code>GLES20.glVertexAttribPointer()</code>来告诉OpenGL怎样使用这些数据。</p><blockquote><p>我们来看第一个使用</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aTriangleBuffer.position(mPositionOffset);</span><br><span class="line">GLES20.glVertexAttribPointer(</span><br><span class="line">        mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, <span class="keyword">false</span>,</span><br><span class="line">        mStrideBytes, aTriangleBuffer);</span><br><span class="line">GLES20.glEnableVertexAttribArray(mPositionHandle);</span><br></pre></td></tr></table></div></figure><p>我们设置缓冲区的位置偏移，它位于缓冲区的开头。然后我们告诉OpenGL使用这些数据并将其提供给顶点着色器并将其应用到位置属性（a_Position）。我们也需要告诉OpenGL每个顶点或迈幅之间有多少个元素。</p><blockquote><p>注意：迈幅（Stride）需要定义为字节（byte），尽管每个顶点之间我们有7个元素（3个是位置，4个是颜色），但我们事实上有28个字节，因为每个浮点数（float）就是4个字节（byte）。忘记此步骤您可能没有任何错误，但是你会想知道为什么您的屏幕上看不到任何内容。</p></blockquote><p>最终，我们使用了顶点属性，往下我们使用了下一个属性。再往后点我们构建一个组合矩阵，将点投影到屏幕上。我们也可以在顶点着色器中执行此操作，但是由于它只需要执行一次我们也可以只缓存结果。<br>我们使用<code>GLES20.glUniformMatrix4fv()</code>方法将最终的矩阵传入顶点着色器。<br><code>GLES20.glDrawArrays()</code>将我们的点转换为三角形并将其绘制在屏幕上。</p><h2 id="总结">总结<a href="post/Learn-OpenGL-Lesson-One#总结"></a></h2><p>呼呼！这是重要的一课，如果您完成了本课，感谢您！<br>我们学习了怎样创建OpenGL上下文，传入形状数据，加载顶点和片段着色器，设置我们的转换矩阵，最终放在一起。<br>如果一切顺利，您因该看到了类似下面的截屏。<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/learn-opengl/20190122233309.png" alt="screenshot"></p><p>这一课有很多需要消化的内容，您可能需要多次阅读这些步骤才能理解它。<br>OpenGL ES 2需要更多的设置才能开始，但是一旦您完成了这个过程几次，您就会记住这个流程。</p><h2 id="在Android市场上发布">在Android市场上发布<a href="post/Learn-OpenGL-Lesson-One#在Android市场上发布"></a></h2><p>当开发的应用我们不想在无法运行这些应用程序的人在市场上看到它们，否则当应用程序在其设备上崩溃时，我们可能会收到大量糟糕的评论和评分。<br>要防止OpenGL ES 2 应用程序出现在不支持它的设备上，你可以在清单文件中添加：</p><figure class="highlight xml"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:glEsVersion</span>=<span class="string">"0x00020000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:required</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></div></figure><p>这告诉市场您的app需要有OpenGL ES 2支持，不支持的设备将会隐藏您的app。</p><h2 id="进一步探索">进一步探索<a href="post/Learn-OpenGL-Lesson-One#进一步探索"></a></h2><p>尝试更改动画速度，顶点或颜色，看看会发生什么！<br>可以在Github下载本课程源代码：<a href="https://github.com/learnopengles/Learn-OpenGLES-Tutorials" target="_blank" rel="noopener">下载项目</a><br>本课的编译版本也可以再Android市场下：<a href="https://market.android.com/details?id=com.learnopengles.android" target="_blank" rel="noopener">google play 下载apk</a><br>“我”也编译了个apk，方便大家下载：<a href="https://github.com/xujiaji/LearnOpenGL/releases" target="_blank" rel="noopener">github download</a></p><h2 id="教程目录">教程目录<a href="post/Learn-OpenGL-Lesson-One#教程目录"></a></h2><ul><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-One">OpenGL Android课程一：入门</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Two">OpenGL Android课程二：环境光和漫射光</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Three">OpenGL Android课程三：使用每片段照明</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Four">OpenGL Android课程四：介绍纹理基础</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Five">OpenGL Android课程五：介绍混合（Blending）</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Six">OpenGL Android课程六：介绍纹理过滤</a></li><li><a href="https://blog.xujiaji.com/post/Learn-OpenGL-Lesson-Seven">OpenGL Android课程七：介绍Vertex Buffer Objects（顶点缓冲区对象，简称：VOB）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;翻译文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文标题：OpenGL Android Lesson One: Getting Started&lt;br&gt;原文链接：&lt;a href=&quot;http://www.learnopengles.com/android-lesson-one-getting-started/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.learnopengles.com/android-lesson-one-getting-started/&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/categories/OpenGL/"/>
    
    
      <category term="Android" scheme="https://blog.xujiaji.com/tags/Android/"/>
    
      <category term="OpenGL" scheme="https://blog.xujiaji.com/tags/OpenGL/"/>
    
      <category term="学习" scheme="https://blog.xujiaji.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="翻译" scheme="https://blog.xujiaji.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>C 学习笔记</title>
    <link href="https://blog.xujiaji.com/post/c-learn-note/index.html"/>
    <id>https://blog.xujiaji.com/post/c-learn-note/index.html</id>
    <published>2018-12-25T15:18:45.000Z</published>
    <updated>2019-05-15T08:15:04.969Z</updated>
    
    <content type="html"><![CDATA[<p>重学一次C语言，记录一下学习《C Primer Plus》的笔记，方便回忆！</p><a id="more"></a><h2 id="编译">编译<a href="post/c-learn-note#编译"></a></h2><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o foo.exe foo.c -lregex</span><br><span class="line">gcc foo.c -o foo.exe -lregex</span><br></pre></td></tr></table></div></figure><h2 id="字符串和格式化输入-输出">字符串和格式化输入/输出<a href="post/c-learn-note#字符串和格式化输入-输出"></a></h2><ol><li>字符串以<code>char</code>数组来存储</li><li><p>常量用 <code>#define</code> 定义</p><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DENSITY 62.4</span></span><br></pre></td></tr></table></div></figure></li><li><p><code>strlen()</code>获取字符串的长度，注意需要<code>#include &lt;string.h&gt;</code></p></li><li><code>char</code>类型数组和<code>null</code>字符<ol><li>C语言没有专门用于储存字符串的变量类型，字符串都被储存在<code>char</code>类型的数组中</li><li>字符串以<code>\0</code>（空字符）结束，它是不打印出来的字符</li><li>如果有40哥存储单单元的字符串，只能储存39哥字符，剩下一个字节留给空字符</li></ol></li><li><p>一下代码<code>%s</code>作为转化说明，<code>scanf()</code>只会读取字符串中的一个单词。并且没有加<code>&amp;</code>取地址符，<code>name</code>就是地址</p><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br></pre></td></tr></table></div></figure></li><li><p><code>&quot;x&quot;</code>不同于<code>&#39;x&#39;</code>,<code>&quot;x&quot;</code>是字符串由<code>x</code>和<code>\0</code>组成</p></li><li><code>sizeof</code>运算符，它以字节为单位给出对象的大小。<code>strlen()</code>只给出字符串长度，到空字符（不包括空字符）<ol><li>C99和C11标准专门为<code>sizeof</code>运算符的返回类型添加了<code>%zd</code>转换说明，对于<code>strlen()</code>也适用</li><li><code>sizeof</code>使用时，对于类型必须加括号。对于特定量，可有可无。类型：<code>sizeof(char)</code>, <code>sizeof(float)</code>; 特定量：<code>sizeof 6.28</code>, <code>sizeof name</code></li></ol></li></ol><h2 id="常量和C预处理器">常量和C预处理器<a href="post/c-learn-note#常量和C预处理器"></a></h2><ol><li><p>C预处理器定义常量：<code>#define NAME value</code>，其中“NAME”为命令的常量名，约定大写；“value”是对应的值</p><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="type">BEEP</span> '\a'</span><br><span class="line">#define <span class="type">TEE</span> '<span class="type">T'</span></span><br><span class="line">#define <span class="type">ESC</span> '\<span class="number">033</span>'</span><br><span class="line">#define <span class="type">OOPS</span> <span class="string">"Now you have done it!"</span></span><br></pre></td></tr></table></div></figure></li><li><p><code>const</code>限定符，C90标准新增该关键字，用于限定一个变量为只读</p></li><li>明示常量：C头文件<code>limits.h</code>和<code>float.h</code>分别提供了与整数类型和浮点数类型大小限制相关的详细信息<figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">#include &lt;float.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Some number limits for this system: \n"</span>);</span><br><span class="line">    printf(<span class="string">"Biggest int: %d\n"</span>, <span class="type">INT_MAX</span>);</span><br><span class="line">    printf(<span class="string">"Smallest long long: %lld\n"</span>, <span class="type">LLONG_MIN</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重学一次C语言，记录一下学习《C Primer Plus》的笔记，方便回忆！&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="https://blog.xujiaji.com/categories/C/"/>
    
    
      <category term="学习" scheme="https://blog.xujiaji.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="https://blog.xujiaji.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C" scheme="https://blog.xujiaji.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>一个项目如何编译多个不同签名、包名、资源等，的apk？</title>
    <link href="https://blog.xujiaji.com/post/android-project-one-for-more/index.html"/>
    <id>https://blog.xujiaji.com/post/android-project-one-for-more/index.html</id>
    <published>2018-10-29T08:15:20.000Z</published>
    <updated>2019-04-08T06:54:02.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介<a href="post/android-project-one-for-more#简介"></a></h2><p>如题所示！本篇文章就是为了解决这种问题。方便打包和运行的时候能做到无需手动替换配置，即可打包想要的apk。打包的时候，只需选一下想打哪种配置的apk就OK啦。 (^o^)/~</p><blockquote><p>先来看，有需求如下：</p></blockquote><ol><li>同一个项目</li><li>不同的apk图标</li><li>不同的服务器域名</li><li>不同的包名</li><li>不同的名称</li><li>不同的签名</li><li>不同的第三方key</li><li>不同的版本名版本号</li></ol><blockquote><p>解决思路</p></blockquote><ol><li>当然最直接的方式不过于每次打不同包的时候都去替换对应的配置，这种方式的麻烦之处不言而喻。</li><li>将所有配置，资源等都配置入项目中，打包的时候，根据选择渠道打包不同配置的apk。（本篇文章就是要讲怎么这么做的）</li><li>相信还有其他的。。。</li></ol><h2 id="相关的几个要点">相关的几个要点<a href="post/android-project-one-for-more#相关的几个要点"></a></h2><ol><li><p>首先我们需要知道<code>productFlavors</code>来配置渠道，这里我将渠道用来表示哪种apk，如下我需要配置四种应用:</p><figure class="highlight groovy"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">  userquhua &#123;&#125;</span><br><span class="line">  quhua &#123;&#125;</span><br><span class="line">  cuntuba &#123;&#125;</span><br><span class="line">  xemh &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p>如果我们选择了某一个渠道，那么运行打包的时候会根据渠道名选择资源文件（可结合第6点一起看）<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/one-for-more/20181029171053.png" alt=""></p></li><li><p>签名可在<code>signingConfigs</code>中配置多个（我将所有签名文件放在了项目跟目录的key文件夹中），这样我们就可以通过<code>signingConfigs</code>指定预制好的签名配置。</p><figure class="highlight groovy"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    userquhuaRelease &#123;</span><br><span class="line">        storeFile file(<span class="string">"../key/xxx1.keystore"</span>)</span><br><span class="line">        storePassword <span class="string">"xxxxxx"</span></span><br><span class="line">        keyAlias <span class="string">"alias"</span></span><br><span class="line">        keyPassword <span class="string">"xxxxxx"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quhuaRelease &#123;</span><br><span class="line">        storeFile file(<span class="string">"../key/xxx2.keystore"</span>)</span><br><span class="line">        storePassword <span class="string">"xxxxxx"</span></span><br><span class="line">        keyAlias <span class="string">"alias"</span></span><br><span class="line">        keyPassword <span class="string">"xxxxxx"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cuntubaRelease &#123;</span><br><span class="line">        storeFile file(<span class="string">"../key/xxx3.keystore"</span>)</span><br><span class="line">        storePassword <span class="string">"xxxxxx"</span></span><br><span class="line">        keyAlias <span class="string">"alias"</span></span><br><span class="line">        keyPassword <span class="string">"xxxxxx"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xemhRelease &#123;</span><br><span class="line">        storeFile file(<span class="string">"../key/xxx4.keystore"</span>)</span><br><span class="line">        storePassword <span class="string">"xxxxxx"</span></span><br><span class="line">        keyAlias <span class="string">"alias"</span></span><br><span class="line">        keyPassword <span class="string">"xxxxxx"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p>可在build.gradle中配置动态配置java代码调用的常量数据（如：通过该方式我们可根据不同渠道动态配置第三方appid，或其他需要根据渠道而改变的数据）</p><ul><li><p>比如：我们在<code>defaultConfig {}</code> 中定义了:</p><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buildConfigField &quot;String&quot;, &quot;SERVER_URL&quot;, &apos;&quot;http://xx.xxxx.com/&quot;&apos;</span><br></pre></td></tr></table></div></figure></li><li><p>此时，您看一下清单文件中<code>manifest</code>标签里的，<code>package</code>的值，假如是：</p><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.xxx.xx</span><br></pre></td></tr></table></div></figure></li><li><p>那么，您就可以在java代码中通过导入文件：</p><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import com.xxx.xx.BuildConfig;</span><br></pre></td></tr></table></div></figure></li><li><p>然后调用</p><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuildConfig.SERVER_URL</span><br></pre></td></tr></table></div></figure></li></ul><p>它的值就是上边配置的字符串：<code>http://xx.xxxx.com/</code>。</p><ul><li>您可以进入<code>BuildConfig</code>看一看，里面还包含了一些当前的包名版本号等信息。<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/one-for-more/20181030234102.png" alt=""></li></ul></li><li><p>在渠道配置那里可以配置对应的包名版本名签名等等<br>如下所示：</p><figure class="highlight groovy"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略其他配置...</span></span><br><span class="line">android &#123;</span><br><span class="line">  <span class="comment">// 省略其他配置...</span></span><br><span class="line">  productFlavors &#123;</span><br><span class="line">      userquhua &#123;</span><br><span class="line">          applicationId <span class="string">"com.xxx.xx"</span></span><br><span class="line">          versionCode <span class="number">1</span></span><br><span class="line">          versionName <span class="string">"1.0.0"</span></span><br><span class="line">          signingConfig signingConfigs.userquhuaRelease <span class="comment">// 配置签名</span></span><br><span class="line"></span><br><span class="line">          String qq_id = <span class="string">'"xxxxxxxxx"'</span> <span class="comment">//配置qq appid</span></span><br><span class="line">          buildConfigField <span class="string">"String"</span>,           <span class="string">"QQ_ID"</span>, qq_id</span><br><span class="line">          buildConfigField <span class="string">"String"</span>,           <span class="string">"WX_ID"</span>, <span class="string">'"wxxxxxxxxxxxxxxxxx"'</span> <span class="comment">// 配置微信appid</span></span><br><span class="line">          manifestPlaceholders = [</span><br><span class="line"><span class="symbol">            qq_id:</span> qq_id,</span><br><span class="line">            <span class="string">JPUSH_PKGNAME :</span> applicationId,</span><br><span class="line">            <span class="string">JPUSH_APPKEY :</span> <span class="string">"xxxxxxxxxxxxxxxxxxxxxxxxxxxxx"</span>, <span class="comment">//JPush 上注册的包名对应的 Appkey.</span></span><br><span class="line">            <span class="string">JPUSH_CHANNEL :</span> <span class="string">"developer-default"</span>,</span><br><span class="line">          ]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">      <span class="comment">// 省略其他配置...</span></span><br><span class="line">        signingConfig <span class="literal">null</span>  <span class="comment">// 置空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug &#123;</span><br><span class="line">      <span class="comment">// 省略其他配置...</span></span><br><span class="line">        signingConfig <span class="literal">null</span> <span class="comment">// 置空</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>这样，如果我们打包userquhua这个渠道，看第2点中介绍选择userquhuaDebug。</li><li>然后，最好clean一下项目、然后我们运行项目。</li><li>该app的包名就是<code>com.xxx.xx</code>，版本号为<code>1</code>，版本名为<code>1.0.0</code>。</li><li>通过<code>BuildConfig</code>调用<code>QQ_ID</code>静态常量，就是该渠道里配置的值，<code>WX_ID</code>同理。</li><li><code>manifestPlaceholders</code>配置也可以这样配置。</li><li>签名问题经过个人反复尝试（然后半天就过去了￣へ￣），最终签名如上配置。<strong>需要注意</strong><code>buildTypes</code>中的签名配置<code>signingConfig</code>如果不设置为<code>null</code>，那么打包的是有还是以内置的签名打包。</li></ul></li><li>资源文件替换<br>再看到第2点的介绍，我们选择运行渠道后，会默认匹配对应渠道下的资源。下面我将<code>xemh</code>渠道的资源目录全部展开一下。<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/one-for-more/20181029233306.png" alt=""><ul><li>如上图这样，只需要资源名字和app目录对应的文件名字一样即可替换。</li><li>strings.xml里的应用名，只需要将对应<code>app_name</code>修改既可替换app下strings的<code>app_name</code>，其他不用替换的不用写就行。</li></ul></li><li>打正式包的时候选好渠道，就可以打包不同配置的apk，当然您也可以使用命令的方式。<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/one-for-more/20181029234235.png" alt=""></li></ol><h2 id="其他配置记录">其他配置记录<a href="post/android-project-one-for-more#其他配置记录"></a></h2><blockquote><p>获取当前时间</p></blockquote><figure class="highlight groovy"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">def</span> releaseTime() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyy-MM-dd-HH.mm"</span>, TimeZone.getTimeZone(<span class="string">"GMT+8"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>打包的时候，修改文件名，以方便区别渠道和版本打包时间</p></blockquote><figure class="highlight groovy"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">applicationVariants.all &#123;</span><br><span class="line">    variant -&gt;</span><br><span class="line">        variant.outputs.all &#123;</span><br><span class="line">            outputFileName = <span class="string">"$&#123;variant.productFlavors[0].name&#125;-v$&#123;variant.productFlavors[0].versionName&#125;-$&#123;releaseTime()&#125;.apk"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><code>${variant.productFlavors[0].name}</code>当前渠道名</li><li><code>${variant.productFlavors[0].versionName}</code>当前版本名</li><li><code>${releaseTime()}</code>当前时间</li></ul><h2 id="其他需要注意事项">其他需要注意事项<a href="post/android-project-one-for-more#其他需要注意事项"></a></h2><p>如果您在清单文件<code>AndroidManifest.xml</code>中，有那种以包名开头命名的那种。因为如果包名都改了，有些也需要动态的改变。可以用<code>${applicationId}</code>代替。在打包的时候，会自动替换成当前包名。</p><blockquote><p>比如，类似下配置：</p></blockquote><figure class="highlight xml"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.xxx.xx.permission.JPUSH_MESSAGE"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:protectionLevel</span>=<span class="string">"signature"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.xxx.xx.permission.JPUSH_MESSAGE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".push.MyJPushMessageReceiver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"cn.jpush.android.intent.RECEIVE_MESSAGE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.xxx.xx"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"com.xxx.xx.provider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:replace</span>=<span class="string">"android:authorities"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></div></figure><blockquote><p>可改为：</p></blockquote><figure class="highlight xml"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"$&#123;applicationId&#125;.permission.JPUSH_MESSAGE"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:protectionLevel</span>=<span class="string">"signature"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"$&#123;applicationId&#125;.permission.JPUSH_MESSAGE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".push.MyJPushMessageReceiver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"cn.jpush.android.intent.RECEIVE_MESSAGE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"$&#123;applicationId&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.provider"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:replace</span>=<span class="string">"android:authorities"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></div></figure><blockquote><p>当然值得注意的是，在代码中我们也不能把包名写死了，可通过<code>BuildConfig</code>得到当前包名</p></blockquote><h2 id="我的完整配置，供参考">我的完整配置，供参考<a href="post/android-project-one-for-more#我的完整配置，供参考"></a></h2><blockquote><p>有关隐私信息的都用xxx替换了</p></blockquote><ol><li><p>项目根目录的<code>build.gradle</code></p><figure class="highlight groovy"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:3.0.0'</span></span><br><span class="line">        classpath <span class="string">"io.github.prototypez:save-state:0.1.7"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">"https://jitpack.io"</span> &#125;</span><br><span class="line">        maven &#123; url <span class="string">'http://oss.jfrog.org/artifactory/oss-snapshot-local/'</span> &#125;</span><br><span class="line">        flatDir &#123;</span><br><span class="line">            dirs <span class="string">'libs'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(<span class="string">type:</span> Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext&#123;</span><br><span class="line">    minSdkVersion               = <span class="number">16</span></span><br><span class="line">    targetSdkVersion            = <span class="number">27</span></span><br><span class="line">    compileSdkVersion           = <span class="number">27</span></span><br><span class="line">    buildToolsVersion           = <span class="string">'27.1.1'</span></span><br><span class="line"></span><br><span class="line">    supportLibraryVersion       = <span class="string">'27.1.1'</span></span><br><span class="line">    xmvpVersion                 = <span class="string">'1.2.2'</span></span><br><span class="line">    retrofit2Version            = <span class="string">'2.3.0'</span></span><br><span class="line">    okhttp3Version              = <span class="string">'3.8.1'</span></span><br><span class="line">    butterknifeVersion          = <span class="string">'8.6.0'</span></span><br><span class="line">    rx2Version                  = <span class="string">'2.0.2'</span></span><br><span class="line">    CircleProgressDialogVersion = <span class="string">'1.0.2'</span></span><br><span class="line">    smarttabVersion             = <span class="string">'1.6.1@aar'</span></span><br><span class="line">    adapterHelperVersion        = <span class="string">'2.9.41'</span></span><br><span class="line">    glideVersion                = <span class="string">'4.7.1'</span></span><br><span class="line">    roundedimageviewVersion     = <span class="string">'2.3.0'</span></span><br><span class="line">    eventbusVersion             = <span class="string">'3.0.0'</span></span><br><span class="line">    dispatcherVersion           = <span class="string">'2.4.0'</span></span><br><span class="line">    picture_libraryVersion      = <span class="string">'v2.2.3'</span></span><br><span class="line">    statusbarutilVersion        = <span class="string">'1.5.1'</span></span><br><span class="line">    okhttpUtilsVersion          = <span class="string">'3.8.0'</span></span><br><span class="line">    constraintVersion           = <span class="string">'1.1.3'</span></span><br><span class="line">    flexboxVersion              = <span class="string">'1.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p>app目录下的<code>build.gradle</code></p><figure class="highlight groovy"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'save.state'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">def</span> releaseTime() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyy-MM-dd-HH.mm"</span>, TimeZone.getTimeZone(<span class="string">"GMT+8"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.compileSdkVersion</span><br><span class="line"><span class="comment">//    buildToolsVersion rootProject.buildToolsVersion</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion rootProject.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.targetSdkVersion</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">        multiDexEnabled <span class="literal">true</span></span><br><span class="line">        <span class="comment">// config the JSON processing library</span></span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [ <span class="string">serializer :</span> <span class="string">"gson"</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters <span class="string">"armeabi-v7a"</span></span><br><span class="line">        &#125;</span><br><span class="line">        renderscriptTargetApi <span class="number">25</span></span><br><span class="line">        renderscriptSupportModeEnabled <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        userquhuaRelease &#123;</span><br><span class="line">            storeFile file(<span class="string">"../key/xxx.keystore"</span>)</span><br><span class="line">            storePassword <span class="string">"xxxxxx"</span></span><br><span class="line">            keyAlias <span class="string">"xxx"</span></span><br><span class="line">            keyPassword <span class="string">"xxxxxx"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quhuaRelease &#123;</span><br><span class="line">            storeFile file(<span class="string">"../key/xxx.keystore"</span>)</span><br><span class="line">            storePassword <span class="string">"xxxxxxx"</span></span><br><span class="line">            keyAlias <span class="string">"xxx"</span></span><br><span class="line">            keyPassword <span class="string">"xxxxxxx"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cuntubaRelease &#123;</span><br><span class="line">            storeFile file(<span class="string">"../key/xxx.keystore"</span>)</span><br><span class="line">            storePassword <span class="string">"xxxxxxx"</span></span><br><span class="line">            keyAlias <span class="string">"xxx"</span></span><br><span class="line">            keyPassword <span class="string">"xxxxxxx"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xemhRelease &#123;</span><br><span class="line">            storeFile file(<span class="string">"../key/xxx.keystore"</span>)</span><br><span class="line">            storePassword <span class="string">"xxxxxxx"</span></span><br><span class="line">            keyAlias <span class="string">"xxx"</span></span><br><span class="line">            keyPassword <span class="string">"xxxxxxx"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flavorDimensions <span class="string">"default"</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        userquhua &#123;</span><br><span class="line">            applicationId <span class="string">"com.xxx.xx"</span></span><br><span class="line">            versionCode <span class="number">22</span></span><br><span class="line">            versionName <span class="string">"1.7.5"</span></span><br><span class="line">            signingConfig = signingConfigs.userquhuaRelease</span><br><span class="line"></span><br><span class="line">            String qq_id = <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"QQ_ID"</span>, qq_id <span class="comment">// qq appId</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,         <span class="string">"SINA_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 新浪appId</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"WX_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 微信 appId</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"UM_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 友盟</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,       <span class="string">"WX_SECRET"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 微信 secret</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,   <span class="string">"SINA_REDIRECT"</span>, <span class="string">'"http://open.weibo.com/apps/xxxxxx/privilege/oauth"'</span> <span class="comment">// 新浪</span></span><br><span class="line"></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,   <span class="string">"ADHUB_INIT_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 广告sdk初始化id</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"ADHUB_SPLASH_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 开屏广告id</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"ADHUB_BANNER_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// banner广告id</span></span><br><span class="line"></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,      <span class="string">"SERVER_URL"</span>, <span class="string">'"http://xxx.xxx.com/"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,        <span class="string">"LOGO_URL"</span>, <span class="string">'"http://file.xxx.com/img/xxx.png"'</span></span><br><span class="line"></span><br><span class="line">            manifestPlaceholders = [</span><br><span class="line"><span class="symbol">                    qq_id:</span> qq_id,</span><br><span class="line">                    <span class="string">JPUSH_PKGNAME :</span> applicationId,</span><br><span class="line">                    <span class="string">JPUSH_APPKEY :</span> <span class="string">"xxxxxx"</span>, <span class="comment">//JPush 上注册的包名对应的 Appkey.</span></span><br><span class="line">                    <span class="string">JPUSH_CHANNEL :</span> <span class="string">"developer-default"</span>, <span class="comment">//暂时填写默认值即可.</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quhua &#123;</span><br><span class="line">            applicationId <span class="string">"com.xxx.xx"</span></span><br><span class="line">            versionCode <span class="number">1</span></span><br><span class="line">            versionName <span class="string">"1.0.0"</span></span><br><span class="line">            signingConfig = signingConfigs.quhuaRelease</span><br><span class="line"></span><br><span class="line">            String qq_id = <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"QQ_ID"</span>, qq_id</span><br><span class="line">            buildConfigField <span class="string">"String"</span>,         <span class="string">"SINA_ID"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"WX_ID"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"UM_ID"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,       <span class="string">"WX_SECRET"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,   <span class="string">"SINA_REDIRECT"</span>, <span class="string">'"http://open.weibo.com/apps/xxxxxx/privilege/oauth"'</span></span><br><span class="line"></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,   <span class="string">"ADHUB_INIT_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 广告sdk初始化id</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"ADHUB_SPLASH_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 开屏广告id</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"ADHUB_BANNER_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// banner广告id</span></span><br><span class="line"></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,      <span class="string">"SERVER_URL"</span>, <span class="string">'"http://xx.xxx.com/"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,        <span class="string">"LOGO_URL"</span>, <span class="string">'"http://file.xxx.com/img/xxx.png"'</span></span><br><span class="line"></span><br><span class="line">            manifestPlaceholders = [</span><br><span class="line"><span class="symbol">                    qq_id:</span> qq_id,</span><br><span class="line">                    <span class="string">JPUSH_PKGNAME :</span> applicationId,</span><br><span class="line">                    <span class="string">JPUSH_APPKEY :</span> <span class="string">"xxxxxx"</span>, <span class="comment">//JPush 上注册的包名对应的 Appkey.</span></span><br><span class="line">                    <span class="string">JPUSH_CHANNEL :</span> <span class="string">"developer-default"</span>, <span class="comment">//暂时填写默认值即可.</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cuntuba &#123;</span><br><span class="line">            applicationId <span class="string">"com.xxx.xx"</span></span><br><span class="line">            versionCode <span class="number">1</span></span><br><span class="line">            versionName <span class="string">"1.0.0"</span></span><br><span class="line">            signingConfig = signingConfigs.cuntubaRelease</span><br><span class="line"></span><br><span class="line">            String qq_id = <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"QQ_ID"</span>, qq_id</span><br><span class="line">            buildConfigField <span class="string">"String"</span>,         <span class="string">"SINA_ID"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"WX_ID"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"UM_ID"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,       <span class="string">"WX_SECRET"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,   <span class="string">"SINA_REDIRECT"</span>, <span class="string">'"http://open.weibo.com/apps/xxxxxx/privilege/oauth"'</span></span><br><span class="line"></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,   <span class="string">"ADHUB_INIT_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 广告sdk初始化id</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"ADHUB_SPLASH_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 开屏广告id</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"ADHUB_BANNER_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// banner广告id</span></span><br><span class="line"></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,      <span class="string">"SERVER_URL"</span>, <span class="string">'"http://xxx.xxxx.com/"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,        <span class="string">"LOGO_URL"</span>, <span class="string">'"http://file.xxx.com/img/xxx.png"'</span></span><br><span class="line"></span><br><span class="line">            manifestPlaceholders = [</span><br><span class="line"><span class="symbol">                    qq_id:</span> qq_id,</span><br><span class="line">                    <span class="string">JPUSH_PKGNAME :</span> applicationId,</span><br><span class="line">                    <span class="string">JPUSH_APPKEY :</span> <span class="string">"xxxxxx"</span>, <span class="comment">//JPush 上注册的包名对应的 Appkey.</span></span><br><span class="line">                    <span class="string">JPUSH_CHANNEL :</span> <span class="string">"developer-default"</span>, <span class="comment">//暂时填写默认值即可.</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xemh &#123;</span><br><span class="line">            applicationId <span class="string">"com.xxx.xx"</span></span><br><span class="line">            versionCode <span class="number">1</span></span><br><span class="line">            versionName <span class="string">"1.0.0"</span></span><br><span class="line">            signingConfig = signingConfigs.xemhRelease</span><br><span class="line"></span><br><span class="line">            String qq_id = <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"QQ_ID"</span>, qq_id</span><br><span class="line">            buildConfigField <span class="string">"String"</span>,         <span class="string">"SINA_ID"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"WX_ID"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,           <span class="string">"UM_ID"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,       <span class="string">"WX_SECRET"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,   <span class="string">"SINA_REDIRECT"</span>, <span class="string">'"xxxxxx"'</span></span><br><span class="line"></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,   <span class="string">"ADHUB_INIT_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 广告sdk初始化id</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"ADHUB_SPLASH_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// 开屏广告id</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>, <span class="string">"ADHUB_BANNER_ID"</span>, <span class="string">'"xxxxxx"'</span> <span class="comment">// banner广告id</span></span><br><span class="line"></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,      <span class="string">"SERVER_URL"</span>, <span class="string">'"http://xx.xxx.com/"'</span></span><br><span class="line">            buildConfigField <span class="string">"String"</span>,        <span class="string">"LOGO_URL"</span>, <span class="string">'"http://file.xxxxxx.com/img/xxxxxx.png"'</span></span><br><span class="line"></span><br><span class="line">            manifestPlaceholders = [</span><br><span class="line"><span class="symbol">                    qq_id:</span> qq_id,</span><br><span class="line">                    <span class="string">JPUSH_PKGNAME :</span> applicationId,</span><br><span class="line">                    <span class="string">JPUSH_APPKEY :</span> <span class="string">"xxxxxx"</span>, <span class="comment">//JPush 上注册的包名对应的 Appkey.</span></span><br><span class="line">                    <span class="string">JPUSH_CHANNEL :</span> <span class="string">"developer-default"</span>, <span class="comment">//暂时填写默认值即可.</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    applicationVariants.all &#123;</span><br><span class="line">        variant -&gt;</span><br><span class="line">            variant.outputs.all &#123;</span><br><span class="line">                outputFileName = <span class="string">"$&#123;variant.productFlavors[0].name&#125;-v$&#123;variant.productFlavors[0].versionName&#125;-$&#123;releaseTime()&#125;.apk"</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 不显示Log</span></span><br><span class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span></span><br><span class="line">            signingConfig <span class="literal">null</span></span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            zipAlignEnabled <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 移除无用的resource文件</span></span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// 显示Log</span></span><br><span class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"true"</span></span><br><span class="line">            signingConfig <span class="literal">null</span></span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            zipAlignEnabled <span class="literal">false</span></span><br><span class="line">            shrinkResources <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    packagingOptions &#123;</span><br><span class="line">        exclude <span class="string">'META-INF/DEPENDENCIES.txt'</span></span><br><span class="line">        exclude <span class="string">'META-INF/NOTICE'</span></span><br><span class="line">        exclude <span class="string">'META-INF/NOTICE.txt'</span></span><br><span class="line">        exclude <span class="string">'META-INF/LICENSE'</span></span><br><span class="line">        exclude <span class="string">'META-INF/LICENSE.txt'</span></span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dexOptions &#123;</span><br><span class="line"></span><br><span class="line">        javaMaxHeapSize <span class="string">"4g"</span> <span class="comment">//此处可根据电脑本身配置 数值越大 当然越快</span></span><br><span class="line"></span><br><span class="line">        preDexLibraries = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    flatDir &#123;</span><br><span class="line">        dirs <span class="string">'libs'</span>, <span class="string">'../adpoymer/libs'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">include:</span> [<span class="string">'*.jar'</span>], <span class="string">dir:</span> <span class="string">'libs'</span>)</span><br><span class="line">    implementation <span class="string">"com.android.support:appcompat-v7:$supportLibraryVersion"</span></span><br><span class="line">    implementation <span class="string">"com.android.support:recyclerview-v7:$supportLibraryVersion"</span></span><br><span class="line">    implementation <span class="string">"com.android.support:support-v4:$supportLibraryVersion"</span></span><br><span class="line">    implementation <span class="string">"com.android.support:design:$supportLibraryVersion"</span></span><br><span class="line">    implementation <span class="string">"com.android.support.constraint:constraint-layout:$constraintVersion"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加retrofit2 的依赖 添加这个依赖就默认添加了okhttp依赖</span></span><br><span class="line">    compile <span class="string">"com.squareup.retrofit2:retrofit:$retrofit2Version"</span></span><br><span class="line">    compile <span class="string">"com.squareup.retrofit2:converter-gson:$retrofit2Version"</span></span><br><span class="line">    compile <span class="string">"com.squareup.retrofit2:adapter-rxjava2:$retrofit2Version"</span></span><br><span class="line">    compile <span class="string">"com.squareup.okhttp3:logging-interceptor:$okhttp3Version"</span></span><br><span class="line">    compile <span class="string">"com.jakewharton:butterknife:$butterknifeVersion"</span></span><br><span class="line">    annotationProcessor <span class="string">"com.jakewharton:butterknife-compiler:$butterknifeVersion"</span></span><br><span class="line">    compile <span class="string">"io.reactivex.rxjava2:rxandroid:$rx2Version"</span></span><br><span class="line">    compile <span class="string">"com.github.xujiaji:xmvp:$xmvpVersion"</span></span><br><span class="line">    implementation <span class="string">"com.github.autume:CircleProgressDialog:$CircleProgressDialogVersion"</span></span><br><span class="line">    compile <span class="string">"com.ogaclejapan.smarttablayout:library:$smarttabVersion"</span></span><br><span class="line">    compile <span class="string">"com.github.CymChad:BaseRecyclerViewAdapterHelper:$adapterHelperVersion"</span></span><br><span class="line"></span><br><span class="line">    compile <span class="string">"com.github.bumptech.glide:glide:$glideVersion"</span></span><br><span class="line">    annotationProcessor <span class="string">"com.github.bumptech.glide:compiler:$glideVersion"</span></span><br><span class="line"></span><br><span class="line">    compile <span class="string">"com.makeramen:roundedimageview:$roundedimageviewVersion"</span></span><br><span class="line">    compile <span class="string">"org.greenrobot:eventbus:$eventbusVersion"</span></span><br><span class="line">    annotationProcessor <span class="string">"com.github.hotchemi:permissionsdispatcher-processor:$dispatcherVersion"</span></span><br><span class="line">    compile <span class="string">"com.jaeger.statusbarutil:library:$statusbarutilVersion"</span></span><br><span class="line">    compile(<span class="string">"com.github.hotchemi:permissionsdispatcher:$dispatcherVersion"</span>) &#123;</span><br><span class="line">        exclude <span class="string">module:</span> <span class="string">"support-v13"</span></span><br><span class="line">    &#125;</span><br><span class="line">    implementation <span class="string">"com.github.LuckSiege.PictureSelector:picture_library:$picture_libraryVersion"</span></span><br><span class="line">    implementation <span class="string">'me.drakeet.library:crashwoodpecker:2.1.1'</span></span><br><span class="line">    implementation <span class="string">'com.github.chenupt.android:springindicator:1.0.2@aar'</span></span><br><span class="line">    debugImplementation <span class="string">'com.amitshekhar.android:debug-db:1.0.4'</span></span><br><span class="line">    implementation <span class="string">'com.umeng.sdk:common:1.5.3'</span></span><br><span class="line">    implementation <span class="string">'com.umeng.sdk:analytics:7.5.3'</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'com.liulishuo.filedownloader:library:1.7.5'</span></span><br><span class="line"></span><br><span class="line">    implementation project(<span class="string">':banner'</span>)</span><br><span class="line">    implementation project(<span class="string">':xdialog'</span>)</span><br><span class="line">    implementation project(<span class="string">':shareutil'</span>)</span><br><span class="line">    implementation project(<span class="string">':update'</span>)</span><br><span class="line">    implementation project(<span class="string">':pay'</span>)</span><br><span class="line"><span class="comment">//    implementation project(':adhub')</span></span><br><span class="line">    implementation project(<span class="string">':imagewatcher'</span>)</span><br><span class="line">    implementation files(<span class="string">'libs/lite-orm-1.9.2.jar'</span>)</span><br><span class="line">    implementation <span class="string">'jp.wasabeef:blurry:2.1.1'</span></span><br><span class="line">    implementation <span class="string">"com.google.android:flexbox:$flexboxVersion"</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'cn.jiguang.sdk:jpush:3.1.6'</span>  <span class="comment">// 此处以JPush 3.1.6 版本为例。</span></span><br><span class="line">    implementation <span class="string">'cn.jiguang.sdk:jcore:1.2.5'</span>  <span class="comment">// 此处以JCore 1.2.5 版本为例。</span></span><br><span class="line"></span><br><span class="line">    compile(<span class="string">name:</span> <span class="string">'sdk-release'</span>, <span class="string">ext:</span> <span class="string">'aar'</span>)</span><br><span class="line">    compile(<span class="string">name:</span> <span class="string">'open_ad_sdk'</span>, <span class="string">ext:</span> <span class="string">'aar'</span>)</span><br><span class="line">    compile(<span class="string">name:</span> <span class="string">'adpoymer-3.4.35'</span>, <span class="string">ext:</span> <span class="string">'aar'</span>)</span><br><span class="line">    implementation <span class="string">'pl.droidsonroids.gif:android-gif-drawable:1.0.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ol><h2 id="Demo-地址">Demo 地址<a href="post/android-project-one-for-more#Demo-地址"></a></h2><p><a href="https://github.com/xujiaji/OneForAllApk" target="_blank" rel="noopener">https://github.com/xujiaji/OneForAllApk</a></p><h2 id="结束">结束<a href="post/android-project-one-for-more#结束"></a></h2><p>就这样就可以解放大量劳动力啦！每次项目打包各种软件，选一下就ojbk，哈哈哈~<br>如果有些配置在其他渠道没有的，也可通过BuildConfig在java中判断如果是某某渠道那么屏蔽。<br>over</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;简介&lt;a href=&quot;post/android-project-one-for-more#简介&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;如题所示！本篇文章就是为了解决这种问题。方便打包和运行的时候能做到无需手动替换配置，即可打包想要的apk。打包的时候，只需选一下想打哪
      
    
    </summary>
    
      <category term="Android" scheme="https://blog.xujiaji.com/categories/Android/"/>
    
    
      <category term="Android" scheme="https://blog.xujiaji.com/tags/Android/"/>
    
      <category term="项目配置" scheme="https://blog.xujiaji.com/tags/%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>XMVP：一个通过泛型实现的MVP框架2年的演化路</title>
    <link href="https://blog.xujiaji.com/post/xmvp-framework/index.html"/>
    <id>https://blog.xujiaji.com/post/xmvp-framework/index.html</id>
    <published>2018-09-21T10:22:15.000Z</published>
    <updated>2019-04-08T06:57:05.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>XMVP框架是我的第一个框架，刚从Android起步第一次了解MVP模式时决心写一个自己的东西框架，到现在已运用在我写的多个项目中。虽然两年了，但核心的思路没有改变，到现在变换也不是太多，精简了一些代码，添加了一些功能。</p></blockquote><a id="more"></a><h2 id="起步2016">起步2016<a href="post/xmvp-framework#起步2016"></a></h2><p>这是个刚出社会找工作痛苦的时期，我个人不太喜欢生活中麻烦的事情。安静是我的本性，于是想写个属于自己的框架，为未来做些铺垫。于是，便有了XMVP，名字“X”是臭不要脸的加上了自己名字的开头字母。</p><h4 id="目标">目标<a href="post/xmvp-framework#目标"></a></h4><p><strong>该框架的目标很简单，为了省掉View、Model、Presenter层之间的依赖实现过程，通过简单的配置，框架自动实现依赖关系</strong></p><p>实现的原理：获取配置的泛型类型，通过反射实例化P层和M层。</p><h4 id="代码">代码<a href="post/xmvp-framework#代码"></a></h4><p><strong>1.</strong> 关键能让我开始做这个框架的核心代码如下：</p><blockquote><p>传入对象的Class和需要过滤泛型得的匹配的对象，然后遍历<code>klass</code>中配置的泛型判断是不是<code>filterClass</code>的子类，如果是则找到了配置的泛型类型。</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Class&lt;T&gt; <span class="title">getGenericClass</span><span class="params">(Class&lt;?&gt; klass, Class&lt;?&gt; filterClass)</span> </span>&#123;</span><br><span class="line">    Type type = klass.getGenericSuperclass(); <span class="comment">// 获取父类Class类型，它包含了所配置的泛型类型</span></span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span> || !(type <span class="keyword">instanceof</span> ParameterizedType)) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 判断是否是泛型类型</span></span><br><span class="line">    ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">    Type[] types = parameterizedType.getActualTypeArguments(); <span class="comment">// 由于一个类可能不止配置了一个泛型，获取该对象所有泛型类型</span></span><br><span class="line">    <span class="keyword">for</span> (Type t : types) &#123;</span><br><span class="line">        Class&lt;T&gt; tClass = (Class&lt;T&gt;) t;</span><br><span class="line">        <span class="keyword">if</span> (filterClass.isAssignableFrom(tClass)) &#123; <span class="comment">// 通过filterClass找到需要的目标类型</span></span><br><span class="line">            <span class="keyword">return</span> tClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>2.</strong> 使用也非常简单，精简代码如下所示，4步配置就实现了MVP</p><ul><li>首先定义契约（Contract），定义View、Model、Presenter的接口，并且都需要继承自<code>XContract</code></li><li>创建Model实现类</li><li>创建Presenter实现类继承<code>XBasePresenter</code>，泛型中关联View接口和Model实现类</li><li>创建View实现类继承<code>XBaseActivity</code>或其子类，泛型中关联Presenter实现类</li></ul><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 契约</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HomeContract</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">XContract</span>.<span class="title">Presenter</span></span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">XContract</span>.<span class="title">View</span></span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Model</span> <span class="keyword">extends</span> <span class="title">XContract</span>.<span class="title">Model</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// M层实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeModel</span> <span class="keyword">implements</span> <span class="title">HomeContract</span>.<span class="title">Model</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P层实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomePresenter</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">XBasePresenter</span>&lt;<span class="title">HomeContract</span>.<span class="title">View</span>, <span class="title">HomeModel</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">HomeContract</span>.<span class="title">Presenter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V层实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeActivity</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">XBaseActivity</span>&lt;<span class="title">HomePresenter</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">HomeContract</span>.<span class="title">View</span> </span>&#123;&#125;</span><br></pre></td></tr></table></div></figure><p><strong>3.</strong> 最初XMVP框架做出时写的一篇文章 <a href="https://www.jianshu.com/p/7c71c0d6c150" target="_blank" rel="noopener">封了一个Android MVP框架，就叫XMVP吧！</a></p><hr><blockquote><p>就这样，第一阶段宣告完毕，然后就是优化和修复一些bug，当然上面的<code>getGenericClass</code>这个方法也是后期优化过的结果。</p></blockquote><h2 id="想偷懒了就开发了MVPManager插件，快速生成XMVP代码">想偷懒了就开发了<code>MVPManager</code>插件，快速生成<code>XMVP</code>代码<a href="post/xmvp-framework#想偷懒了就开发了MVPManager插件，快速生成XMVP代码"></a></h2><p><img src="https://raw.githubusercontent.com/xujiaji/MVPManager/master/display/banner.png" alt=""><br>也就是<code>XMVP</code>框架开发出来也就1个月之内的事情吧！这时感觉写契约（Contract），写<code>XMVP</code>各个实现类，都是重复的劳动力，每一个新的界面就得去创建这么些文件太过辛苦。结果虽然变得有条理有模块，但是工作量有些重复和增加，有些时候配置泛型忘了还需要看之前是怎么配置的。</p><p>当时其实也有创建MVP文件的插件之类的东西，但是不符合<code>XMVP</code>的实情，泛型还是得自己动手，于是决心自己写一个<code>intellij</code>插件，当然在<code>AS</code>中也能使用。</p><h4 id="创建MVP代码截图，这是最新的创建代码界面的截图">创建MVP代码截图，这是最新的创建代码界面的截图<a href="post/xmvp-framework#创建MVP代码截图，这是最新的创建代码界面的截图"></a></h4><blockquote><p>在1.0的基础上，增加了可将同一个模块放一个包中或将MVP分在对应的包中的选项；增加了可以不是XMVP框架的情况下使用</p></blockquote><p><img src="https://github.com/xujiaji/MVPManager/raw/master/display/update_2_0_0.png" alt="" class="article-img"></p><h4 id="这是一张动态图，是一张旧版本的演示图。只需要和上面的截图结合来看一下哦">这是一张动态图，是一张旧版本的演示图。只需要和上面的截图结合来看一下哦<a href="post/xmvp-framework#这是一张动态图，是一张旧版本的演示图。只需要和上面的截图结合来看一下哦"></a></h4><p><img src="https://github.com/xujiaji/MVPManager/raw/master/display/edit_MVPManager.gif" alt="" class="article-img"></p><h4 id="最后还有个逆向增加或删除XMVP契约中定义方法的功能">最后还有个逆向增加或删除XMVP契约中定义方法的功能<a href="post/xmvp-framework#最后还有个逆向增加或删除XMVP契约中定义方法的功能"></a></h4><blockquote><p>会同时更新实现类的方法，本人是写出这个功能，但几乎不用的啦</p></blockquote><p><img src="https://github.com/xujiaji/MVPManager/raw/master/display/open_change_MVPManager.gif" alt="" class="article-img"></p><h4 id="刚刚开发出来MVPManager的时候，我也写了篇文章介绍-这个AS插件能帮你快速管理MVP">刚刚开发出来MVPManager的时候，我也写了篇文章介绍 <a href="https://www.jianshu.com/p/5d528019a76b" target="_blank" rel="noopener">这个AS插件能帮你快速管理MVP</a><a href="post/xmvp-framework#刚刚开发出来MVPManager的时候，我也写了篇文章介绍-这个AS插件能帮你快速管理MVP"></a></h4><hr><blockquote><p>就这样，第二阶段结束了。其主要目的就是为了解决MVP重复逻辑的代码量问题</p></blockquote><h2 id="实践中的更新">实践中的更新<a href="post/xmvp-framework#实践中的更新"></a></h2><p>在不断的实践运用中也发现了很多没有考虑到或者忽略的问题，其中最映像深刻的不过于有次上线应用的时候，混淆居然会导致无法创建Presenter熬夜找了很久。</p><p>还有就是忽略了Fragment有app包和v4包两个地方，框架中只写了一个，考虑的都比较片面。</p><p>只有在实践中才能真正的考验，一直以来大概就我和少数的小伙伴在使用。虽然用的比较少，但是写出来后就要对它负责嘛！</p><h4 id="使用中的一些个人技巧">使用中的一些个人技巧<a href="post/xmvp-framework#使用中的一些个人技巧"></a></h4><p><strong>1.</strong> 很多时候，Activity和Presenter，更或者Model都有共用的地方，此时我们需要作出提取抽象。于是我们就需要继承<code>XBaseActivity</code>、<code>XBaseFragment</code>、<code>XBasePresenter</code>再做一层抽象，这样如果以后不想用<code>XMVP</code>框架有更好的选择也更好替换哈。如下所示：</p><blockquote><p>BaseActivity.java</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">XBasePresenter</span>&gt; <span class="keyword">extends</span> <span class="title">XBaseActivity</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInitCircle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onInitCircle();</span><br><span class="line">    ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>BasePresenter.java</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasePresenter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">XContract</span>.<span class="title">View</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">XContract</span>.<span class="title">Model</span>&gt; <span class="keyword">extends</span> <span class="title">XBasePresenter</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> CompositeDisposable mCompositeDisposable;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.end();</span><br><span class="line">        <span class="keyword">if</span> (mCompositeDisposable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCompositeDisposable.clear();</span><br><span class="line">            mCompositeDisposable = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>向上面这样，我们通过一个中间层，处理一些我们需要统一调用的或处理的一些东西</p><p><strong>2.</strong> 对于Presenter回调Model处理后返回的数据监听，我们可以定义一个通用监听接口，如下：</p><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">int</span> code, String err)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>并且，我们可以对这个接口进行实现，我们可以统一对错误信息做些提示或处理</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericListenerImp</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">GenericListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GenericListenerImp</span><span class="params">(<span class="comment">/*可以传入进来base view或base presenter，如果有错误可以调用对应方法统一处理*/</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">int</span> code, String err)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对错误做出统一处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>3.</strong> 我们最常用的就是刷新加载列表了，几乎所有app中都需要，并且在同一个应用中的加载逻辑都是一样的，于是我们可以将其抽象出来，使用的时候会非常方便。</p><blockquote><p>首先定义一个基础刷新契约，每一个有刷新的view的接口都直接从这里继承</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseRefreshContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">XContract</span>.<span class="title">Presenter</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">requestLoadListData</span><span class="params">(<span class="keyword">int</span> page)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求更新列表数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">requestUpdateListData</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> &lt;<span class="title">X</span>&gt; <span class="keyword">extends</span> <span class="title">XContract</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新列表成功</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">updateListSuccess</span><span class="params">(List&lt;X&gt; datas, <span class="keyword">boolean</span> isEnd)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新失败</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">updateListFail</span><span class="params">(String err)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 加载数据成功</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadListDataSuccess</span><span class="params">(List&lt;X&gt; datas, <span class="keyword">int</span> currentPage, <span class="keyword">boolean</span> isEnd)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 加载数据失败</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> err</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadListDataFail</span><span class="params">(String err)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数据已经被加载完</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadListDateOver</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>然后抽象View，这里以Activity为例，Fragment一致。我使用了<code>SwipeRefreshLayout</code>作为刷新，<code>BaseRecyclerViewAdapterHelper</code>处理填充数据和加载数据</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRefreshActivity</span>&lt;<span class="title">E</span> ,<span class="title">X</span> <span class="keyword">extends</span> <span class="title">BaseQuickAdapter</span>&lt;<span class="title">E</span>, <span class="title">BaseViewHolder</span>&gt;, <span class="title">T</span> <span class="keyword">extends</span> <span class="title">XBasePresenter</span>&gt; <span class="keyword">extends</span> <span class="title">BaseActivity</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">BaseRefreshContract</span>.<span class="title">View</span>&lt;<span class="title">E</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">BaseQuickAdapter</span>.<span class="title">RequestLoadMoreListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SwipeRefreshLayout</span>.<span class="title">OnRefreshListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> currentPage;<span class="comment">//当前的页面</span></span><br><span class="line">    <span class="keyword">protected</span> X mAdapter;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">protected</span> SwipeRefreshLayout swipeLayout;</span><br><span class="line">    <span class="keyword">protected</span> RecyclerView mRecyclerView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInitCircle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onInitCircle();</span><br><span class="line">        mAdapter = getAdapter();</span><br><span class="line">        mRecyclerView = getRecyclerView();</span><br><span class="line">        swipeLayout = getSwipeLayout();</span><br><span class="line">        swipeLayout.setOnRefreshListener(<span class="keyword">this</span>);</span><br><span class="line">        mAdapter.setOnLoadMoreListener(<span class="keyword">this</span>, mRecyclerView);</span><br><span class="line">        mRecyclerView.setAdapter(mAdapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> X <span class="title">getAdapter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> SwipeRefreshLayout <span class="title">getSwipeLayout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> RecyclerView <span class="title">getRecyclerView</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新列表成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListSuccess</span><span class="params">(List&lt;E&gt; datas, <span class="keyword">boolean</span> isEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isEnd = isEnd;</span><br><span class="line">        currentPage = <span class="number">1</span>;</span><br><span class="line">        mAdapter.setNewData(datas);</span><br><span class="line">        swipeLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (isEnd) &#123;</span><br><span class="line">            loadListDateOver();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mAdapter.setEnableLoadMore(<span class="keyword">true</span>);</span><br><span class="line">            mAdapter.loadMoreComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListFail</span><span class="params">(String err)</span> </span>&#123;</span><br><span class="line">        swipeLayout.setRefreshing(<span class="keyword">false</span>);</span><br><span class="line">        mAdapter.setEnableLoadMore(<span class="keyword">true</span>);</span><br><span class="line">        ToastUtil.getInstance().showLongT(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载数据成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadListDataSuccess</span><span class="params">(List&lt;E&gt; datas, <span class="keyword">int</span> currentPage, <span class="keyword">boolean</span> isEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentPage = currentPage;</span><br><span class="line">        <span class="keyword">this</span>.isEnd = isEnd;</span><br><span class="line">        mAdapter.addData(datas);</span><br><span class="line">        swipeLayout.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        mAdapter.loadMoreComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载数据失败</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> err</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadListDataFail</span><span class="params">(String err)</span> </span>&#123;</span><br><span class="line">        swipeLayout.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        mAdapter.loadMoreFail();</span><br><span class="line">        ToastUtil.getInstance().showLongT(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据已经被加载完</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadListDateOver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mAdapter.loadMoreEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!swipeLayout.isRefreshing())</span><br><span class="line">        &#123;</span><br><span class="line">            swipeLayout.setRefreshing(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getPresenter().requestUpdateListData();</span><br><span class="line">        mAdapter.setEnableLoadMore(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadMoreRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEnd) &#123;</span><br><span class="line">            loadListDateOver();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swipeLayout.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        getPresenter().requestLoadListData(++currentPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> BaseRefreshContract.<span class="function">Presenter <span class="title">getPresenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (presenter <span class="keyword">instanceof</span> BaseRefreshContract.Presenter) &#123;</span><br><span class="line">            <span class="keyword">return</span>  (BaseRefreshContract.Presenter) presenter;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"presenter please extends BaseRefreshContract.Presenter"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>使用：定义一个列表页面的契约</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleDetailContract</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseRefreshContract</span>.<span class="title">View</span>&lt;<span class="title">CircleMsgEntity</span>.<span class="title">CommentBean</span>&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BaseRefreshContract</span>.<span class="title">Presenter</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Model</span> <span class="keyword">extends</span> <span class="title">XContract</span>.<span class="title">Model</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">catArticleDetails</span><span class="params">(<span class="keyword">int</span> articleId, <span class="keyword">int</span> page, CompositeDisposable cd, NetRequestListener&lt;Result&lt;CircleMsgEntity&gt;&gt; listener)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>使用：View实现层，由于这是一个公司项目中的类，省略的所有的无关代码<br><code>CircleMsgEntity.CommentBean</code> 是一个Adapter(ArticleCommentAdapter)填充的实体类<br><code>ArticleCommentAdapter</code> 是一个继承BaseRecyclerViewAdapterHelper框架中的<code>BaseQuickAdapter</code>的类，并且该类是这样的：<code>public class ArticleCommentAdapter extends BaseQuickAdapter&lt;CircleMsgEntity.CommentBean, BaseViewHolder&gt;</code> 必须保证Activity第一个泛型和Adapter的第一个泛型类型一致</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDetailActivity</span> <span class="keyword">extends</span> <span class="title">BaseRefreshActivity</span>&lt;<span class="title">CircleMsgEntity</span>.<span class="title">CommentBean</span>, <span class="title">ArticleCommentAdapter</span>, <span class="title">ArticleDetailPresenter</span>&gt; <span class="keyword">implements</span> <span class="title">ArticleDetailContract</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.recycler)</span><br><span class="line">    RecyclerView recycler;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.refresh)</span><br><span class="line">    SwipeRefreshLayout refresh;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInitCircle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onInitCircle();</span><br><span class="line">        onRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">layoutId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> R.layout.activity_article_detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ArticleCommentAdapter <span class="title">getAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArticleCommentAdapter(ArticleCommentAdapter.TYPE_NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SwipeRefreshLayout <span class="title">getSwipeLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refresh.setColorSchemeResources(R.color.yellow);</span><br><span class="line">        <span class="keyword">return</span> refresh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RecyclerView <span class="title">getRecyclerView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        recycler.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">return</span> recycler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>使用： Presenter实现层</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDetailPresenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span>&lt;<span class="title">ArticleDetailContract</span>.<span class="title">View</span>,<span class="title">ArticleDetailModel</span>&gt; <span class="keyword">implements</span> <span class="title">ArticleDetailContract</span>.<span class="title">Presenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">        mCompositeDisposable = <span class="keyword">new</span> CompositeDisposable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLoadListData</span><span class="params">(<span class="keyword">int</span> page)</span> </span>&#123;</span><br><span class="line">        model.catArticleDetails(view.getArticleId(), page, mCompositeDisposable, <span class="keyword">new</span> NetRequestListener&lt;Result&lt;CircleMsgEntity&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(Result&lt;CircleMsgEntity&gt; circleMsgEntityResult)</span> </span>&#123;</span><br><span class="line">                ResultListBean&lt;List&lt;CircleMsgEntity.CommentBean&gt;&gt; resultListBean = circleMsgEntityResult.getData().getCommentList();</span><br><span class="line">                view.loadListDataSuccess(resultListBean.getList(), resultListBean.getPage(), resultListBean.getPage() &gt;= resultListBean.getPagecount());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String err)</span> </span>&#123;</span><br><span class="line">                view.loadListDataFail(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestUpdateListData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        model.catArticleDetails(view.getArticleId(), <span class="number">1</span>, mCompositeDisposable, <span class="keyword">new</span> NetRequestListener&lt;Result&lt;CircleMsgEntity&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">(Result&lt;CircleMsgEntity&gt; circleMsgEntityResult)</span> </span>&#123;</span><br><span class="line">                ResultListBean&lt;List&lt;CircleMsgEntity.CommentBean&gt;&gt; resultListBean = circleMsgEntityResult.getData().getCommentList();</span><br><span class="line">                view.updateListSuccess(resultListBean.getList(), resultListBean.getPage() &gt;= resultListBean.getPagecount());</span><br><span class="line">                view.displayArticleDetail(circleMsgEntityResult.getData());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String err)</span> </span>&#123;</span><br><span class="line">                view.updateListFail(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>Model层，去请求列表数据</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleDetailModel</span> <span class="keyword">implements</span> <span class="title">ArticleDetailContract</span>.<span class="title">Model</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catArticleDetails</span><span class="params">(<span class="keyword">int</span> articleId, <span class="keyword">int</span> page, CompositeDisposable cd, NetRequestListener&lt;Result&lt;CircleMsgEntity&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">        Observer&lt;Result&lt;CircleMsgEntity&gt;&gt; observer = ModelHelper.getObserver(cd, listener, <span class="keyword">true</span>); <span class="comment">// 对rxjava返回的数据进行统一处理</span></span><br><span class="line">        Http.getInstance().getArticleDetails(articleId, page, observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这样，我们就可以不断的复用<code>BaseRefreshActivity</code>、<code>ArticleDetailContract</code>来让刷新加载统一，当然在您实际的使用过程中肯定还需要调整。这里只给我了我自己的一些思路和实现方式。</p><blockquote><p>如果我们需要其他的抽象时，只需要注意像刷新一样将泛型继承关系标准上就可以啦。如果Model也可以抽取出来，复用时只需要继承抽象出来的Model。</p></blockquote><h2 id="目前">目前<a href="post/xmvp-framework#目前"></a></h2><p>目前XMVP框架已更新到<code>1.2.2</code>，废弃了一些以前的方法（当然现在还能用）。添加了更多View层的辅助方法，为了偷个懒，就直接展示新增的方法代码啦！</p><blockquote><p>基本周期</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: xujiaji</span></span><br><span class="line"><span class="comment"> * created on: 2018/9/4 10:57</span></span><br><span class="line"><span class="comment"> * description: 定义View相关周期 &lt;br /&gt; Define View related Cycle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XViewCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 super &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(Bundle)&#125;之前被调用              &lt;br /&gt;  will be called before super class &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(Bundle)&#125; called</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onBeforeCreateCircle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 super &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(Bundle)&#125;之前被调用，并且有Bundle &lt;br /&gt;  will be called before super class &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(Bundle)&#125; called</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> savedInstanceState 该参数不可能为null                                  &lt;br /&gt; this parameter cannot be null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onBundleHandle</span><span class="params">(@NonNull Bundle savedInstanceState)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取布局的id                                &lt;br /&gt; get layout id</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> #onBeforeCreateCircle &#125;之后被调用 &lt;br /&gt; will be called after &#123;<span class="doctag">@link</span> #onBeforeCreateCircle &#125; called</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> xml布局id                         &lt;br /&gt; xml layout id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">layoutId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  在这里面进行初始化                    &lt;br /&gt; initialize here</span></span><br><span class="line"><span class="comment">     *  在 &#123;<span class="doctag">@link</span> #layoutId()&#125; 之后被调用   &lt;br /&gt; will be called after &#123;<span class="doctag">@link</span> #layoutId()&#125; called</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onInitCircle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里面写监听事件                       &lt;br /&gt; write listens event here</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> #onInitCircle()&#125; 之后被调用 &lt;br /&gt; will be called after &#123;<span class="doctag">@link</span> #onInitCircle()&#125; called</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onListenerCircle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>Activiy中</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: xujiaji</span></span><br><span class="line"><span class="comment"> * created on: 2018/9/11 15:05</span></span><br><span class="line"><span class="comment"> * description: 定义Activity View相关周期 &lt;br /&gt; Define Activity View related Cycle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XActivityCycle</span> <span class="keyword">extends</span> <span class="title">XViewCycle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理上个页面传递过来的数据 &lt;br /&gt; Handle the data passed from the previous page</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onIntentHandle</span><span class="params">(@NonNull Intent intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>Fragment中</p></blockquote><figure class="highlight java"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: xujiaji</span></span><br><span class="line"><span class="comment"> * created on: 2018/9/4 10:57</span></span><br><span class="line"><span class="comment"> * description: 定义Fragment View相关周期 &lt;br /&gt; Define Fragment View related Cycle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XFragViewCycle</span> <span class="keyword">extends</span> <span class="title">XViewCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理&#123;<span class="doctag">@link</span> Fragment#getArguments()&#125; 的值，如果有才会调用  &lt;br /&gt; Handle the value of &#123;<span class="doctag">@link</span> Fragment#getArguments()&#125; , if it is there, it will be called</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bundle</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onArgumentsHandle</span><span class="params">(@NonNull Bundle bundle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onVisible</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onInvisible</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLazyLoad</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 忽略&#123;<span class="doctag">@link</span> #isFirstLoad() &#125;的值，强制刷新数据，但仍要满足 &#123;<span class="doctag">@link</span> #isFragmentVisible()&#125; &amp;&amp; &#123;<span class="doctag">@link</span> #isPrepared()&#125; &lt;br /&gt;</span></span><br><span class="line"><span class="comment">     * Ignore the value of &#123;<span class="doctag">@link</span> #isFirstLoad() &#125; to force refresh data, but still satisfy &#123;<span class="doctag">@link</span> #isFragmentVisible()&#125; &amp;&amp; &#123;<span class="doctag">@link</span> #isPrepared()&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setForceLoad</span><span class="params">(<span class="keyword">boolean</span> forceLoad)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isForceLoad</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrepared</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isFirstLoad</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isFragmentVisible</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是在ViewPager中，默认为true</span></span><br><span class="line"><span class="comment">     * whether in ViewPager, default is true</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isInViewPager</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到Fragment中定义的方法是比较多的，因为由于懒加载比较常用，新增了懒加载。我们如果需要加载数据，可直接在<code>onLazyLoad()</code>方法中进行。</p><blockquote><p>需要注意：如果Fragment不是和ViewPager结合，需要将<code>isInViewPager</code>返回false，默认返回的true。如果不这样，可能会导致通过FragmentManger提交的Fragment无法调用到<code>onLazyLoad</code>方法。</p></blockquote><h2 id="最后">最后<a href="post/xmvp-framework#最后"></a></h2><p>通过写这个框架学到了思考很多东西，并且后期也会继续更新，我自己写项目中也在使用。可能有些地方考虑的不充足，谢谢大家也可以提建议。当然这只是MVP的一种实现思路，其他的还是有很多的，这里大家也许都有一定了解哈。</p><p>XMVP地址：<a href="https://github.com/xujiaji/XMVP" target="_blank" rel="noopener">https://github.com/xujiaji/XMVP</a></p><p>欢迎大家Star、Fork、PR (〃’▽’〃)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;XMVP框架是我的第一个框架，刚从Android起步第一次了解MVP模式时决心写一个自己的东西框架，到现在已运用在我写的多个项目中。虽然两年了，但核心的思路没有改变，到现在变换也不是太多，精简了一些代码，添加了一些功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://blog.xujiaji.com/categories/Android/"/>
    
    
      <category term="Android" scheme="https://blog.xujiaji.com/tags/Android/"/>
    
      <category term="Library" scheme="https://blog.xujiaji.com/tags/Library/"/>
    
  </entry>
  
  <entry>
    <title>iOS Objective-C Learn Note</title>
    <link href="https://blog.xujiaji.com/post/iOS-Objective-C-Learn/index.html"/>
    <id>https://blog.xujiaji.com/post/iOS-Objective-C-Learn/index.html</id>
    <published>2018-09-05T10:11:24.000Z</published>
    <updated>2018-11-02T07:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源代码文件扩展名对比">源代码文件扩展名对比<a href="post/iOS-Objective-C-Learn#源代码文件扩展名对比"></a></h2><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left"></th><th>头文件</th><th>实现文件</th></tr></thead><tbody><tr><td style="text-align:left">c语言</td><td>.h</td><td>.c</td></tr><tr><td style="text-align:left">c++语言</td><td>.h</td><td>.cpp</td></tr><tr><td style="text-align:left">oc语言</td><td>.h</td><td>.m</td></tr><tr><td style="text-align:left">oc&amp;c++</td><td>.h</td><td>.mm</td></tr></tbody></table></div></div><h2 id="类的定义">类的定义<a href="post/iOS-Objective-C-Learn#类的定义"></a></h2><blockquote><p>定义一个<code>SimpleClass</code>类</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SimpleClass</span>: <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><h2 id="类的属性申明">类的属性申明<a href="post/iOS-Objective-C-Learn#类的属性申明"></a></h2><blockquote><p>通过<code>@property</code></p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *firstName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *lastName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针类型，是一个对象</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSNumber</span> *yearOfBirth;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础类型，是一个值类型</span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> yearOfBirth;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个只读的属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *firstName;</span><br></pre></td></tr></table></div></figure><h2 id="减号方法和加号方法（本质就是一个函数）">减号方法和加号方法（本质就是一个函数）<a href="post/iOS-Objective-C-Learn#减号方法和加号方法（本质就是一个函数）"></a></h2><ol><li>减号方法（普通方法又称对象方法）</li><li>加号方法（类方法，又称静态方法）</li></ol><h2 id="完整的例子">完整的例子<a href="post/iOS-Objective-C-Learn#完整的例子"></a></h2><blockquote><p>接口<code>XYZPerson.h</code></p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XYZPerson</span>: <span class="title">NSObject</span></span></span><br><span class="line">-(<span class="keyword">void</span>)sayHello;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>实现<code>XYZPerson.m</code></p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"XYZPerson.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XYZPerson</span></span></span><br><span class="line">-(<span class="keyword">void</span>)sayHello &#123;</span><br><span class="line">  <span class="comment">// 加了@符号，表示是OC类型的字符串。不加表示是纯C语言的字符数组</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><h2 id="简单的程序">简单的程序<a href="post/iOS-Objective-C-Learn#简单的程序"></a></h2><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="基本数据类型">基本数据类型<a href="post/iOS-Objective-C-Learn#基本数据类型"></a></h2><div class="article-bounded"><div class="article-table"><table><thead><tr><th>类型</th><th style="text-align:right">进制位</th><th style="text-align:right">例子</th></tr></thead><tbody><tr><td>int</td><td style="text-align:right">32位</td><td style="text-align:right">int a = 0;</td></tr><tr><td>float</td><td style="text-align:right">32位</td><td style="text-align:right">float f = 1.0;</td></tr><tr><td>double</td><td style="text-align:right">64位</td><td style="text-align:right">double num;</td></tr><tr><td>char</td><td style="text-align:right">8位</td><td style="text-align:right">char c = ‘A’;</td></tr></tbody></table></div></div><h2 id="其他类型">其他类型<a href="post/iOS-Objective-C-Learn#其他类型"></a></h2><div class="article-bounded"><div class="article-table"><table><tbody><tr><td>NSString</td><td>@”hello world”</td></tr><tr><td>“hello world”</td><td>C语言字符串类型</td></tr></tbody></table></div></div><h2 id="限定词">限定词<a href="post/iOS-Objective-C-Learn#限定词"></a></h2><div class="article-bounded"><div class="article-table"><table><thead><tr><th>限定词</th><th style="text-align:right">例子</th><th>描述</th></tr></thead><tbody><tr><td>long</td><td style="text-align:right">long a;</td><td>//完整写法为：long int a;其实现在int已经32位了就相当于int a;</td></tr><tr><td>long long</td><td style="text-align:right">long long int a;</td><td></td></tr><tr><td>short</td><td style="text-align:right">short int a; short a;</td><td>// 16位整型</td></tr><tr><td>unsigned</td><td style="text-align:right">unsigned int a;</td><td>// 无符号</td></tr><tr><td>signed</td><td style="text-align:right">signed int a;</td><td>// 有符号</td></tr></tbody></table></div></div><h2 id="算术表达式与运算符">算术表达式与运算符<a href="post/iOS-Objective-C-Learn#算术表达式与运算符"></a></h2><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:right">名称</th><th style="text-align:left">表示</th></tr></thead><tbody><tr><td style="text-align:right">赋值</td><td style="text-align:left"><code>=</code></td></tr><tr><td style="text-align:right">一元运算符</td><td style="text-align:left"><code>++</code> <code>--</code></td></tr><tr><td style="text-align:right">二元运算符</td><td style="text-align:left"><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code></td></tr><tr><td style="text-align:right">三目运算符</td><td style="text-align:left">2 &gt; 3 <code>?</code> YES <code>:</code> NO</td></tr></tbody></table></div></div><h2 id="if语句（非0就是真）"><code>if</code>语句（非0就是真）<a href="post/iOS-Objective-C-Learn#if语句（非0就是真）"></a></h2><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:right"></th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:right">真</td><td style="text-align:left"><code>YES</code> <code>所有非0的值</code></td></tr><tr><td style="text-align:right">假</td><td style="text-align:left"><code>NO</code> <code>0</code></td></tr></tbody></table></div></div><blockquote><p>简单例子</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"这句话是真的"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"这句话是假的 %hhd"</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="goto-跳转语句，跳转的前面定义的标签处"><code>goto</code> 跳转语句，跳转的前面定义的标签处<a href="post/iOS-Objective-C-Learn#goto-跳转语句，跳转的前面定义的标签处"></a></h2><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义标签a</span></span><br><span class="line">    a:</span><br><span class="line">        i ++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i的值为%d"</span>, i);</span><br><span class="line"><span class="comment">//        if(i &lt; 5) goto a;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> a; <span class="comment">// 跳转到标签a</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> b; <span class="comment">// 跳转到标签b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"============"</span>); <span class="comment">// 由于上面直接跳转到了b标签，因此该语句得不到执行</span></span><br><span class="line"></span><br><span class="line">    b:&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"跳到b了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 2018-09-05 22:23:53.800654+0800 les1[971:104767] i的值为1</span></span><br><span class="line"><span class="comment">// 2018-09-05 22:23:53.800827+0800 les1[971:104767] i的值为2</span></span><br><span class="line"><span class="comment">// 2018-09-05 22:23:53.800858+0800 les1[971:104767] i的值为3</span></span><br><span class="line"><span class="comment">// 2018-09-05 22:23:53.800876+0800 les1[971:104767] i的值为4</span></span><br><span class="line"><span class="comment">// 2018-09-05 22:23:53.800889+0800 les1[971:104767] i的值为5</span></span><br><span class="line"><span class="comment">// 2018-09-05 22:23:53.800902+0800 les1[971:104767] 跳到b了</span></span><br></pre></td></tr></table></div></figure><h2 id="while-循环语句"><code>while</code> 循环语句<a href="post/iOS-Objective-C-Learn#while-循环语句"></a></h2><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Hello world! i = %d"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Hello world! i = 1</span></span><br><span class="line"><span class="comment">// Hello world! i = 2</span></span><br><span class="line"><span class="comment">// Hello world! i = 3</span></span><br><span class="line"><span class="comment">// Hello world! i = 4</span></span><br><span class="line"><span class="comment">// Hello world! i = 5</span></span><br></pre></td></tr></table></div></figure><h2 id="do-while-循环，至少执行一次"><code>do</code> <code>while</code> 循环，至少执行一次<a href="post/iOS-Objective-C-Learn#do-while-循环，至少执行一次"></a></h2><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"hello!"</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// hello!</span></span><br></pre></td></tr></table></div></figure><h2 id="for-循环"><code>for</code> 循环<a href="post/iOS-Objective-C-Learn#for-循环"></a></h2><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"i = %d"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// i = 1</span></span><br><span class="line"><span class="comment">// i = 2</span></span><br><span class="line"><span class="comment">// i = 3</span></span><br><span class="line"><span class="comment">// i = 4</span></span><br><span class="line"><span class="comment">// i = 5</span></span><br></pre></td></tr></table></div></figure><h2 id="循环控制break、continue">循环控制<code>break</code>、<code>continue</code><a href="post/iOS-Objective-C-Learn#循环控制break、continue"></a></h2><ul><li>break： 终止循环</li><li>continue: 跳过当前循环</li></ul><h2 id="switch分支语句"><code>switch</code>分支语句<a href="post/iOS-Objective-C-Learn#switch分支语句"></a></h2><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = 0"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = 1"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = 2"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"i = 3"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NO"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="函数的基本写法">函数的基本写法<a href="post/iOS-Objective-C-Learn#函数的基本写法"></a></h2><figure class="highlight c"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 求面积的函数</span></span><br><span class="line"><span class="comment"> * 传入值，计算并返回面积值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参无返回的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"this is a test!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@<span class="string">"value = %f"</span>, area(<span class="number">5.0</span>, <span class="number">3.0</span>));</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="main函数中的默认参数">main函数中的默认参数<a href="post/iOS-Objective-C-Learn#main函数中的默认参数"></a></h2><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"argc = %d"</span>, argc);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>终端运行</p></blockquote><figure class="highlight sh"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 56</span><br><span class="line">-rwxr-xr-x@ 1 username  staff  27984  9  5 23:21 les1</span><br><span class="line"></span><br><span class="line">$ ./les1</span><br><span class="line">2018-09-05 23:28:27.313 les1[1369:176584] argc = 1</span><br><span class="line">2018-09-05 23:28:27.313 les1[1369:176584] ./les1</span><br><span class="line"></span><br><span class="line">$ ./les1 -a -b -c</span><br><span class="line">2018-09-05 23:28:39.782 les1[1370:176617] argc = 4</span><br><span class="line">2018-09-05 23:28:39.782 les1[1370:176617] ./les1</span><br><span class="line">2018-09-05 23:28:39.782 les1[1370:176617] -a</span><br><span class="line">2018-09-05 23:28:39.782 les1[1370:176617] -b</span><br><span class="line">2018-09-05 23:28:39.782 les1[1370:176617] -c</span><br></pre></td></tr></table></div></figure><h2 id="创建类">创建类<a href="post/iOS-Objective-C-Learn#创建类"></a></h2><blockquote><p>头文件<code>People.h</code></p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">People</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>实现文件<code>People.m</code></p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"People.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">People</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><h2 id="实例化对象">实例化对象<a href="post/iOS-Objective-C-Learn#实例化对象"></a></h2><ol><li>导入类的头文件</li><li><code>[]</code>中写函数的调用</li><li><code>alloc</code> 函数为对象分配内存空间</li><li><code>init</code> 函数进行初始化操作</li></ol><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"People.h"</span> // 导入类头文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        <span class="comment">// [] 函数的调用</span></span><br><span class="line">        <span class="comment">// [类名 方法名]</span></span><br><span class="line">        <span class="comment">// [对象名 方法名]</span></span><br><span class="line">        <span class="comment">// alloc - 为对象分配内存空间</span></span><br><span class="line">        <span class="comment">// init - 进行初始化操作</span></span><br><span class="line">        People * p1 = [[People alloc] init];</span><br><span class="line">        People * p2 = [[People alloc] init];</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="属性和成员变量">属性和成员变量<a href="post/iOS-Objective-C-Learn#属性和成员变量"></a></h2><ol><li>类内使用成员变量、类外使用属性</li><li>定义成员变量，此时外部无法访问。如果要让外部可访问需要加上（不建议）：@public</li><li>属性是为了让类外可以访问成员变量</li><li>属性就是成员变量的外部接口</li><li>可将属性拆开，写成<code>get</code>和<code>set</code>两部分</li></ol><blockquote><p>People.h</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类内使用成员变量、类外使用属性</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">People</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义成员变量，此时外部无法访问。如果要让外部可访问需要加上：@public</span></span><br><span class="line">    <span class="comment">// @public</span></span><br><span class="line">    <span class="comment">// NSString * _peopleName; // 如果定义了该成员变量的属性，那么可以不写。编译器会为我们自动生成一个叫_peopleName的成员变量</span></span><br><span class="line">    <span class="keyword">int</span> _peopleAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 属性是为了让类外可以访问成员变量</span></span><br><span class="line"><span class="comment">// 属性就是成员变量的外部接口</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">NSString</span> * peopleName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性拆开</span></span><br><span class="line">- (<span class="keyword">void</span>) setAge:(<span class="keyword">int</span>) age;</span><br><span class="line">- (<span class="keyword">int</span>) getAge;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>People.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"People.h"</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> _peopleSex; <span class="comment">// 也可以将成员变量定义在m文件中，没什么区别</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">People</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _peopleName = <span class="string">@"张三"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) setAge:(<span class="keyword">int</span>) age</span><br><span class="line">&#123;</span><br><span class="line">    _peopleAge = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>) getAge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _peopleAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>main.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"People.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        People * p1 = [[People alloc] init];</span><br><span class="line">        p1.peopleName = <span class="string">@"李四"</span>; <span class="comment">// 通过属性设置名字</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"p1 name %@"</span>, [p1 peopleName]); <span class="comment">// 通过属性获取名字</span></span><br><span class="line">        [p1 setAge:<span class="number">23</span>]; <span class="comment">// 通过函数设置年龄</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"p1 age %d"</span>, [p1 getAge]); <span class="comment">// 通过函数获取年龄</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="函数">函数<a href="post/iOS-Objective-C-Learn#函数"></a></h2><ol><li>调用方法是用中括号</li><li><code>-</code>、<code>+</code> 方法的类型（减号代表对象方法，加号代表类方法）</li><li>加号方法和减号方法之间的相互调用逻辑和java一样</li><li>方法名：去掉方法类型和参数类型就是方法名</li><li><code>(int)</code> 返回值类型<code>int</code></li><li><code>:(int) x</code>     代表方法有参数，参数类型<code>int</code>，参数名<code>x</code></li></ol><blockquote><p>People.h</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">People</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 申明方法</span></span><br><span class="line"><span class="comment"> -、+ 方法的类型（减号代表对象方法，加号代表类方法）</span></span><br><span class="line"><span class="comment"> 加号方法和减号方法之间的相互调用逻辑和java一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(int) 返回值类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> :(int) x     代表方法有参数，参数类型int，参数名x</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 方法名：去掉方法类型和参数类型就是方法名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">int</span>) report;</span><br><span class="line">+ (<span class="keyword">void</span>) report1;</span><br><span class="line">- (<span class="keyword">int</span>) showWithA:(<span class="keyword">int</span>) a;</span><br><span class="line">- (<span class="keyword">int</span>) showWithA:(<span class="keyword">int</span>) a andB:(<span class="keyword">int</span>) b;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>People.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"People.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">People</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *_name1;</span><br><span class="line">- (<span class="keyword">int</span>)report</span><br><span class="line">&#123;</span><br><span class="line">    _name = <span class="string">@"abc"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-号方法:report"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)report1</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//     _name = @"abc"; 编译错误，+号方法相当于java中的静态方法</span></span><br><span class="line">    _name1 = <span class="string">@"abc"</span>;<span class="comment">//静态方法可调用静态变量</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"+号方法：report1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>) showWithA:(<span class="keyword">int</span>) a</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>) showWithA:(<span class="keyword">int</span>) a andB:(<span class="keyword">int</span>) b&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>main.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"People.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// [] 调用方法</span></span><br><span class="line">        People *p1 = [[People alloc] init];</span><br><span class="line"><span class="comment">//        NSLog(@"return value %d", [p1 report]);</span></span><br><span class="line"><span class="comment">//        [People report1];</span></span><br><span class="line">        <span class="keyword">int</span> a1 = [p1 showWithA:<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"a1 = %d"</span>, a1);</span><br><span class="line">        <span class="keyword">int</span> a2 = [p1 showWithA:<span class="number">10</span> andB:<span class="number">20</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"a2 = %d"</span>, a2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="初始化函数">初始化函数<a href="post/iOS-Objective-C-Learn#初始化函数"></a></h2><blockquote><p>People.h</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">People</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 初始化方法</span></span><br><span class="line"><span class="comment">//- (id) init;//任意类型</span></span><br><span class="line"><span class="comment">//虽然上面的也可以但是推荐下面</span></span><br><span class="line">- (<span class="keyword">instancetype</span>) init; <span class="comment">// 当前类型，当前是People类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义初始化方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>) initPeople:(<span class="built_in">NSString</span> *) name age:(<span class="keyword">int</span>) age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>People.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"People.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">People</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="keyword">int</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写初始化方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _age = <span class="number">23</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age = %d"</span>, _age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initPeople:(<span class="built_in">NSString</span> *)name age:(<span class="keyword">int</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _age = age;</span><br><span class="line">        _name = name;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age = %d, name = %@"</span>, _age, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>main.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"People.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        People *p1 = [[People alloc] init];</span><br><span class="line">        People * p2 = [[People alloc] initPeople:<span class="string">@"xu"</span> age:<span class="number">24</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>输出</p></blockquote><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = 23</span><br><span class="line">age = 24, name = xu</span><br></pre></td></tr></table></div></figure><h2 id="封装">封装<a href="post/iOS-Objective-C-Learn#封装"></a></h2><blockquote><p>访问修饰符</p></blockquote><div class="article-bounded"><div class="article-table"><table><thead><tr><th>声明</th><th>作用</th></tr></thead><tbody><tr><td><code>@public</code></td><td>公有的， 在类中和类外都可以使用并且可以被继承</td></tr><tr><td><code>@private</code></td><td>私有的，在类中可以使用，类外无法调用，不可以被继承</td></tr><tr><td><code>@protected</code></td><td>受保护的（默认），在类中可以使用，类外无法调用，但是可以被继承</td></tr><tr><td><code>@package</code></td><td>框架权限，在框架内相当于受保护，在框架外相当于私有</td></tr></tbody></table></div></div><blockquote><p>方法是没有访问修饰符的同c语言一样，如果不想让外部访问，去掉<code>.h</code>中的方法定义就可以了。</p></blockquote><blockquote><p>MyClass.h</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _classInt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * className;</span><br><span class="line">-(<span class="keyword">void</span>) report;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>MyClass.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)report</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"class name = %@"</span>, _className);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"class name = %d"</span>, _classInt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>main.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyClass *c = [[MyClass alloc] init];</span><br><span class="line">        c.className = <span class="string">@"My Class"</span>;</span><br><span class="line">        <span class="comment">// 使用指向来调用类中的公有成员变量</span></span><br><span class="line">        c-&gt;_classInt = <span class="number">22</span>;</span><br><span class="line">        [c report];</span><br><span class="line">    &#125;ß</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="继承">继承<a href="post/iOS-Objective-C-Learn#继承"></a></h2><blockquote><p>interface 时候 冒号 代表继承</p></blockquote><blockquote><p>父类</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> _claseInt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line">- (<span class="keyword">void</span>) report;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)report</span><br><span class="line">&#123;</span><br><span class="line">    _claseInt = <span class="number">23</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name = %@, value = %d"</span>, _name, _claseInt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>子类</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"><span class="comment">// interface 时候 冒号 代表继承</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MySubClass</span> : <span class="title">MyClass</span></span></span><br><span class="line">-(<span class="keyword">void</span>) show;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MySubClass.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MySubClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)show</span><br><span class="line">&#123;</span><br><span class="line">    _claseInt = <span class="number">100</span>;</span><br><span class="line">    [<span class="keyword">self</span> report];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>main.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MySubClass.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyClass *c = [[MyClass alloc] init];</span><br><span class="line">        c.name = <span class="string">@"xu"</span>;</span><br><span class="line">        [c report];</span><br><span class="line"></span><br><span class="line">        MySubClass *sc = [[MySubClass alloc] init];</span><br><span class="line">        sc.name = <span class="string">@"xu"</span>;</span><br><span class="line"><span class="comment">//        [sc report];</span></span><br><span class="line">        [sc show];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>输出</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = xu, value = <span class="number">23</span></span><br><span class="line">name = xu, value = <span class="number">23</span></span><br></pre></td></tr></table></div></figure><h2 id="多态">多态<a href="post/iOS-Objective-C-Learn#多态"></a></h2><blockquote><p>父类<code>Printer.h</code>  <code>Printer.m</code></p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Printer</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>) print;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Printer.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Printer</span></span></span><br><span class="line">- (<span class="keyword">void</span>)print</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我是一个打印机"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>子类<code>ColorPrinter.h</code>  <code>ColorPrinter.m</code></p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Printer.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ColorPrinter</span> : <span class="title">Printer</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ColorPrinter.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ColorPrinter</span></span></span><br><span class="line">- (<span class="keyword">void</span>)print</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> print]; <span class="comment">// 子类中调用父类的方法</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"我是一个彩色打印机"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></div></figure><blockquote><p>main.m</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ColorPrinter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        ColorPrinter *cp = [[ColorPrinter alloc] init];</span><br><span class="line">        [cp print];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父类可以引用子类型</span></span><br><span class="line">        Printer * p = [[ColorPrinter alloc] init];</span><br><span class="line">        [p print];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p>输出</p></blockquote><figure class="highlight objc"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是一个打印机</span><br><span class="line">我是一个彩色打印机</span><br><span class="line">我是一个打印机</span><br><span class="line">我是一个彩色打印机</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源代码文件扩展名对比&quot;&gt;源代码文件扩展名对比&lt;a href=&quot;post/iOS-Objective-C-Learn#源代码文件扩展名对比&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;div class=&quot;article-bounded&quot;&gt;&lt;div class=&quot;article-tabl
      
    
    </summary>
    
      <category term="iOS" scheme="https://blog.xujiaji.com/categories/iOS/"/>
    
    
      <category term="学习" scheme="https://blog.xujiaji.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="笔记" scheme="https://blog.xujiaji.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="iOS" scheme="https://blog.xujiaji.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://blog.xujiaji.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Git Commit Standard</title>
    <link href="https://blog.xujiaji.com/post/Git-Commit-Standard/index.html"/>
    <id>https://blog.xujiaji.com/post/Git-Commit-Standard/index.html</id>
    <published>2018-09-05T02:21:44.000Z</published>
    <updated>2019-04-08T06:55:24.990Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下Git的提交规范，方便以后查阅</p><a id="more"></a><h2 id="提交命令">提交命令<a href="post/Git-Commit-Standard#提交命令"></a></h2><ol><li><code>git commit -m &quot;提交修改信息&quot;</code>，这样这只能有一行信息</li><li><code>git commit</code>，会进入<code>vi</code>文本编辑器，可写多行。</li></ol><h2 id="提交信息的格式">提交信息的格式<a href="post/Git-Commit-Standard#提交信息的格式"></a></h2><blockquote><p>每次提交信息都包括三个部分：Header、Body和Footer。其中，Header 是必需的，Body 和 Footer 可以省略。</p></blockquote><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></div></figure><blockquote><p>文字描述</p></blockquote><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 标题行：50个字符以内，描述主要变更内容</span><br><span class="line">#</span><br><span class="line"># 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:</span><br><span class="line">#</span><br><span class="line"># * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等</span><br><span class="line"># * 他如何解决这个问题? 具体描述解决问题的步骤</span><br><span class="line"># * 是否存在副作用、风险?</span><br><span class="line">#</span><br><span class="line"># 尾部：如果需要的化可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。</span><br></pre></td></tr></table></div></figure><h2 id="lt-type-gt"><code>&lt;type&gt;</code><a href="post/Git-Commit-Standard#lt-type-gt"></a></h2><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">feat</td><td style="text-align:left">feature新功能</td></tr><tr><td style="text-align:left">fix</td><td style="text-align:left">修复bug</td></tr><tr><td style="text-align:left">doc</td><td style="text-align:left">仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等</td></tr><tr><td style="text-align:left">style</td><td style="text-align:left">代码格式改变，不改变代码逻辑</td></tr><tr><td style="text-align:left">refactor</td><td style="text-align:left">代码重构，没有加新功能或者修复bug</td></tr><tr><td style="text-align:left">perf</td><td style="text-align:left">优化相关，比如提升性能、体验</td></tr><tr><td style="text-align:left">test</td><td style="text-align:left">测试用例，包括单元测试、集成测试等</td></tr><tr><td style="text-align:left">chore</td><td style="text-align:left">改变构建流程、或者增加依赖库、工具等</td></tr><tr><td style="text-align:left">revert</td><td style="text-align:left">回滚到上一个版本</td></tr></tbody></table></div></div><h2 id="lt-scope-gt"><code>&lt;scope&gt;</code><a href="post/Git-Commit-Standard#lt-scope-gt"></a></h2><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">all</td><td style="text-align:left">表示影响面大 ，如修改了网络框架  会对真个程序产生影响</td></tr><tr><td style="text-align:left">loation</td><td style="text-align:left">表示影响小，某个小小的功能</td></tr><tr><td style="text-align:left">module</td><td style="text-align:left">表示会影响某个模块 如登录模块、首页模块 、用户管理模块等等</td></tr></tbody></table></div></div><h2 id="lt-subject-gt"><code>&lt;subject&gt;</code><a href="post/Git-Commit-Standard#lt-subject-gt"></a></h2><ol><li>subject是 commit 目的的简短描述，不超过50个字符。</li><li>以动词开头，第一个字母小写，使用第一人称现在时，比如change，而不是changed或changes<br>第一个字母小写</li><li>结尾不加句号”.”</li></ol><h2 id="lt-body-gt"><code>&lt;body&gt;</code><a href="post/Git-Commit-Standard#lt-body-gt"></a></h2><p>对本次 commit 的详细描述，可以分成多行。</p><h2 id="lt-footer-gt"><code>&lt;footer&gt;</code><a href="post/Git-Commit-Standard#lt-footer-gt"></a></h2><ol><li><p>并联Issue，本次提交如果和摸个issue有关系则需要写上这个，格式如下：</p><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Issue #1, #2, #3</span><br></pre></td></tr></table></div></figure></li><li><p>关闭 Issue，如果当前提交信息解决了某个issue，那么可以在 Footer 部分关闭这个 issue，关闭的格式如下：</p><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Close #1, #2, #3</span><br></pre></td></tr></table></div></figure></li></ol><h2 id="完整例子">完整例子<a href="post/Git-Commit-Standard#完整例子"></a></h2><figure class="highlight plain"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">feat(all): add login</span><br><span class="line"></span><br><span class="line">add login in project</span><br><span class="line"></span><br><span class="line">- qq login</span><br><span class="line">- weixin login</span><br><span class="line">- sina login</span><br><span class="line"></span><br><span class="line">Issue #1, #2</span><br><span class="line">Close #1, #2</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下Git的提交规范，方便以后查阅&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://blog.xujiaji.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://blog.xujiaji.com/tags/Git/"/>
    
      <category term="笔记" scheme="https://blog.xujiaji.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS用UISegmentedControl设计一个顶部分页导航-Swift（翻译文）</title>
    <link href="https://blog.xujiaji.com/post/ios-uisegmented-design/index.html"/>
    <id>https://blog.xujiaji.com/post/ios-uisegmented-design/index.html</id>
    <published>2018-07-23T06:36:32.000Z</published>
    <updated>2019-04-08T06:55:47.295Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：《<a href="https://www.codementor.io/kevinfarst/designing-a-button-bar-style-uisegmentedcontrol-in-swift-cg6cf0dok" target="_blank" rel="noopener">Designing a Button Bar-Style UISegmentedControl in Swift</a>》</p></blockquote><a id="more"></a><p>我正在做一个项目，项目里面我想用<code>UISegmentedControl</code>做一个简洁的“底部条形样式”的设计。它没有边框，所选下方有一个小长条，当你选择一个元素后他会相应的移动过去。我找到几个非常好的第三方库来处理这个问题，但是我在这些类库上遇到了一些麻烦，于是我尝试自己做。我以自动布局约束，以swift代码方式构建视图，并为了简单起见，将所有主题内联完成。</p><h2 id="准备开始">准备开始<a href="post/ios-uisegmented-design#准备开始"></a></h2><p>我们在Swift playground中做这些事情，因此让我们从基本的东西开始，创建一个新的UIView并且添加一个带有3个片段的UISegmentedControl，另外需要注意，我构建约束的方式是假设所有片段长度想等的情况。如果不是的话，会导致底部长条在相应的位置上变得太宽或不够宽。</p><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> PlaygroundSupport</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器View</span></span><br><span class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">400</span>, height: <span class="number">100</span>))</span><br><span class="line">view.backgroundColor = .white</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> segmentedControl = <span class="type">UISegmentedControl</span>()</span><br><span class="line"><span class="comment">// 添加片段</span></span><br><span class="line">segmentedControl.insertSegment(withTitle: <span class="string">"One"</span>, at: <span class="number">0</span>, animated: <span class="literal">true</span>)</span><br><span class="line">segmentedControl.insertSegment(withTitle: <span class="string">"Two"</span>, at: <span class="number">1</span>, animated: <span class="literal">true</span>)</span><br><span class="line">segmentedControl.insertSegment(withTitle: <span class="string">"Three"</span>, at: <span class="number">2</span>, animated: <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 让第一个片段默认选中</span></span><br><span class="line">segmentedControl.selectedSegmentIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置为false，我们才能使用自动布局约束</span></span><br><span class="line">segmentedControl.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加UISegmentedControl到容器View</span></span><br><span class="line">view.addSubview(segmentedControl)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 约束到容器的顶部</span></span><br><span class="line">segmentedControl.topAnchor.constraint(equalTo: view.topAnchor).isActive = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 限制为容器view的宽度</span></span><br><span class="line">segmentedControl.widthAnchor.constraint(equalTo: view.widthAnchor).isActive = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 设置高度</span></span><br><span class="line">segmentedControl.heightAnchor.constraint(equalToConstant: <span class="number">40</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="type">PlaygroundPage</span>.current.liveView = view</span><br></pre></td></tr></table></div></figure><p>此时实时窗口已经为我们展示了基本的<code>UISegmentedControl</code>。不要忘记将<code>isActive</code>属性附加到每个自动布局约束，其值为true，否则他们将不起作用。<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/ios-uisegmented-design/basic-uisegmentedcontrol.png" alt="Basic UISegmentedControl"></p><h2 id="颜色、字体和边框Oh-My！">颜色、字体和边框Oh My！<a href="post/ios-uisegmented-design#颜色、字体和边框Oh-My！"></a></h2><p>接下来，让我们删除掉<code>backgroundColor</code>和<code>tintColor</code>，删除后边框和已选择的片段背景颜色将会消失。<br><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将下面的代码添加到 selectedSegmentIndex下面</span></span><br><span class="line">segmentedControl.backgroundColor = .clear</span><br><span class="line">segmentedControl.tintColor = .clear</span><br></pre></td></tr></table></div></figure></p><p>如果你看实时窗口，我们删除了<code>tintColor</code>后，<code>UISegmentedControl</code>已经消失，现在没有颜色了。要恢复标签，让我们更改所选片段和未选片段的字体、文本颜色和大小。<br><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加这些代码到 segmentedControl.tintColor = .clear 后</span></span><br><span class="line">segmentedControl.setTitleTextAttributes([</span><br><span class="line">    <span class="type">NSAttributedStringKey</span>.font: <span class="type">UIFont</span>(name: <span class="string">"DINCondensed-Bold"</span>, size: <span class="number">18</span>)!,</span><br><span class="line">    <span class="type">NSAttributedStringKey</span>.foregroundColor: <span class="type">UIColor</span>.lightGray</span><br><span class="line">    ], <span class="keyword">for</span>: .normal)</span><br><span class="line"></span><br><span class="line">segmentedControl.setTitleTextAttributes([</span><br><span class="line">    <span class="type">NSAttributedStringKey</span>.font : <span class="type">UIFont</span>(name: <span class="string">"DINCondensed-Bold"</span>, size: <span class="number">18</span>)!,</span><br><span class="line">    <span class="type">NSAttributedStringKey</span>.foregroundColor: <span class="type">UIColor</span>.orange</span><br><span class="line">    ], <span class="keyword">for</span>: .selected)</span><br></pre></td></tr></table></div></figure></p><p><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/ios-uisegmented-design/change-color-font.png" alt="change-color-font"><br>到这儿差不多了！现在我们必须在所选段下方添加一个长条栏。</p><h2 id="为选定片段底部添加长条">为选定片段底部添加长条<a href="post/ios-uisegmented-design#为选定片段底部添加长条"></a></h2><p>这个长条只是一个简单的UIView，然后将其<code>backgroundColor</code>与其所选片段字体的颜色相匹配。我们将选择的片段字体颜色和长条都设置为橙色。并且我们要为长条设置<code>translatesAutoresizingMaskIntoConstraints</code>为false。<br><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buttonBar = <span class="type">UIView</span>()</span><br><span class="line"><span class="comment">// 设置为false，我们才能使用自动布局约束</span></span><br><span class="line">buttonBar.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">buttonBar.backgroundColor = <span class="type">UIColor</span>.orange</span><br></pre></td></tr></table></div></figure></p><p>接下来，将<code>buttonBar</code>作为子View添加到容器view中<br><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加到 view.addSubview(segmentedControl)之后</span></span><br><span class="line">view.addSubview(buttonBar)</span><br></pre></td></tr></table></div></figure></p><p>最终，我们需要给它个宽度、高度和位置，在<code>segmentedControl</code>之后添加这些约束<br><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约束它的顶部位置在片段的底部位置</span></span><br><span class="line">buttonBar.topAnchor.constraint(equalTo: segmentedControl.bottomAnchor).isActive = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 设置长条的高度</span></span><br><span class="line">buttonBar.heightAnchor.constraint(equalToConstant: <span class="number">5</span>).isActive = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 约束它的左侧和片段的左侧重合</span></span><br><span class="line">buttonBar.leftAnchor.constraint(equalTo: segmentedControl.leftAnchor).isActive = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 约束它的宽度 = 片段容器宽度 / 片段个数</span></span><br><span class="line">buttonBar.widthAnchor.constraint(equalTo: segmentedControl.widthAnchor, multiplier: <span class="number">1</span> / <span class="type">CGFloat</span>(segmentedControl.numberOfSegments)).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></div></figure></p><p>正如最后那条注释所说，我们需要长条的宽度为<code>segmentedControl</code>的宽度除以片段个个数。这保证了长条宽度将与单个片段的宽度完全匹配，同样这里是假设所有的段都是想等的宽度。<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/ios-uisegmented-design/added-bar.png" alt="added-bar"><br>初始视图现在已完成！最后一步，我们需要让长条随所选的片段移动。</p><h2 id="长条栏动画">长条栏动画<a href="post/ios-uisegmented-design#长条栏动画"></a></h2><p>当所选片段发生改变时，<code>segmentedControl</code>需要调用一个函数来处理长条栏在x轴上的位置转换，使其跑到选择的片段下方。定义个<code>Responder</code>类，并添加方法，然后在<code>segmentedControl</code>变量上添加回调，<code>segmentedControl</code>的值改变时会触发。<br><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在import声明下方</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Responder</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">segmentedControlValueChanged</span><span class="params">(<span class="number">_</span> sender: UISegmentedControl)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> responder = <span class="type">Responder</span>()</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 在PlaygroundPage.current.liveView = view声明的上方</span></span><br><span class="line">segmentedControl.addTarget(responder, action: #selector(responder.segmentedControlValueChanged(<span class="number">_</span>:)), <span class="keyword">for</span>: <span class="type">UIControlEvents</span>.valueChanged)</span><br></pre></td></tr></table></div></figure></p><p>一定要确保<code>sender</code>作为方法参数类型，因为我们需要在调用函数时访问它。最后让我们来完成最后一块拼图，<code>buttonBar</code>在x轴的移动，它将移动到被选中的片段下<br><figure class="highlight swift"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">segmentedControlValueChanged</span><span class="params">(<span class="number">_</span> sender: UISegmentedControl)</span></span> &#123;</span><br><span class="line">  <span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>) &#123;</span><br><span class="line">      buttonBar.frame.origin.x = (segmentedControl.frame.width / <span class="type">CGFloat</span>(segmentedControl.numberOfSegments)) * <span class="type">CGFloat</span>(segmentedControl.selectedSegmentIndex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p><p>长条因该去的x轴位置 = (<code>segmentedControl</code>的宽度 / 片段个数) * 当前片段的下标</p><p>瞧瞧！我们的动画按钮栏出来了<br><img src="https://xujiaji.oss-accelerate.aliyuncs.com/blog/ios-uisegmented-design/display.gif" alt="finished"></p><h2 id="结论">结论<a href="post/ios-uisegmented-design#结论"></a></h2><p>我希望这篇文章所提供的信息，能作为你在看了许多类库或iOS应用后的一个DIY解决方案。你可以将这里的<code>UISegmentedControl</code>连接到<code>UIPageViewController</code>或<code>UIScrollView</code>作为分段内容直接移动的方式。你这可以在<a href="https://gist.github.com/kfarst/9f8a1eb59cce2004b15f0b682c92eeed" target="_blank" rel="noopener">这里</a>找到playgroud代码在Github Gist，祝您iOS开发顺利！</p><hr><blockquote><p>补充说明：下面链接到的是我在练习的时候写的代码，供参考！</p></blockquote><p><a href="https://github.com/xujiaji/Learn-iOS/blob/master/TabSegmentedControl.playground/Contents.swift" target="_blank" rel="noopener">https://github.com/xujiaji/Learn-iOS/blob/master/TabSegmentedControl.playground/Contents.swift</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文：《&lt;a href=&quot;https://www.codementor.io/kevinfarst/designing-a-button-bar-style-uisegmentedcontrol-in-swift-cg6cf0dok&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Designing a Button Bar-Style UISegmentedControl in Swift&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://blog.xujiaji.com/categories/iOS/"/>
    
    
      <category term="翻译" scheme="https://blog.xujiaji.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="iOS" scheme="https://blog.xujiaji.com/tags/iOS/"/>
    
      <category term="UI" scheme="https://blog.xujiaji.com/tags/UI/"/>
    
      <category term="Swift" scheme="https://blog.xujiaji.com/tags/Swift/"/>
    
  </entry>
  
</feed>
